<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Whack-a-Ghoul ‚Äî Afterverse Arcade</title>
<link href="https://fonts.googleapis.com/css2?family=Creepster&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0a0a; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
canvas { display: block; max-width: 100vw; max-height: 100vh; object-fit: contain; cursor: crosshair; touch-action: none; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = 560, H = 700;
canvas.width = W; canvas.height = H;

// Audio
class AudioMgr {
  constructor() {
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    this.muted = false;
    this.volume = 0.5;
  }
  resume() { if (this.ctx.state === 'suspended') this.ctx.resume(); }
  play(freq, dur, type='square', vol=0.3) {
    if (this.muted) return;
    const o = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = vol * this.volume;
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
    o.connect(g); g.connect(this.ctx.destination);
    o.start(); o.stop(this.ctx.currentTime + dur);
  }
  whack() { this.play(500, 0.08, 'square', 0.5); setTimeout(() => this.play(300, 0.06), 50); }
  miss() { this.play(150, 0.15, 'sawtooth', 0.3); }
  bonusWhack() { this.play(800, 0.1, 'square', 0.5); setTimeout(() => this.play(1000, 0.1), 80); }
  penaltyWhack() { this.play(100, 0.3, 'sawtooth', 0.5); }
  gameOver() { [300,250,200,150].forEach((f,i) => setTimeout(() => this.play(f, 0.3, 'sawtooth', 0.5), i*200)); }
  start() { [330,440,550,660].forEach((f,i) => setTimeout(() => this.play(f, 0.1, 'square', 0.4), i*80)); }
  tick() { this.play(600, 0.03, 'triangle', 0.15); }
}
const audio = new AudioMgr();

// Grid: 3x3 holes
const GRID_COLS = 3, GRID_ROWS = 3;
const HOLE_W = 120, HOLE_H = 80;
const GRID_START_X = (W - GRID_COLS * (HOLE_W + 30) + 30) / 2;
const GRID_START_Y = 200;
const HOLE_GAP_X = HOLE_W + 30, HOLE_GAP_Y = HOLE_H + 60;

// Ghoul types
const GHOULS = [
  { emoji: 'üíÄ', points: 10, color: '#e9d5ff', name: 'Skull' },
  { emoji: 'üëª', points: 15, color: '#c084fc', name: 'Ghost' },
  { emoji: 'ü¶á', points: 20, color: '#a855f7', name: 'Bat' },
  { emoji: '‚ò†Ô∏è', points: 25, color: '#7c3aed', name: 'Death' },
  { emoji: 'üï∑Ô∏è', points: 30, color: '#d946ef', name: 'Spider' },
];
const BONUS_GHOUL = { emoji: 'üëë', points: 50, color: '#eab308', name: 'King Skull' };
const PENALTY_GHOUL = { emoji: 'ü™¶', points: -20, color: '#6b7280', name: 'Tombstone' };

// State
let state = 'title';
let score = 0, bestScore = 0, combo = 0, maxCombo = 0;
let timeLeft = 60; // seconds
let lastTick = 0;
let holes = [];
let particles = [];
let hitTexts = [];
let spawnTimer = 0, spawnInterval = 90; // frames
let countdownNum = 3, countdownTimer = 0;
let difficulty = 1;

try { bestScore = parseInt(localStorage.getItem('whackghoul_best')) || 0; } catch(e) {}

function initHoles() {
  holes = [];
  for (let r = 0; r < GRID_ROWS; r++) {
    for (let c = 0; c < GRID_COLS; c++) {
      holes.push({
        x: GRID_START_X + c * HOLE_GAP_X,
        y: GRID_START_Y + r * HOLE_GAP_Y,
        ghoul: null,
        timer: 0,
        popHeight: 0, // 0 to 1 animation
        state: 'empty' // empty, rising, up, falling
      });
    }
  }
}

function spawnGhoul() {
  const empties = holes.filter(h => h.state === 'empty');
  if (empties.length === 0) return;
  const hole = empties[Math.floor(Math.random() * empties.length)];

  // Pick ghoul type
  const roll = Math.random();
  if (roll < 0.08) {
    hole.ghoul = BONUS_GHOUL;
    hole.timer = 40 + Math.floor(30 / difficulty);
  } else if (roll < 0.18) {
    hole.ghoul = PENALTY_GHOUL;
    hole.timer = 80;
  } else {
    const idx = Math.min(Math.floor(Math.random() * (2 + difficulty)), GHOULS.length - 1);
    hole.ghoul = GHOULS[idx];
    hole.timer = 60 + Math.floor(40 / difficulty);
  }
  hole.state = 'rising';
  hole.popHeight = 0;
}

function whackHole(hole) {
  if (!hole.ghoul || hole.state === 'falling') return;

  const ghoul = hole.ghoul;
  const cx = hole.x + HOLE_W/2, cy = hole.y - 10;

  if (ghoul === PENALTY_GHOUL) {
    // Hit tombstone ‚Äî penalty!
    score = Math.max(0, score + ghoul.points);
    combo = 0;
    audio.penaltyWhack();
    hitTexts.push({ x: cx, y: cy, text: ghoul.points.toString(), color: '#f87171', life: 1 });
    spawnParticles(cx, cy, '#6b7280', 6);
  } else {
    const pts = ghoul.points * (1 + Math.floor(combo / 5));
    score += pts;
    combo++;
    maxCombo = Math.max(maxCombo, combo);
    if (ghoul === BONUS_GHOUL) audio.bonusWhack(); else audio.whack();
    hitTexts.push({ x: cx, y: cy, text: '+' + pts, color: ghoul.color, life: 1 });
    spawnParticles(cx, cy, ghoul.color, 8);
  }

  hole.state = 'falling';
  hole.timer = 10;
}

function spawnParticles(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random()-0.5)*8,
      vy: -Math.random()*6-2,
      life: 1, color,
      size: Math.random()*4+2
    });
  }
}

// Input
function getCanvasPos(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = W / rect.width, scaleY = H / rect.height;
  return {
    x: (e.clientX - rect.left) * scaleX,
    y: (e.clientY - rect.top) * scaleY
  };
}

canvas.addEventListener('click', e => {
  audio.resume();
  if (state === 'title') { startGame(); return; }
  if (state === 'gameover') { state = 'title'; return; }
  if (state !== 'playing') return;

  const pos = getCanvasPos(e);
  let hit = false;
  for (const hole of holes) {
    if (hole.state === 'up' || hole.state === 'rising') {
      const hx = hole.x, hy = hole.y - 50 * hole.popHeight;
      if (pos.x >= hx && pos.x <= hx + HOLE_W && pos.y >= hy && pos.y <= hy + HOLE_H + 20) {
        whackHole(hole);
        hit = true;
        break;
      }
    }
  }
  if (!hit && state === 'playing') {
    combo = 0;
    audio.miss();
  }
});

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  audio.resume();
  if (state === 'title') { startGame(); return; }
  if (state === 'gameover') { state = 'title'; return; }
  if (state !== 'playing') return;

  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const scaleX = W / rect.width, scaleY = H / rect.height;
  const pos = { x: (touch.clientX - rect.left) * scaleX, y: (touch.clientY - rect.top) * scaleY };

  let hit = false;
  for (const hole of holes) {
    if (hole.state === 'up' || hole.state === 'rising') {
      const hx = hole.x, hy = hole.y - 50 * hole.popHeight;
      if (pos.x >= hx && pos.x <= hx + HOLE_W && pos.y >= hy && pos.y <= hy + HOLE_H + 20) {
        whackHole(hole);
        hit = true;
        break;
      }
    }
  }
  if (!hit) { combo = 0; audio.miss(); }
});

document.addEventListener('keydown', e => {
  if (e.key === 'm' || e.key === 'M') { audio.muted = !audio.muted; return; }
  if (state === 'title' && (e.key === 'e' || e.key === 'E' || e.key === ' ')) startGame();
  if (state === 'gameover' && (e.key === 'e' || e.key === 'E' || e.key === ' ')) state = 'title';
});

function startGame() {
  audio.resume();
  audio.start();
  initHoles();
  score = 0; combo = 0; maxCombo = 0;
  timeLeft = 60; lastTick = Date.now();
  spawnTimer = 0; difficulty = 1;
  particles = []; hitTexts = [];
  state = 'countdown';
  countdownNum = 3; countdownTimer = 0;
}

function update() {
  if (state === 'countdown') {
    countdownTimer++;
    if (countdownTimer >= 60) { countdownTimer = 0; countdownNum--; }
    if (countdownNum <= 0) { state = 'playing'; lastTick = Date.now(); }
    return;
  }
  if (state !== 'playing') return;

  // Timer
  const now = Date.now();
  if (now - lastTick >= 1000) {
    timeLeft--;
    lastTick = now;
    if (timeLeft <= 5 && timeLeft > 0) audio.tick();
    if (timeLeft <= 0) {
      state = 'gameover';
      audio.gameOver();
      if (score > bestScore) { bestScore = score; try { localStorage.setItem('whackghoul_best', bestScore); } catch(e) {} }
      return;
    }
  }

  // Difficulty ramp
  difficulty = 1 + (60 - timeLeft) * 0.04;
  spawnInterval = Math.max(20, 70 - (60 - timeLeft));

  // Spawn
  spawnTimer++;
  if (spawnTimer >= spawnInterval) {
    spawnTimer = 0;
    spawnGhoul();
    // Spawn extra ghouls at higher difficulty
    if (difficulty > 2 && Math.random() > 0.5) spawnGhoul();
  }

  // Update holes
  for (const hole of holes) {
    if (hole.state === 'rising') {
      hole.popHeight = Math.min(1, hole.popHeight + 0.12);
      if (hole.popHeight >= 1) hole.state = 'up';
    }
    if (hole.state === 'up') {
      hole.timer--;
      if (hole.timer <= 0) {
        hole.state = 'falling';
        hole.timer = 10;
        // Missed ‚Äî break combo only for non-penalty ghouls
        if (hole.ghoul !== PENALTY_GHOUL) combo = 0;
      }
    }
    if (hole.state === 'falling') {
      hole.popHeight = Math.max(0, hole.popHeight - 0.15);
      if (hole.popHeight <= 0) {
        hole.state = 'empty';
        hole.ghoul = null;
      }
    }
  }

  // Particles
  particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.vy += 0.2; p.life -= 0.025; });
  particles = particles.filter(p => p.life > 0);

  // Hit texts
  hitTexts.forEach(t => { t.y -= 1.5; t.life -= 0.02; });
  hitTexts = hitTexts.filter(t => t.life > 0);
}

function drawHole(hole) {
  const x = hole.x, y = hole.y;

  // Grave mound
  ctx.fillStyle = '#2d1b00';
  ctx.beginPath();
  ctx.ellipse(x + HOLE_W/2, y + HOLE_H/2 + 10, HOLE_W/2 + 5, 20, 0, 0, Math.PI*2);
  ctx.fill();

  // Dark hole
  ctx.fillStyle = '#0a0505';
  ctx.beginPath();
  ctx.ellipse(x + HOLE_W/2, y + HOLE_H/2, HOLE_W/2 - 5, 15, 0, 0, Math.PI*2);
  ctx.fill();

  // Ghoul popping up
  if (hole.ghoul && hole.popHeight > 0) {
    ctx.save();
    // Clip to hole area (ghoul should appear to come from hole)
    ctx.beginPath();
    ctx.rect(x - 10, y - 60, HOLE_W + 20, HOLE_H + 10);
    ctx.clip();

    const popY = y - 50 * hole.popHeight;
    const size = 48;

    // Glow
    ctx.shadowColor = hole.ghoul.color;
    ctx.shadowBlur = 15;

    // Emoji
    ctx.font = `${size}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(hole.ghoul.emoji, x + HOLE_W/2, popY + 10);
    ctx.shadowBlur = 0;

    // Wobble for bonus
    if (hole.ghoul === BONUS_GHOUL) {
      ctx.globalAlpha = 0.5 + Math.sin(Date.now()/100)*0.3;
      ctx.fillStyle = '#eab308';
      ctx.font = '12px Creepster';
      ctx.fillText('‚òÖ BONUS ‚òÖ', x + HOLE_W/2, popY - 20);
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  }
}

function drawMuteIndicator() {
  ctx.font = '12px monospace';
  ctx.textAlign = 'right';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText(audio.muted ? 'üîá M ‚Äî Muted' : 'üîä M ‚Äî Sound', W - 8, H - 8);
}

function drawTitle() {
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, W, H);

  const t = Date.now()/1000;

  // Floating ghouls
  for (let i = 0; i < 5; i++) {
    ctx.font = '36px serif';
    ctx.textAlign = 'center';
    ctx.globalAlpha = 0.15;
    ctx.fillText(GHOULS[i].emoji, W*(i+1)/6, 130 + Math.sin(t+i)*25);
  }
  ctx.globalAlpha = 1;

  ctx.font = '52px Creepster';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#a855f7';
  ctx.shadowColor = '#a855f7';
  ctx.shadowBlur = 30;
  ctx.fillText('WHACK-A-GHOUL', W/2, 230);
  ctx.shadowBlur = 0;

  ctx.font = '18px Creepster';
  ctx.fillStyle = '#c084fc';
  ctx.fillText('Smash the skulls. Dodge the tombstones.', W/2, 275);
  ctx.fillText('60 seconds. Build combos for bonus points!', W/2, 300);

  if (bestScore > 0) {
    ctx.font = '20px Creepster';
    ctx.fillStyle = '#eab308';
    ctx.fillText('üèÜ Best: ' + bestScore, W/2, 350);
  }

  ctx.font = '16px Creepster';
  ctx.fillStyle = '#e9d5ff';
  ctx.fillText('Click or Tap the ghouls to whack them!', W/2, 430);
  ctx.fillText('üëë = Bonus Points | ü™¶ = Penalty!', W/2, 455);
  ctx.fillText('M ‚Äî Mute', W/2, 480);

  const pulse = Math.sin(t*3)*0.3+0.7;
  ctx.globalAlpha = pulse;
  ctx.font = '28px Creepster';
  ctx.fillStyle = '#f87171';
  ctx.fillText('Press E or Tap to Start', W/2, 550);
  ctx.globalAlpha = 1;

  ctx.font = '14px Creepster';
  ctx.fillStyle = 'rgba(168,85,247,0.6)';
  ctx.fillText('‚ò† A JURN Production ‚ò†', W/2, H - 25);

  drawMuteIndicator();
}

function drawGameOver() {
  ctx.fillStyle = 'rgba(10,10,10,0.88)';
  ctx.fillRect(0, 0, W, H);

  ctx.font = '52px Creepster';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#f87171';
  ctx.shadowColor = '#f87171';
  ctx.shadowBlur = 25;
  ctx.fillText('TIME\'S UP!', W/2, 200);
  ctx.shadowBlur = 0;

  ctx.font = '28px Creepster';
  ctx.fillStyle = '#e9d5ff';
  ctx.fillText('Score: ' + score, W/2, 270);
  ctx.fillText('Max Combo: ' + maxCombo + 'x', W/2, 310);

  if (score >= bestScore && score > 0) {
    ctx.fillStyle = '#eab308';
    ctx.font = '24px Creepster';
    ctx.fillText('üèÜ NEW BEST!', W/2, 360);
  }

  const t = Date.now()/1000;
  ctx.globalAlpha = Math.sin(t*3)*0.3+0.7;
  ctx.font = '22px Creepster';
  ctx.fillStyle = '#c084fc';
  ctx.fillText('Press E or Tap to Continue', W/2, 450);
  ctx.globalAlpha = 1;

  drawMuteIndicator();
}

function render() {
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, W, H);

  if (state === 'title') { drawTitle(); return; }
  if (state === 'gameover') { drawGameOver(); return; }

  // HUD
  ctx.font = '22px Creepster';
  ctx.textAlign = 'left';
  ctx.fillStyle = '#a855f7';
  ctx.fillText('Score: ' + score, 20, 40);

  ctx.textAlign = 'center';
  // Timer ‚Äî flash red when low
  if (timeLeft <= 10) {
    ctx.fillStyle = '#f87171';
    ctx.shadowColor = '#f87171';
    ctx.shadowBlur = timeLeft <= 5 ? 15 : 0;
  } else {
    ctx.fillStyle = '#e9d5ff';
  }
  ctx.fillText('‚è± ' + timeLeft + 's', W/2, 40);
  ctx.shadowBlur = 0;

  ctx.textAlign = 'right';
  ctx.fillStyle = combo >= 5 ? '#eab308' : '#c084fc';
  ctx.fillText('Combo: ' + combo + 'x', W - 20, 40);

  // Difficulty indicator
  ctx.textAlign = 'center';
  ctx.font = '14px Creepster';
  ctx.fillStyle = 'rgba(168,85,247,0.5)';
  const lvl = Math.floor(difficulty);
  ctx.fillText('‚ò†'.repeat(Math.min(lvl, 5)), W/2, 65);

  // Holes
  for (const hole of holes) drawHole(hole);

  // Particles
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;

  // Hit texts
  hitTexts.forEach(t => {
    ctx.globalAlpha = t.life;
    ctx.font = '24px Creepster';
    ctx.textAlign = 'center';
    ctx.fillStyle = t.color;
    ctx.shadowColor = t.color;
    ctx.shadowBlur = 10;
    ctx.fillText(t.text, t.x, t.y);
    ctx.shadowBlur = 0;
  });
  ctx.globalAlpha = 1;

  // Countdown
  if (state === 'countdown') {
    ctx.fillStyle = 'rgba(10,10,10,0.6)';
    ctx.fillRect(0, 0, W, H);
    const colors = ['#22c55e','#eab308','#f87171'];
    const scale = 1 + (countdownTimer/60)*0.5;
    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.scale(scale, scale);
    ctx.font = '80px Creepster';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = colors[3-countdownNum] || '#f87171';
    ctx.fillText(countdownNum, 0, 0);
    ctx.restore();
  }

  drawMuteIndicator();
}

function loop() { update(); render(); requestAnimationFrame(loop); }
loop();
</script>
</body>
</html>