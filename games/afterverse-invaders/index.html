<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Afterverse Invaders ‚Äî Afterverse Arcade</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Creepster&display=swap');
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center;
  min-height: 100vh; font-family: 'Creepster', cursive; overflow: hidden;
}
canvas { border: 2px solid rgba(57,255,20,0.2); border-radius: 8px; box-shadow: 0 0 30px rgba(57,255,20,0.1), 0 0 60px rgba(0,0,0,0.5); }
#ui {
  position: absolute; top: 0; left: 0; right: 0; display: flex; justify-content: space-between; padding: 15px 20px;
  pointer-events: none; z-index: 10;
}
.score-label { color: #39ff14; font-size: 1.4rem; text-shadow: 0 0 10px rgba(57,255,20,0.5); letter-spacing: 2px; }
.lives-label { color: #ff1744; font-size: 1.2rem; text-shadow: 0 0 10px rgba(255,23,68,0.5); }
.ghost-counter { color: #00bfff; font-size: 1rem; text-shadow: 0 0 10px rgba(0,191,255,0.5); position: absolute; top: 38px; left: 20px; }
#back-link {
  position: fixed; bottom: 15px; left: 50%; transform: translateX(-50%);
  color: #888; text-decoration: none; font-family: 'Inter', sans-serif; font-size: 0.85rem; transition: color 0.3s;
}
#back-link:hover { color: #39ff14; }
#mobile-controls {
  display: none; position: fixed; bottom: 50px; left: 0; right: 0; z-index: 100; padding: 0 20px;
}
.m-row { display: flex; justify-content: space-between; align-items: center; }
.m-btn {
  background: rgba(191,0,255,0.15); border: 1px solid rgba(191,0,255,0.3); border-radius: 12px;
  color: #bf00ff; font-size: 1.8rem; width: 65px; height: 65px;
  display: flex; align-items: center; justify-content: center;
  cursor: pointer; user-select: none; -webkit-user-select: none; touch-action: manipulation;
}
.m-btn:active { background: rgba(191,0,255,0.35); }
.m-fire {
  background: rgba(255,23,68,0.2); border-color: rgba(255,23,68,0.4); color: #ff1744;
  width: 80px; height: 80px; border-radius: 50%; font-size: 2rem;
}
.m-fire:active { background: rgba(255,23,68,0.5); }
@media (pointer: coarse) { #mobile-controls { display: block; } }
#loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
  color: #bf00ff; font-size: 1.5rem; text-shadow: 0 0 15px rgba(191,0,255,0.5); }
</style>
</head>
<body>
<video id="bg-video" autoplay muted loop playsinline style="position:fixed;top:50%;left:50%;min-width:100%;min-height:100%;transform:translate(-50%,-50%);z-index:-1;opacity:0.25;object-fit:cover;pointer-events:none;">
  <source src="animatedbackground.mp4" type="video/mp4">
</video>
<div id="loading">Loading the tour van...</div>
<div id="ui" style="display:none;">
  <div>
    <div class="score-label">SCORE: <span id="score">0</span></div>
    <div class="ghost-counter">üëª <span id="ghostKills">0</span>/3</div>
  </div>
  <div style="display:flex;gap:12px;align-items:center;">
    <div class="lives-label">LIVES: <span id="lives">3</span></div>
    <div class="lives-label" style="color:#00e5ff;">üõ°Ô∏è <span id="shieldCount">0</span></div>
  </div>
</div>
<canvas id="game" style="display:none;"></canvas>
<div id="mobile-controls">
  <div class="m-row">
    <div class="m-btn" id="m-left">‚óÄ</div>
    <div class="m-btn m-fire" id="m-fire">üéµ</div>
    <div class="m-btn" id="m-right">‚ñ∂</div>
  </div>
</div>
<a id="back-link" href="../../games.html">‚Üê Back to Afterverse Arcade</a>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const ghostKillsEl = document.getElementById('ghostKills');
const shieldCountEl = document.getElementById('shieldCount');
const loadingEl = document.getElementById('loading');
const uiEl = document.getElementById('ui');

let W, H;
function resize() {
  W = Math.min(window.innerWidth - 20, 616);
  H = Math.min(window.innerHeight - 80, 704);
  canvas.width = W; canvas.height = H;
}
resize();

// === AUDIO ===
// Boss entrance ‚Äî synth fart barrage (no MP3 dependency)
function playEvilLaugh() {
  const actx = new (window.AudioContext || window.webkitAudioContext)();
  // 3-4 rapid descending fart blasts
  const farts = [
    { t: 0,    freq: 120, dur: 0.18 },
    { t: 0.22, freq: 95,  dur: 0.22 },
    { t: 0.50, freq: 70,  dur: 0.28 },
    { t: 0.85, freq: 50,  dur: 0.35 },
  ];
  farts.forEach(f => {
    // Main oscillator ‚Äî low sawtooth for that raspy buzz
    const osc = actx.createOscillator();
    const gain = actx.createGain();
    const filter = actx.createBiquadFilter();
    osc.type = 'sawtooth';
    const t0 = actx.currentTime + f.t;
    osc.frequency.setValueAtTime(f.freq, t0);
    osc.frequency.exponentialRampToValueAtTime(f.freq * 0.4, t0 + f.dur);
    // Lowpass filter for muffled rumble
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(300, t0);
    filter.frequency.exponentialRampToValueAtTime(80, t0 + f.dur);
    // Volume envelope ‚Äî quick attack, slow decay
    gain.gain.setValueAtTime(0.325, t0);
    gain.gain.linearRampToValueAtTime(0.39, t0 + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.01, t0 + f.dur);
    osc.connect(filter); filter.connect(gain); gain.connect(actx.destination);
    osc.start(t0); osc.stop(t0 + f.dur + 0.05);
    // Sub-bass rumble underneath each fart
    const sub = actx.createOscillator();
    const subG = actx.createGain();
    sub.type = 'sine';
    sub.frequency.setValueAtTime(f.freq * 0.5, t0);
    sub.frequency.exponentialRampToValueAtTime(25, t0 + f.dur);
    subG.gain.setValueAtTime(0.195, t0);
    subG.gain.exponentialRampToValueAtTime(0.001, t0 + f.dur);
    sub.connect(subG); subG.connect(actx.destination);
    sub.start(t0); sub.stop(t0 + f.dur + 0.05);
  });
}

// Background music ‚Äî loops, starts on first user interaction
const bgMusic = new Audio('afterverseinvaders.mp3');
bgMusic.loop = true; bgMusic.volume = 0.35; bgMusic.preload = 'auto';
let bgMusicStarted = false;
function startBgMusic() {
  if (!bgMusicStarted && gameState === 'playing') { bgMusic.play().catch(()=>{}); bgMusicStarted = true; }
}
const snares = ['../jurnbreaker/snare.mp3','../jurnbreaker/snare1.mp3','../jurnbreaker/snare2.mp3','../jurnbreaker/snare3.mp3'];
const snarePool = [];
snares.forEach(src => { for (let i = 0; i < 3; i++) { const a = new Audio(src); a.volume = 0.35; a.preload = 'auto'; snarePool.push(a); } });
let snareIdx = 0;
function playSnare() { const a = snarePool[snareIdx % snarePool.length]; a.currentTime = 0; a.play().catch(()=>{}); snareIdx++; }

const gameOverSound = new Audio('../jurnbreaker/gameover.mp3');
gameOverSound.volume = 0.6; gameOverSound.preload = 'auto';
function playGameOver() { gameOverSound.currentTime = 0; gameOverSound.play().catch(()=>{}); }

let audioCtx;
function playShootSound() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
  osc.connect(gain); gain.connect(audioCtx.destination);
  osc.type = 'square';
  osc.frequency.setValueAtTime(880, audioCtx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(220, audioCtx.currentTime + 0.08);
  gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
  osc.start(audioCtx.currentTime); osc.stop(audioCtx.currentTime + 0.1);
}

function playBossSpawnSound() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
  osc.connect(gain); gain.connect(audioCtx.destination);
  osc.type = 'sawtooth';
  osc.frequency.setValueAtTime(80, audioCtx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.6);
  gain.gain.setValueAtTime(0.26, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.7);
  osc.start(audioCtx.currentTime); osc.stop(audioCtx.currentTime + 0.7);
}

function playBossDeathSound() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  for (let i = 0; i < 4; i++) {
    const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.type = 'square';
    osc.frequency.setValueAtTime(200 + i * 100, audioCtx.currentTime + i * 0.1);
    osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + i * 0.1 + 0.3);
    gain.gain.setValueAtTime(0.15, audioCtx.currentTime + i * 0.1);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + i * 0.1 + 0.35);
    osc.start(audioCtx.currentTime + i * 0.1); osc.stop(audioCtx.currentTime + i * 0.1 + 0.35);
  }
}

// === SPRITES ===
const vanLeft = new Image(); const vanRight = new Image();
let imagesLoaded = 0;
function onImageLoad() {
  imagesLoaded++;
  if (imagesLoaded >= 2) { loadingEl.style.display = 'none'; canvas.style.display = 'block'; uiEl.style.display = 'flex'; init(); requestAnimationFrame(loop); }
}
vanLeft.onload = onImageLoad; vanRight.onload = onImageLoad;
vanLeft.src = '../jurnbreaker/jurnleft.png'; vanRight.src = '../jurnbreaker/jurnright.png';

// Title screen images
const titleBgImg = new Image();
titleBgImg.src = 'titlescreen_bg.jpg';
const titleLogoImg = new Image();
titleLogoImg.src = 'afterverse_logo.png';

const NOTES = ['‚ô©','‚ô™','‚ô´','‚ô¨','üéµ','üé∂'];
const NOTE_COLORS = ['#39ff14','#00ff88','#7fff00','#adff2f','#00ffcc','#39ff14'];

// === HIGH SCORE SYSTEM ===
const HS_KEY = 'afterverse_invaders_highscores';
function getHighScores() {
  try { return JSON.parse(localStorage.getItem(HS_KEY)) || []; } catch(e) { return []; }
}
function saveHighScore(name, sc) {
  let scores = getHighScores();
  scores.push({ name: name.toUpperCase().slice(0,3), score: sc, date: new Date().toISOString().slice(0,10) });
  scores.sort((a,b) => b.score - a.score);
  scores = scores.slice(0, 10);
  localStorage.setItem(HS_KEY, JSON.stringify(scores));
  return scores;
}
function isHighScore(sc) {
  const scores = getHighScores();
  return scores.length < 10 || sc > (scores[scores.length-1]?.score || 0);
}

// === GAME STATE ===
let player, bullets, enemies, enemyBullets, particles, score, lives, level;
let enemyDir, enemySpeed, enemyShootTimer;
let gameState; // title, countdown, playing, dead, gameover, highscore_entry, highscore_display
let countdownTimer = 0;
let countdownNum = 3;
let keys = {};
let deadTimer = 0;
let playerFacing = 'right';

// Blue ghost system
let blueGhost = null;
let blueGhostKills = 0;
let blueGhostSpawnTimer = 0;
let parachuteHuman = null;
let parachuteSpawnTimer = 0;
const PARACHUTE_INTERVAL = 10000; // twice as rare as blue ghost (10s vs 5s)
let playerShield = 0; // 0-3 shield levels
let splatters = []; // red splatters from missed humans
const BLUE_GHOST_INTERVAL = 5000; // ms between spawn attempts

// Skull boss system
let skullBoss = null;
const SKULL_BOSS_HP = 20;
const SKULL_BOSS_W = 120;
const SKULL_BOSS_H = 100;
let skullBossShootTimer = 0;

// High score entry
let hsInitials = '';
let hsCursorBlink = 0;

const PLAYER_W = 60, PLAYER_H = 40;
const ENEMY_W = 30, ENEMY_H = 24;

function init() {
  player = { x: W/2 - PLAYER_W/2, y: H - 70, w: PLAYER_W, h: PLAYER_H };
  bullets = []; enemyBullets = []; particles = [];
  score = 0; lives = 3; level = 1;
  blueGhost = null; blueGhostKills = 0; blueGhostSpawnTimer = 0;
  skullBoss = null; skullBossShootTimer = 0;
  parachuteHuman = null; parachuteSpawnTimer = 0; playerShield = 0; splatters = [];
  scoreEl.textContent = '0'; livesEl.textContent = '3'; ghostKillsEl.textContent = '0';
  shieldCountEl.textContent = '0';
  gameState = 'title'; playerFacing = 'right';
  hsInitials = ''; hsCursorBlink = 0;
  spawnEnemies();
}

function startGame() {
  // Reset everything and start countdown
  init(); // sets gameState to 'title'
  gameState = 'countdown';
  countdownNum = 3;
  countdownTimer = 1000;
}

function spawnEnemies() {
  enemies = [];
  const types = ['üíÄ','üëª','ü¶á','‚ò†Ô∏è','üï∑Ô∏è'];
  const rows = Math.min(3 + Math.floor(level / 2), 5);
  const cols = Math.min(6 + level, 10);
  const gap = 42;
  const startX = (W - cols * gap) / 2 + 6;
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      enemies.push({ x: startX + c * gap, y: 50 + r * 38, w: ENEMY_W, h: ENEMY_H, type: types[r % types.length], hp: r === 0 ? 2 : 1, flash: 0 });
    }
  }
  // Wave 4+: add an extra bottom row of skulls (tougher, 2 HP)
  if (level >= 4) {
    const extraY = 50 + rows * 38;
    for (let c = 0; c < cols; c++) {
      enemies.push({ x: startX + c * gap, y: extraY, w: ENEMY_W, h: ENEMY_H, type: 'üíÄ', hp: 2, flash: 0 });
    }
  }
  enemyDir = 1; enemySpeed = 0.3 + level * 0.15; enemyShootTimer = 0;
}

// === BLUE GHOST ===
function spawnBlueGhost() {
  if (blueGhost || skullBoss) return; // don't spawn if one exists or boss is active
  const side = Math.random() < 0.5 ? 'left' : 'right';
  blueGhost = {
    x: side === 'left' ? -30 : W + 30,
    y: H * 0.35 + Math.random() * (H * 0.2),
    w: 34, h: 28,
    hp: 3,
    dir: side === 'left' ? 1 : -1,
    speed: 1.2 + level * 0.1,
    shootTimer: 0,
    flash: 0,
    bobPhase: Math.random() * Math.PI * 2
  };
}

// === SKULL BOSS ===
function spawnSkullBoss() {
  playBossSpawnSound();
  playEvilLaugh();
  const side = Math.random() < 0.5 ? 'left' : 'right';
  skullBoss = {
    x: side === 'left' ? -SKULL_BOSS_W - 20 : W + 20,
    y: H * 0.25,
    w: SKULL_BOSS_W, h: SKULL_BOSS_H,
    hp: SKULL_BOSS_HP, maxHp: SKULL_BOSS_HP,
    flash: 0,
    dir: side === 'left' ? 1 : -1,
    speed: 0.6 + Math.random() * 0.3,
    phase: 0,
    bobPhase: Math.random() * Math.PI * 2,
    driftStyle: 'ghost', // moves like blue ghost
    entered: false
  };
  skullBossShootTimer = 0;
}

function addParticles(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    particles.push({ x, y, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4, life: 30 + Math.random()*20, maxLife: 50, color, size: 2 + Math.random()*3 });
  }
}

function shoot() {
  if (gameState !== 'playing') return;
  startBgMusic();
  const noteIdx = Math.floor(Math.random() * NOTES.length);
  bullets.push({ x: player.x + PLAYER_W/2, y: player.y - 5, note: NOTES[noteIdx], color: NOTE_COLORS[noteIdx], w: 16, h: 20, rot: (Math.random()-0.5)*0.3 });
  playShootSound();
}

function enemyShoot() {
  if (enemies.length === 0) return;
  const shooter = enemies[Math.floor(Math.random() * enemies.length)];
  enemyBullets.push({ x: shooter.x + ENEMY_W/2 - 2, y: shooter.y + ENEMY_H, w: 4, h: 10, color: '#ff1744', type: 'normal' });
}

function collides(a, b) { return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
function collidesNote(bullet, enemy) {
  const bx = bullet.x - bullet.w/2; const by = bullet.y - bullet.h/2;
  return bx < enemy.x + enemy.w && bx + bullet.w > enemy.x && by < enemy.y + enemy.h && by + bullet.h > enemy.y;
}
function collidesNoteRect(bullet, rect) {
  const bx = bullet.x - bullet.w/2; const by = bullet.y - bullet.h/2;
  return bx < rect.x + rect.w && bx + bullet.w > rect.x && by < rect.y + rect.h && by + bullet.h > rect.y;
}

function update(dt) {
  if (gameState === 'title' || gameState === 'gameover' || gameState === 'highscore_display') return;
  if (gameState === 'countdown') {
    countdownTimer -= dt;
    if (countdownTimer <= 0) {
      countdownNum--;
      if (countdownNum <= 0) {
        gameState = 'playing';
        startBgMusic();
      } else {
        countdownTimer = 1000;
      }
    }
    return;
  }
  if (gameState === 'dead') {
    deadTimer -= dt;
    if (deadTimer <= 0) {
      if (lives <= 0) {
        gameState = isHighScore(score) ? 'highscore_entry' : 'highscore_display';
        bgMusic.pause(); bgMusic.currentTime = 0; bgMusicStarted = false;
        playGameOver();
      } else { gameState = 'playing'; }
    }
    particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life--; p.vy += 0.08; });
    particles = particles.filter(p => p.life > 0);
    return;
  }
  if (gameState !== 'playing') return;

  const spd = 4;
  if (keys.ArrowLeft || keys.KeyA || keys.mLeft) { player.x -= spd; playerFacing = 'left'; }
  if (keys.ArrowRight || keys.KeyD || keys.mRight) { player.x += spd; playerFacing = 'right'; }
  player.x = Math.max(0, Math.min(W - PLAYER_W, player.x));

  // Player bullets
  bullets.forEach(b => { b.y -= 6; b.x += Math.sin(b.y * 0.05 + b.rot * 10) * 0.5; });
  bullets = bullets.filter(b => b.y > -25);

  // Enemy bullets
  enemyBullets.forEach(b => {
    if (b.type === 'lightning') {
      // Lightning bolts wiggle left/right as they descend ‚Äî no tracking
      if (!b.wigglePhase) b.wigglePhase = Math.random() * Math.PI * 2;
      b.wigglePhase += 0.15;
      b.x += Math.sin(b.wigglePhase) * 2.5;
      b.y += b.vy;
    } else if (b.type === 'blue') {
      b.y += 3.8;
      b.x += Math.sin(b.y * 0.04) * 1.5;
    } else {
      b.y += 3.5;
    }
  });
  enemyBullets = enemyBullets.filter(b => b.y < H + 20 && b.x > -20 && b.x < W + 20);

  // Enemy movement
  let edgeHit = false;
  enemies.forEach(e => { e.x += enemyDir * enemySpeed; if (e.flash > 0) e.flash--; if (e.x <= 5 || e.x + e.w >= W - 5) edgeHit = true; });
  if (edgeHit) { enemyDir *= -1; enemies.forEach(e => e.y += 12); }

  // Enemy shooting
  enemyShootTimer += dt;
  const shootInterval = Math.max(600 - level * 50, 200);
  if (enemyShootTimer > shootInterval) { enemyShootTimer = 0; enemyShoot(); }

  // === BLUE GHOST LOGIC ===
  blueGhostSpawnTimer += dt;
  if (!blueGhost && !skullBoss && blueGhostKills < 3 && blueGhostSpawnTimer > BLUE_GHOST_INTERVAL) {
    if (Math.random() < 0.6) spawnBlueGhost();
    blueGhostSpawnTimer = 0;
  }

  if (blueGhost) {
    const bg = blueGhost;
    bg.x += bg.dir * bg.speed;
    bg.bobPhase += 0.05;
    bg.y += Math.sin(bg.bobPhase) * 0.8;
    if (bg.flash > 0) bg.flash--;

    // Blue ghost shooting ‚Äî cyan projectiles
    bg.shootTimer += dt;
    if (bg.shootTimer > 1200) {
      bg.shootTimer = 0;
      enemyBullets.push({ x: bg.x + bg.w/2 - 2, y: bg.y + bg.h, w: 6, h: 10, color: '#00bfff', type: 'blue' });
    }

    // Check if off screen
    if (bg.x < -60 || bg.x > W + 60) blueGhost = null;
  }

  // === PARACHUTE HUMAN LOGIC ===
  parachuteSpawnTimer += dt;
  if (!parachuteHuman && parachuteSpawnTimer > PARACHUTE_INTERVAL) {
    if (Math.random() < 0.3) { // 30% chance each interval ‚Äî rarer than blue ghost
      parachuteHuman = {
        x: 40 + Math.random() * (W - 80),
        y: -36,
        w: 34, h: 34,
        speed: 0.8 + Math.random() * 0.4,
        swayPhase: Math.random() * Math.PI * 2,
        helpFlash: 0,
        caught: false
      };
    }
    parachuteSpawnTimer = 0;
  }

  if (parachuteHuman && !parachuteHuman.caught) {
    const ph = parachuteHuman;
    ph.y += ph.speed;
    ph.swayPhase += 0.04;
    ph.x += Math.sin(ph.swayPhase) * 0.6; // gentle sway
    ph.helpFlash = (ph.helpFlash || 0) + dt;

    // Check if player catches it (lands on the van)
    if (ph.y + ph.h >= player.y && ph.y <= player.y + PLAYER_H &&
        ph.x + ph.w > player.x && ph.x < player.x + PLAYER_W) {
      // Caught! Add shield (max 3)
      if (playerShield < 3) {
        playerShield++;
        shieldCountEl.textContent = playerShield;
      }
      addParticles(ph.x + ph.w/2, ph.y + ph.h/2, '#00e5ff', 15);
      // Play a happy chime
      const actx = new (window.AudioContext || window.webkitAudioContext)();
      [523, 659, 784].forEach((freq, i) => {
        const o = actx.createOscillator(); const g = actx.createGain();
        o.type = 'sine'; o.frequency.value = freq;
        g.gain.setValueAtTime(0.15, actx.currentTime + i*0.08);
        g.gain.exponentialRampToValueAtTime(0.01, actx.currentTime + i*0.08 + 0.2);
        o.connect(g); g.connect(actx.destination);
        o.start(actx.currentTime + i*0.08); o.stop(actx.currentTime + i*0.08 + 0.25);
      });
      parachuteHuman = null;
    }

    // Missed ‚Äî hit the ground
    else if (ph.y > H - 15) {
      // Splat! Red splatter stays until wave ends
      splatters.push({ x: ph.x + ph.w/2, y: H - 8, life: 99999 });
      addParticles(ph.x + ph.w/2, H - 10, '#ff1744', 12);
      // Sad splat sound
      const actx = new (window.AudioContext || window.webkitAudioContext)();
      const o = actx.createOscillator(); const g = actx.createGain();
      o.type = 'sawtooth'; o.frequency.setValueAtTime(200, actx.currentTime);
      o.frequency.exponentialRampToValueAtTime(50, actx.currentTime + 0.3);
      g.gain.setValueAtTime(0.12, actx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.001, actx.currentTime + 0.35);
      const filt = actx.createBiquadFilter(); filt.type = 'lowpass'; filt.frequency.value = 400;
      o.connect(filt); filt.connect(g); g.connect(actx.destination);
      o.start(); o.stop(actx.currentTime + 0.4);
      parachuteHuman = null;
    }
  }

  // === SKULL BOSS LOGIC ‚Äî ghost-style movement ===
  if (skullBoss) {
    const sb = skullBoss;
    // Horizontal drift (like blue ghost)
    sb.x += sb.dir * sb.speed;
    // Vertical bob (sine wave, like blue ghost but slower/bigger)
    sb.bobPhase += 0.03;
    sb.y += Math.sin(sb.bobPhase) * 1.2;
    // Keep boss within screen bounds ‚Äî soft bounce off edges
    if (sb.x + sb.w/2 > 30 && sb.x + sb.w/2 < W - 30) sb.entered = true;
    if (sb.entered) {
      // Once on screen, bounce between edges instead of leaving
      if (sb.x <= 10) { sb.x = 10; sb.dir = Math.abs(sb.dir); }
      if (sb.x + sb.w >= W - 10) { sb.x = W - 10 - sb.w; sb.dir = -Math.abs(sb.dir); }
      // Clamp Y so boss doesn't drift off screen
      sb.y = Math.max(30, Math.min(H * 0.45, sb.y));
    }

    // Shooting ‚Äî lightning ‚ö° from eyes (only after entered screen)
    if (sb.entered) {
      sb.phase += dt;
      skullBossShootTimer += dt;
      if (skullBossShootTimer > 800) {
        skullBossShootTimer = 0;
        const eyeL = { x: sb.x + sb.w * 0.32, y: sb.y + sb.h * 0.38 };
        const eyeR = { x: sb.x + sb.w * 0.68, y: sb.y + sb.h * 0.38 };
        const spreadL = (Math.random() - 0.5) * 1.2;
        const spreadR = (Math.random() - 0.5) * 1.2;
        const bspd = 2.8;
        enemyBullets.push({ x: eyeL.x, y: eyeL.y, vx: spreadL, vy: bspd, w: 16, h: 16, color: '#ffff00', type: 'lightning', text: '‚ö°' });
        enemyBullets.push({ x: eyeR.x, y: eyeR.y, vx: spreadR, vy: bspd, w: 16, h: 16, color: '#ffff00', type: 'lightning', text: '‚ö°' });
        addParticles(eyeL.x, eyeL.y, '#ffffff', 5);
        addParticles(eyeR.x, eyeR.y, '#ffffff', 5);
      }
    }
    if (sb.flash > 0) sb.flash--;
  }

  // Note-enemy collision
  bullets.forEach(b => {
    // Regular enemies
    enemies.forEach(e => {
      if (collidesNote(b, e)) {
        b.dead = true; e.hp--; e.flash = 8; playSnare();
        if (e.hp <= 0) {
          e.dead = true; score += 10 * level; scoreEl.textContent = score;
          addParticles(e.x + e.w/2, e.y + e.h/2, '#bf00ff', 12);
          for (let i = 0; i < 3; i++) {
            particles.push({ x: e.x+e.w/2, y: e.y+e.h/2, vx:(Math.random()-0.5)*3, vy:-Math.random()*3-1, life:40, maxLife:40, color:NOTE_COLORS[Math.floor(Math.random()*NOTE_COLORS.length)], size:3, isNote:true, note:NOTES[Math.floor(Math.random()*NOTES.length)] });
          }
        } else { addParticles(e.x+e.w/2, e.y+e.h/2, '#ff1744', 5); }
      }
    });

    // Blue ghost
    if (blueGhost && !b.dead && collidesNoteRect(b, blueGhost)) {
      b.dead = true; blueGhost.hp--; blueGhost.flash = 8; playSnare();
      if (blueGhost.hp <= 0) {
        score += 50 * level; scoreEl.textContent = score;
        blueGhostKills++; ghostKillsEl.textContent = blueGhostKills;
        addParticles(blueGhost.x + blueGhost.w/2, blueGhost.y + blueGhost.h/2, '#00bfff', 20);
        blueGhost = null;
        // Check for boss spawn
        if (blueGhostKills >= 3) {
          spawnSkullBoss();
          blueGhostKills = 0; ghostKillsEl.textContent = '0';
        }
      } else {
        addParticles(blueGhost.x + blueGhost.w/2, blueGhost.y + blueGhost.h/2, '#00bfff', 5);
      }
    }

    // Skull boss
    if (skullBoss && !b.dead && collidesNoteRect(b, skullBoss)) {
      b.dead = true; skullBoss.hp--; skullBoss.flash = 6; playSnare();
      addParticles(b.x, b.y, '#ffff00', 4);
      if (skullBoss.hp <= 0) {
        score += 500 * level; scoreEl.textContent = score;
        playBossDeathSound();
        // Massive explosion
        for (let i = 0; i < 40; i++) {
          particles.push({
            x: skullBoss.x + skullBoss.w/2 + (Math.random()-0.5)*40,
            y: skullBoss.y + skullBoss.h/2 + (Math.random()-0.5)*40,
            vx: (Math.random()-0.5)*8, vy: (Math.random()-0.5)*8,
            life: 50 + Math.random()*30, maxLife: 80,
            color: ['#ffff00','#ff8800','#ff1744','#bf00ff','#00bfff'][Math.floor(Math.random()*5)],
            size: 3 + Math.random()*5
          });
        }
        // Scatter lightning emojis
        for (let i = 0; i < 8; i++) {
          particles.push({
            x: skullBoss.x + skullBoss.w/2, y: skullBoss.y + skullBoss.h/2,
            vx: (Math.random()-0.5)*6, vy: (Math.random()-0.5)*6 - 2,
            life: 60, maxLife: 60, color: '#ffff00', size: 4, isNote: true, note: '‚ö°'
          });
        }
        skullBoss = null;
      }
    }
  });
  bullets = bullets.filter(b => !b.dead);
  enemies = enemies.filter(e => !e.dead);

  // Enemy bullets hit player
  enemyBullets.forEach(b => {
    const bRect = b.type === 'lightning' ? { x: b.x - 6, y: b.y - 6, w: 12, h: 12 } : { x: b.x, y: b.y, w: b.w, h: b.h };
    if (collides(bRect, player)) {
      b.dead = true;
      if (playerShield > 0) {
        // Shield absorbs the hit
        playerShield--;
        shieldCountEl.textContent = playerShield;
        addParticles(player.x + PLAYER_W/2, player.y + PLAYER_H/2, '#00e5ff', 15);
        // Shield break sound
        const actx = new (window.AudioContext || window.webkitAudioContext)();
        const o = actx.createOscillator(); const g = actx.createGain();
        o.type = 'triangle'; o.frequency.setValueAtTime(800, actx.currentTime);
        o.frequency.exponentialRampToValueAtTime(200, actx.currentTime + 0.15);
        g.gain.setValueAtTime(0.2, actx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, actx.currentTime + 0.2);
        o.connect(g); g.connect(actx.destination);
        o.start(); o.stop(actx.currentTime + 0.25);
      } else {
        lives--; livesEl.textContent = lives;
        addParticles(player.x + PLAYER_W/2, player.y + PLAYER_H/2, '#ff1744', 20);
        gameState = 'dead'; deadTimer = 1500;
      }
    }
  });
  enemyBullets = enemyBullets.filter(b => !b.dead);

  // Enemies reach bottom
  if (enemies.some(e => e.y + e.h >= player.y)) {
    lives = 0; livesEl.textContent = '0';
    gameState = isHighScore(score) ? 'highscore_entry' : 'highscore_display';
    bgMusic.pause(); bgMusic.currentTime = 0; bgMusicStarted = false;
    playGameOver();
  }

  // Wave cleared
  if (enemies.length === 0 && !skullBoss) { level++; splatters = []; spawnEnemies(); }

  // Particles
  particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life--; p.vy += 0.08; });
  particles = particles.filter(p => p.life > 0);
}

function draw() {
  ctx.fillStyle = 'rgba(5,5,8,0.85)'; ctx.fillRect(0, 0, W, H);

  // === TITLE SCREEN ===
  if (gameState === 'title') {
    ctx.fillStyle = '#050508'; ctx.fillRect(0, 0, W, H);
    ctx.save();
    // Background image (cover-fit)
    if (titleBgImg.complete && titleBgImg.naturalWidth > 0) {
      const imgAspect = titleBgImg.naturalWidth / titleBgImg.naturalHeight;
      const canvasAspect = W / H;
      let dw, dh, dx, dy;
      if (canvasAspect > imgAspect) { dw = W; dh = W / imgAspect; dx = 0; dy = (H - dh) / 2; }
      else { dh = H; dw = H * imgAspect; dy = 0; dx = (W - dw) / 2; }
      ctx.globalAlpha = 0.6;
      ctx.drawImage(titleBgImg, dx, dy, dw, dh);
      ctx.globalAlpha = 1;
    }
    // Dark overlay for readability
    ctx.fillStyle = 'rgba(5,5,8,0.45)'; ctx.fillRect(0, 0, W, H);
    // Logo image (centered, sized to ~70% of canvas width)
    if (titleLogoImg.complete && titleLogoImg.naturalWidth > 0) {
      const logoW = W * 0.7;
      const logoH = logoW * (titleLogoImg.naturalHeight / titleLogoImg.naturalWidth);
      const logoX = (W - logoW) / 2;
      const logoY = H * 0.08;
      ctx.drawImage(titleLogoImg, logoX, logoY, logoW, logoH);
    }
    ctx.textAlign = 'center';
    // Pulsing "Press E to Start"
    const titlePulse = 0.5 + 0.5 * Math.sin(Date.now() * 0.004);
    ctx.globalAlpha = 0.5 + titlePulse * 0.5;
    ctx.fillStyle = '#39ff14'; ctx.font = '24px Creepster';
    ctx.shadowColor = '#39ff14'; ctx.shadowBlur = 15;
    ctx.fillText('Press E to Start', W/2, H/2 + 60);
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
    // Subtitle
    ctx.fillStyle = '#aaa'; ctx.font = '14px Creepster';
    ctx.fillText('‚ò† A JURN Production ‚ò†', W/2, H/2 + 100);
    // High scores preview
    const scores = getHighScores();
    if (scores.length > 0) {
      ctx.fillStyle = '#bf00ff'; ctx.font = '18px Creepster';
      ctx.shadowColor = '#bf00ff'; ctx.shadowBlur = 8;
      ctx.fillText('‚ò† HIGH SCORES ‚ò†', W/2, H/2 + 145);
      ctx.shadowBlur = 0;
      ctx.font = '14px Creepster';
      const top3 = scores.slice(0, 3);
      top3.forEach((s, i) => {
        ctx.fillStyle = i === 0 ? '#ffff00' : '#e8e0d4';
        ctx.fillText((i+1) + '. ' + s.name + ' ‚Äî ' + s.score.toLocaleString(), W/2, H/2 + 172 + i * 22);
      });
    }
    ctx.restore();
    return;
  }

  // === COUNTDOWN ===
  if (gameState === 'countdown') {
    drawOverlay();
    ctx.save();
    ctx.textAlign = 'center';
    const num = countdownNum;
    const scale = 1 + 0.3 * (countdownTimer / 1000); // shrinks as timer ticks
    const countAlpha = Math.min(1, countdownTimer / 200);
    ctx.globalAlpha = countAlpha;
    ctx.fillStyle = num === 1 ? '#39ff14' : num === 2 ? '#ffff00' : '#ff1744';
    ctx.font = (80 * scale) + 'px Creepster';
    ctx.shadowColor = ctx.fillStyle; ctx.shadowBlur = 40;
    ctx.fillText(num, W/2, H/2 + 20);
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#888'; ctx.font = '18px Creepster'; ctx.shadowBlur = 0;
    ctx.fillText('GET READY', W/2, H/2 + 80);
    ctx.restore();
    return;
  }

  // Starfield
  ctx.fillStyle = 'rgba(191,0,255,0.15)';
  for (let i = 0; i < 40; i++) { const sx = (i*137+50)%W; const sy = (i*251+80)%H; ctx.fillRect(sx, sy, 1.5, 1.5); }

  // Enemies ‚Äî bright and vivid, lightning flash on hit
  enemies.forEach(e => {
    ctx.save();
    ctx.globalAlpha = 1;
    ctx.font = (e.h + 4) + 'px serif'; ctx.textAlign = 'center';
    if (e.flash > 0) {
      ctx.shadowColor = '#ffffff'; ctx.shadowBlur = 35 + Math.random() * 10;
      ctx.fillText(e.type, e.x + e.w/2, e.y + e.h - 2);
      ctx.shadowColor = '#bf00ff'; ctx.shadowBlur = 18;
      ctx.fillText(e.type, e.x + e.w/2, e.y + e.h - 2);
    } else {
      ctx.shadowColor = '#bf00ff'; ctx.shadowBlur = 6;
      ctx.fillText(e.type, e.x + e.w/2, e.y + e.h - 2);
    }
    ctx.restore();
  });

  // === BLUE GHOST ===
  if (blueGhost) {
    const bg = blueGhost;
    ctx.save();
    ctx.font = (bg.h + 4) + 'px serif'; ctx.textAlign = 'center';
    if (bg.flash > 0) {
      ctx.shadowColor = '#ffffff'; ctx.shadowBlur = 25;
    } else {
      ctx.shadowColor = 'rgba(0, 191, 255, 0.9)'; ctx.shadowBlur = 18;
    }
    ctx.fillText('üëª', bg.x + bg.w/2, bg.y + bg.h);
    // Extra cyan tint overlay
    ctx.shadowColor = '#00bfff'; ctx.shadowBlur = 10;
    ctx.fillText('üëª', bg.x + bg.w/2, bg.y + bg.h);
    ctx.restore();

    // "BLUE" label
    ctx.save();
    ctx.font = '10px Creepster'; ctx.textAlign = 'center';
    ctx.fillStyle = '#00bfff'; ctx.shadowColor = '#00bfff'; ctx.shadowBlur = 5;
    ctx.fillText('RARE', bg.x + bg.w/2, bg.y - 4);
    ctx.restore();
  }

  // === SKULL BOSS ===
  if (skullBoss) {
    const sb = skullBoss;
    ctx.save();

    // Boss body ‚Äî giant skull
    ctx.font = sb.h + 'px serif'; ctx.textAlign = 'center';
    if (sb.flash > 0) {
      ctx.shadowColor = '#ffff00'; ctx.shadowBlur = 40;
    } else {
      ctx.shadowColor = 'rgba(255, 50, 50, 0.8)'; ctx.shadowBlur = 25;
    }
    ctx.fillText('‚ò†Ô∏è', sb.x + sb.w/2, sb.y + sb.h - 5);

    // Eye glow effect
    const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
    ctx.shadowColor = `rgba(255, 255, 0, ${pulse})`; ctx.shadowBlur = 15;
    ctx.font = '14px serif';
    ctx.fillText('‚ö°', sb.x + sb.w * 0.3, sb.y + sb.h * 0.5);
    ctx.fillText('‚ö°', sb.x + sb.w * 0.7, sb.y + sb.h * 0.5);

    // HP bar
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.fillRect(sb.x, sb.y - 12, sb.w, 6);
    const hpPct = sb.hp / sb.maxHp;
    const hpColor = hpPct > 0.5 ? '#39ff14' : hpPct > 0.25 ? '#ffff00' : '#ff1744';
    ctx.fillStyle = hpColor;
    ctx.fillRect(sb.x, sb.y - 12, sb.w * hpPct, 6);
    ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 1;
    ctx.strokeRect(sb.x, sb.y - 12, sb.w, 6);

    // "BOSS" label
    ctx.font = '14px Creepster'; ctx.textAlign = 'center';
    ctx.fillStyle = '#ff1744'; ctx.shadowColor = '#ff1744'; ctx.shadowBlur = 10;
    ctx.fillText('‚ò† BOSS ‚ò†', sb.x + sb.w/2, sb.y - 18);

    ctx.restore();
  }

  // Ground splatters (missed parachute humans)
  splatters.forEach(s => {
    ctx.save();
    ctx.font = '20px serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.shadowColor = '#ff1744'; ctx.shadowBlur = 8;
    ctx.fillText('üí•', s.x, s.y);
    ctx.restore();
  });

  // Parachute human ‚Äî extra bright, double-drawn to beat canvas trail dimming
  if (parachuteHuman && !parachuteHuman.caught) {
    const ph = parachuteHuman;
    ctx.save();
    ctx.globalAlpha = 1;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    // Clear the area behind parachute to prevent trail dimming
    ctx.fillStyle = 'rgba(5,5,8,1)';
    ctx.fillRect(ph.x - 8, ph.y - 22, ph.w + 16, ph.h + 28);
    // Draw emoji large and bright ‚Äî double draw for vivid appearance
    ctx.font = '38px serif';
    ctx.shadowColor = '#ffffff'; ctx.shadowBlur = 4;
    ctx.fillText('ü™Ç', ph.x + ph.w/2, ph.y + ph.h/2);
    ctx.shadowBlur = 0;
    ctx.fillText('ü™Ç', ph.x + ph.w/2, ph.y + ph.h/2);
    // Flashing red HELP! / ‚ÅâÔ∏è alternating every 400ms
    const flashCycle = Math.floor((ph.helpFlash || 0) / 400) % 2;
    const helpVis = Math.floor((ph.helpFlash || 0) / 250) % 2;
    if (helpVis === 0) {
      ctx.font = 'bold 13px monospace';
      ctx.fillStyle = '#ff1744';
      ctx.shadowColor = '#ff1744'; ctx.shadowBlur = 10;
      const helpText = flashCycle === 0 ? 'HELP!' : '‚ÅâÔ∏è';
      ctx.fillText(helpText, ph.x + ph.w/2, ph.y - 12);
    }
    ctx.restore();
  }

  // Player
  if (gameState !== 'dead') {
    const vanImg = playerFacing === 'left' ? vanLeft : vanRight;
    ctx.save(); ctx.shadowColor = '#39ff14'; ctx.shadowBlur = 15;
    ctx.drawImage(vanImg, player.x, player.y, PLAYER_W, PLAYER_H);
    // Shield bars ‚Äî draw layered arcs above the van
    if (playerShield > 0) {
      ctx.shadowBlur = 0;
      const cx = player.x + PLAYER_W/2;
      const cy = player.y - 2;
      const shieldColors = ['#00e5ff', '#00bcd4', '#0097a7'];
      for (let i = 0; i < playerShield; i++) {
        ctx.strokeStyle = shieldColors[i];
        ctx.lineWidth = 3;
        ctx.shadowColor = shieldColors[i]; ctx.shadowBlur = 8 + i * 4;
        ctx.beginPath();
        ctx.arc(cx, cy + i * 2, PLAYER_W/2 + 4 + i * 5, Math.PI, 0);
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  // Player bullets
  bullets.forEach(b => {
    ctx.save(); ctx.translate(b.x, b.y); ctx.rotate(b.rot);
    ctx.font = '18px serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.shadowColor = b.color; ctx.shadowBlur = 12; ctx.fillStyle = b.color;
    ctx.fillText(b.note, 0, 0); ctx.restore();
  });

  // Enemy bullets
  enemyBullets.forEach(b => {
    ctx.save();
    if (b.type === 'lightning') {
      ctx.font = '18px serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      // Triple-layer glow for maximum brightness
      ctx.shadowColor = '#ffffff'; ctx.shadowBlur = 30;
      ctx.fillText('‚ö°', b.x, b.y);
      ctx.shadowColor = '#ffff00'; ctx.shadowBlur = 20;
      ctx.fillText('‚ö°', b.x, b.y);
      ctx.shadowColor = '#ffee00'; ctx.shadowBlur = 8;
      ctx.fillText('‚ö°', b.x, b.y);
    } else if (b.type === 'blue') {
      ctx.fillStyle = '#00bfff'; ctx.shadowColor = '#00bfff'; ctx.shadowBlur = 10;
      ctx.beginPath(); ctx.arc(b.x + 3, b.y + 5, 4, 0, Math.PI*2); ctx.fill();
    } else {
      ctx.fillStyle = '#ff1744'; ctx.shadowColor = '#ff1744'; ctx.shadowBlur = 6;
      ctx.beginPath(); ctx.arc(b.x + 2, b.y + 5, 3, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
  });

  // Particles
  particles.forEach(p => {
    ctx.globalAlpha = p.life / p.maxLife;
    if (p.isNote) {
      ctx.font = '14px serif'; ctx.fillStyle = p.color;
      ctx.shadowColor = p.color; ctx.shadowBlur = 6; ctx.textAlign = 'center';
      ctx.fillText(p.note, p.x, p.y); ctx.shadowBlur = 0;
    } else { ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.size, p.size); }
  });
  ctx.globalAlpha = 1;

  // Wave indicator
  ctx.fillStyle = 'rgba(191,0,255,0.3)'; ctx.font = '14px Creepster'; ctx.textAlign = 'center';
  ctx.fillText('WAVE ' + level, W/2, 30);

  // Dead overlay
  if (gameState === 'dead') {
    ctx.fillStyle = 'rgba(255,23,68,0.15)'; ctx.fillRect(0, 0, W, H);
  }

  // === HIGH SCORE ENTRY ===
  if (gameState === 'highscore_entry') {
    drawOverlay();
    ctx.fillStyle = '#39ff14'; ctx.font = '36px Creepster'; ctx.textAlign = 'center';
    ctx.shadowColor = '#39ff14'; ctx.shadowBlur = 15;
    ctx.fillText('NEW HIGH SCORE!', W/2, H/2 - 80);
    ctx.shadowBlur = 0;

    ctx.fillStyle = '#e8e0d4'; ctx.font = '22px Creepster';
    ctx.fillText('Score: ' + score, W/2, H/2 - 45);

    ctx.fillStyle = '#bf00ff'; ctx.font = '18px Creepster';
    ctx.fillText('Enter your initials:', W/2, H/2 - 10);

    // Initials display
    hsCursorBlink += 0.05;
    const displayStr = hsInitials.padEnd(3, '_');
    ctx.font = '48px Creepster'; ctx.fillStyle = '#39ff14';
    ctx.shadowColor = '#39ff14'; ctx.shadowBlur = 10;
    const charW = 35;
    const startX = W/2 - charW * 1.5 + charW/2;
    for (let i = 0; i < 3; i++) {
      const ch = displayStr[i];
      const isActive = i === hsInitials.length && ch === '_';
      if (isActive && Math.sin(hsCursorBlink * 3) > 0) {
        ctx.fillStyle = '#bf00ff';
      } else {
        ctx.fillStyle = ch === '_' ? 'rgba(57,255,20,0.3)' : '#39ff14';
      }
      ctx.fillText(ch, startX + i * charW, H/2 + 45);
    }
    ctx.shadowBlur = 0;

    ctx.fillStyle = '#888'; ctx.font = '13px Creepster';
    ctx.fillText('Type A-Z then press ENTER', W/2, H/2 + 80);
  }

  // === HIGH SCORE DISPLAY / GAME OVER ===
  if (gameState === 'gameover' || gameState === 'highscore_display') {
    drawOverlay();
    ctx.fillStyle = '#ff1744'; ctx.font = '46px Creepster'; ctx.textAlign = 'center';
    ctx.shadowColor = '#ff1744'; ctx.shadowBlur = 25;
    ctx.fillText('GAME OVER', W/2, H/2 - 120);
    ctx.shadowBlur = 0;

    ctx.fillStyle = '#e8e0d4'; ctx.font = '20px Creepster';
    ctx.fillText('Score: ' + score, W/2, H/2 - 85);

    // Draw leaderboard
    const scores = getHighScores();
    if (scores.length > 0) {
      ctx.fillStyle = '#bf00ff'; ctx.font = '20px Creepster';
      ctx.fillText('‚ò† HIGH SCORES ‚ò†', W/2, H/2 - 50);

      ctx.font = '15px Creepster';
      scores.slice(0, 10).forEach((s, i) => {
        const yPos = H/2 - 25 + i * 22;
        const isNew = s.score === score && gameState === 'highscore_display';
        ctx.fillStyle = isNew ? '#39ff14' : (i < 3 ? '#ffff00' : '#e8e0d4');
        ctx.textAlign = 'left';
        ctx.fillText(`${(i+1+'').padStart(2,' ')}. ${s.name}`, W/2 - 80, yPos);
        ctx.textAlign = 'right';
        ctx.fillText(s.score.toLocaleString(), W/2 + 80, yPos);
      });
    }

    ctx.textAlign = 'center';
    ctx.fillStyle = '#888'; ctx.font = '14px Creepster';
    ctx.fillText('Press SPACE to return to Title', W/2, H/2 + 210);
  }
}

function drawOverlay() {
  ctx.fillStyle = 'rgba(5,5,8,0.92)'; ctx.fillRect(0, 0, W, H);
}

let lastTime = 0;
function loop(ts) { const dt = ts - lastTime; lastTime = ts; update(dt); draw(); requestAnimationFrame(loop); }

// === INPUT ===
document.addEventListener('keydown', e => {
  keys[e.code] = true;
  startBgMusic();

  if (gameState === 'highscore_entry') {
    e.preventDefault();
    if (e.key.length === 1 && /[a-zA-Z]/.test(e.key) && hsInitials.length < 3) {
      hsInitials += e.key.toUpperCase();
    }
    if (e.code === 'Backspace' && hsInitials.length > 0) {
      hsInitials = hsInitials.slice(0, -1);
    }
    if (e.code === 'Enter' && hsInitials.length > 0) {
      // Pad to 3 chars
      while (hsInitials.length < 3) hsInitials += '_';
      saveHighScore(hsInitials, score);
      gameState = 'highscore_display';
    }
    return;
  }

  if (e.code === 'KeyE' && gameState === 'title') {
    e.preventDefault();
    startGame();
    return;
  }
  if (e.code === 'Space') {
    e.preventDefault();
    if (gameState === 'title') { startGame(); return; }
    if (gameState === 'gameover' || gameState === 'highscore_display') { init(); return; }
    shoot();
  }
  if (e.code === 'Enter') {
    if (gameState === 'title') { startGame(); return; }
    if (gameState === 'gameover' || gameState === 'highscore_display') { init(); return; }
  }
});
document.addEventListener('keyup', e => { keys[e.code] = false; });

// Mobile
document.getElementById('m-left').addEventListener('touchstart', e => { e.preventDefault(); keys.mLeft = true; });
document.getElementById('m-left').addEventListener('touchend', () => { keys.mLeft = false; });
document.getElementById('m-right').addEventListener('touchstart', e => { e.preventDefault(); keys.mRight = true; });
document.getElementById('m-right').addEventListener('touchend', () => { keys.mRight = false; });
document.getElementById('m-fire').addEventListener('touchstart', e => {
  e.preventDefault();
  startBgMusic();
  if (gameState === 'title') { startGame(); return; }
  if (gameState === 'gameover' || gameState === 'highscore_display') { init(); return; }
  if (gameState === 'highscore_entry') { /* handled by virtual keyboard */ return; }
  if (gameState === 'countdown') return;
  shoot();
});
canvas.addEventListener('click', () => { if (gameState === 'title') startGame(); else if (gameState === 'gameover' || gameState === 'highscore_display') init(); });
window.addEventListener('resize', () => { resize(); });
</script>
</body>
</html>