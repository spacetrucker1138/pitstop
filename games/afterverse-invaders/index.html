<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Afterverse Invaders ‚Äî Afterverse Arcade</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Creepster&display=swap');
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #050508; display: flex; flex-direction: column; align-items: center; justify-content: center;
  min-height: 100vh; font-family: 'Creepster', cursive; overflow: hidden;
}
canvas { border: 2px solid rgba(57,255,20,0.2); border-radius: 8px; box-shadow: 0 0 30px rgba(57,255,20,0.1), 0 0 60px rgba(0,0,0,0.5); }
#ui {
  position: absolute; top: 0; left: 0; right: 0; display: flex; justify-content: space-between; padding: 15px 20px;
  pointer-events: none; z-index: 10;
}
.score-label { color: #39ff14; font-size: 1.4rem; text-shadow: 0 0 10px rgba(57,255,20,0.5); letter-spacing: 2px; }
.lives-label { color: #ff1744; font-size: 1.2rem; text-shadow: 0 0 10px rgba(255,23,68,0.5); }
#back-link {
  position: fixed; bottom: 15px; left: 50%; transform: translateX(-50%);
  color: #888; text-decoration: none; font-family: 'Inter', sans-serif; font-size: 0.85rem; transition: color 0.3s;
}
#back-link:hover { color: #39ff14; }
#mobile-controls {
  display: none; position: fixed; bottom: 50px; left: 0; right: 0; z-index: 100;
  padding: 0 20px;
}
.m-row { display: flex; justify-content: space-between; align-items: center; }
.m-btn {
  background: rgba(191,0,255,0.15); border: 1px solid rgba(191,0,255,0.3); border-radius: 12px;
  color: #bf00ff; font-size: 1.8rem; width: 65px; height: 65px;
  display: flex; align-items: center; justify-content: center;
  cursor: pointer; user-select: none; -webkit-user-select: none; touch-action: manipulation;
}
.m-btn:active { background: rgba(191,0,255,0.35); }
.m-fire {
  background: rgba(255,23,68,0.2); border-color: rgba(255,23,68,0.4); color: #ff1744;
  width: 80px; height: 80px; border-radius: 50%; font-size: 2rem;
}
.m-fire:active { background: rgba(255,23,68,0.5); }
@media (pointer: coarse) { #mobile-controls { display: block; } }
#loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
  color: #bf00ff; font-size: 1.5rem; text-shadow: 0 0 15px rgba(191,0,255,0.5); }
</style>
</head>
<body>
<div id="loading">Loading the tour van...</div>
<div id="ui" style="display:none;">
  <div class="score-label">SCORE: <span id="score">0</span></div>
  <div class="lives-label">LIVES: <span id="lives">3</span></div>
</div>
<canvas id="game" style="display:none;"></canvas>
<div id="mobile-controls">
  <div class="m-row">
    <div class="m-btn" id="m-left">‚óÄ</div>
    <div class="m-btn m-fire" id="m-fire">üéµ</div>
    <div class="m-btn" id="m-right">‚ñ∂</div>
  </div>
</div>
<a id="back-link" href="../../games.html">‚Üê Back to Afterverse Arcade</a>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const loadingEl = document.getElementById('loading');
const uiEl = document.getElementById('ui');

let W, H;
function resize() {
  W = Math.min(window.innerWidth - 20, 560);
  H = Math.min(window.innerHeight - 100, 640);
  canvas.width = W; canvas.height = H;
}
resize();

// === AUDIO ===
// Reuse JURNBREAKER sound assets
const snares = [
  '../jurnbreaker/snare.mp3',
  '../jurnbreaker/snare1.mp3',
  '../jurnbreaker/snare2.mp3',
  '../jurnbreaker/snare3.mp3'
];
const snarePool = [];
snares.forEach(src => {
  // Create 3 copies of each snare for overlapping playback
  for (let i = 0; i < 3; i++) {
    const a = new Audio(src);
    a.volume = 0.35;
    a.preload = 'auto';
    snarePool.push(a);
  }
});
let snareIdx = 0;

function playSnare() {
  // Cycle through pool to allow overlapping hits
  const a = snarePool[snareIdx % snarePool.length];
  a.currentTime = 0;
  a.play().catch(() => {});
  snareIdx++;
}

const gameOverSound = new Audio('../jurnbreaker/gameover.mp3');
gameOverSound.volume = 0.5;
gameOverSound.preload = 'auto';

function playGameOver() {
  gameOverSound.currentTime = 0;
  gameOverSound.play().catch(() => {});
}

// Simple shoot sound via Web Audio API (quick blip)
let audioCtx;
function playShootSound() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.type = 'square';
  osc.frequency.setValueAtTime(880, audioCtx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(220, audioCtx.currentTime + 0.08);
  gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
  osc.start(audioCtx.currentTime);
  osc.stop(audioCtx.currentTime + 0.1);
}

// === SPRITES ===
const vanLeft = new Image();
const vanRight = new Image();
let imagesLoaded = 0;
function onImageLoad() {
  imagesLoaded++;
  if (imagesLoaded >= 2) {
    loadingEl.style.display = 'none';
    canvas.style.display = 'block';
    uiEl.style.display = 'flex';
    init();
    requestAnimationFrame(loop);
  }
}
vanLeft.onload = onImageLoad;
vanRight.onload = onImageLoad;
vanLeft.src = '../jurnbreaker/jurnleft.png';
vanRight.src = '../jurnbreaker/jurnright.png';

// Music note types for projectiles
const NOTES = ['‚ô©', '‚ô™', '‚ô´', '‚ô¨', 'üéµ', 'üé∂'];
const NOTE_COLORS = ['#39ff14', '#00ff88', '#7fff00', '#adff2f', '#00ffcc', '#39ff14'];

// Game state
let player, bullets, enemies, enemyBullets, particles, score, lives, level;
let enemyDir, enemySpeed, enemyShootTimer;
let gameState;
let keys = {};
let deadTimer = 0;
let playerFacing = 'right';

const PLAYER_W = 60, PLAYER_H = 40;
const ENEMY_W = 30, ENEMY_H = 24;

function init() {
  player = { x: W/2 - PLAYER_W/2, y: H - 70, w: PLAYER_W, h: PLAYER_H };
  bullets = []; enemyBullets = []; particles = [];
  score = 0; lives = 3; level = 1;
  scoreEl.textContent = '0'; livesEl.textContent = '3';
  gameState = 'playing';
  playerFacing = 'right';
  spawnEnemies();
}

function spawnEnemies() {
  enemies = [];
  const types = ['üíÄ', 'üëª', 'ü¶á', '‚ò†Ô∏è', 'üßü'];
  const rows = Math.min(3 + Math.floor(level / 2), 5);
  const cols = Math.min(6 + level, 10);
  const gap = 42;
  const startX = (W - cols * gap) / 2 + 6;
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      enemies.push({
        x: startX + c * gap, y: 50 + r * 38,
        w: ENEMY_W, h: ENEMY_H,
        type: types[r % types.length],
        hp: r === 0 ? 2 : 1,
        flash: 0
      });
    }
  }
  enemyDir = 1; enemySpeed = 0.3 + level * 0.15;
  enemyShootTimer = 0;
}

function addParticles(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4,
      life: 30 + Math.random()*20, maxLife: 50, color, size: 2 + Math.random()*3
    });
  }
}

function shoot() {
  if (gameState !== 'playing') return;
  const noteIdx = Math.floor(Math.random() * NOTES.length);
  bullets.push({
    x: player.x + PLAYER_W/2,
    y: player.y - 5,
    note: NOTES[noteIdx],
    color: NOTE_COLORS[noteIdx],
    w: 16, h: 20,
    rot: (Math.random() - 0.5) * 0.3
  });
  playShootSound();
}

function enemyShoot() {
  if (enemies.length === 0) return;
  const shooter = enemies[Math.floor(Math.random() * enemies.length)];
  enemyBullets.push({ x: shooter.x + ENEMY_W/2 - 2, y: shooter.y + ENEMY_H, w: 4, h: 10 });
}

function collides(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

function collidesNote(bullet, enemy) {
  const bx = bullet.x - bullet.w/2;
  const by = bullet.y - bullet.h/2;
  return bx < enemy.x + enemy.w && bx + bullet.w > enemy.x &&
         by < enemy.y + enemy.h && by + bullet.h > enemy.y;
}

function update(dt) {
  if (gameState === 'dead') {
    deadTimer -= dt;
    if (deadTimer <= 0) {
      if (lives <= 0) { gameState = 'gameover'; playGameOver(); }
      else { gameState = 'playing'; }
    }
    return;
  }
  if (gameState !== 'playing') return;

  const spd = 4;
  if (keys.ArrowLeft || keys.KeyA || keys.mLeft) { player.x -= spd; playerFacing = 'left'; }
  if (keys.ArrowRight || keys.KeyD || keys.mRight) { player.x += spd; playerFacing = 'right'; }
  player.x = Math.max(0, Math.min(W - PLAYER_W, player.x));

  // Player bullets
  bullets.forEach(b => {
    b.y -= 6;
    b.x += Math.sin(b.y * 0.05 + b.rot * 10) * 0.5;
  });
  bullets = bullets.filter(b => b.y > -25);

  // Enemy bullets
  enemyBullets.forEach(b => b.y += 3.5);
  enemyBullets = enemyBullets.filter(b => b.y < H + 20);

  // Enemy movement
  let edgeHit = false;
  enemies.forEach(e => {
    e.x += enemyDir * enemySpeed;
    if (e.flash > 0) e.flash--;
    if (e.x <= 5 || e.x + e.w >= W - 5) edgeHit = true;
  });
  if (edgeHit) {
    enemyDir *= -1;
    enemies.forEach(e => e.y += 12);
  }

  // Enemy shooting
  enemyShootTimer += dt;
  const shootInterval = Math.max(600 - level * 50, 200);
  if (enemyShootTimer > shootInterval) {
    enemyShootTimer = 0;
    enemyShoot();
  }

  // Note-enemy collision
  bullets.forEach(b => {
    enemies.forEach(e => {
      if (collidesNote(b, e)) {
        b.dead = true;
        e.hp--;
        e.flash = 8;
        playSnare();
        if (e.hp <= 0) {
          e.dead = true;
          score += 10 * level;
          scoreEl.textContent = score;
          addParticles(e.x + e.w/2, e.y + e.h/2, '#bf00ff', 12);
          for (let i = 0; i < 3; i++) {
            particles.push({
              x: e.x + e.w/2, y: e.y + e.h/2,
              vx: (Math.random()-0.5)*3, vy: -Math.random()*3 - 1,
              life: 40, maxLife: 40,
              color: NOTE_COLORS[Math.floor(Math.random()*NOTE_COLORS.length)],
              size: 3, isNote: true,
              note: NOTES[Math.floor(Math.random()*NOTES.length)]
            });
          }
        } else {
          addParticles(e.x + e.w/2, e.y + e.h/2, '#ff1744', 5);
        }
      }
    });
  });
  bullets = bullets.filter(b => !b.dead);
  enemies = enemies.filter(e => !e.dead);

  // Enemy bullets hit player
  enemyBullets.forEach(b => {
    if (collides(b, player)) {
      b.dead = true;
      lives--; livesEl.textContent = lives;
      addParticles(player.x + PLAYER_W/2, player.y + PLAYER_H/2, '#ff1744', 20);
      gameState = 'dead'; deadTimer = 1500;
      if (lives <= 0) { /* gameover triggered when deadTimer expires */ }
    }
  });
  enemyBullets = enemyBullets.filter(b => !b.dead);

  // Enemies reach bottom
  if (enemies.some(e => e.y + e.h >= player.y)) {
    lives = 0; livesEl.textContent = '0';
    gameState = 'gameover';
    playGameOver();
  }

  // Wave cleared
  if (enemies.length === 0) {
    level++;
    spawnEnemies();
  }

  // Particles
  particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life--; p.vy += 0.08; });
  particles = particles.filter(p => p.life > 0);
}

function draw() {
  ctx.fillStyle = '#050508';
  ctx.fillRect(0, 0, W, H);

  // Starfield
  ctx.fillStyle = 'rgba(191,0,255,0.15)';
  for (let i = 0; i < 40; i++) {
    const sx = (i * 137 + 50) % W;
    const sy = (i * 251 + 80) % H;
    ctx.fillRect(sx, sy, 1.5, 1.5);
  }

  // Enemies ‚Äî purple ambient glow, lightning flash on hit
  enemies.forEach(e => {
    ctx.save();
    ctx.font = e.h + 'px serif';
    ctx.textAlign = 'center';
    if (e.flash > 0) {
      // Lightning flash ‚Äî bright white glow radiating from the emoji itself
      ctx.shadowColor = '#ffffff';
      ctx.shadowBlur = 30 + Math.random() * 10;
      ctx.fillText(e.type, e.x + e.w/2, e.y + e.h - 2);
      // Second burst layer for intensity
      ctx.shadowColor = '#bf00ff';
      ctx.shadowBlur = 15;
      ctx.fillText(e.type, e.x + e.w/2, e.y + e.h - 2);
    } else {
      // Normal state ‚Äî purple ambient glow, slightly boosted
      ctx.shadowColor = 'rgba(191, 0, 255, 0.7)';
      ctx.shadowBlur = 12;
      ctx.fillText(e.type, e.x + e.w/2, e.y + e.h - 2);
    }
    ctx.restore();
  });

  // Player ‚Äî JURN tour van
  if (gameState !== 'dead') {
    const vanImg = playerFacing === 'left' ? vanLeft : vanRight;
    ctx.save();
    ctx.shadowColor = '#39ff14';
    ctx.shadowBlur = 15;
    ctx.drawImage(vanImg, player.x, player.y, PLAYER_W, PLAYER_H);
    ctx.restore();
  }

  // Player bullets ‚Äî music notes
  bullets.forEach(b => {
    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.rotate(b.rot);
    ctx.font = '18px serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = b.color;
    ctx.shadowBlur = 12;
    ctx.fillStyle = b.color;
    ctx.fillText(b.note, 0, 0);
    ctx.restore();
  });

  // Enemy bullets ‚Äî red plasma
  ctx.fillStyle = '#ff1744';
  ctx.shadowColor = '#ff1744'; ctx.shadowBlur = 6;
  enemyBullets.forEach(b => {
    ctx.beginPath(); ctx.arc(b.x + 2, b.y + 5, 3, 0, Math.PI*2); ctx.fill();
  });
  ctx.shadowBlur = 0;

  // Particles
  particles.forEach(p => {
    ctx.globalAlpha = p.life / p.maxLife;
    if (p.isNote) {
      ctx.font = '14px serif';
      ctx.fillStyle = p.color;
      ctx.shadowColor = p.color; ctx.shadowBlur = 6;
      ctx.textAlign = 'center';
      ctx.fillText(p.note, p.x, p.y);
      ctx.shadowBlur = 0;
    } else {
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, p.size, p.size);
    }
  });
  ctx.globalAlpha = 1;

  // Wave indicator
  ctx.fillStyle = 'rgba(191,0,255,0.3)';
  ctx.font = '14px Creepster'; ctx.textAlign = 'center';
  ctx.fillText('WAVE ' + level, W/2, 30);

  // Overlays
  if (gameState === 'dead') {
    ctx.fillStyle = 'rgba(255,23,68,0.15)';
    ctx.fillRect(0, 0, W, H);
  }
  if (gameState === 'gameover') {
    ctx.fillStyle = 'rgba(5,5,8,0.88)';
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#ff1744';
    ctx.font = '52px Creepster'; ctx.textAlign = 'center';
    ctx.shadowColor = '#ff1744'; ctx.shadowBlur = 25;
    ctx.fillText('GAME OVER', W/2, H/2 - 30);
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#e8e0d4';
    ctx.font = '24px Creepster';
    ctx.fillText('Final Score: ' + score, W/2, H/2 + 15);
    ctx.fillStyle = '#888';
    ctx.font = '16px Creepster';
    ctx.fillText('Press SPACE or Tap to haunt again', W/2, H/2 + 55);
  }
}

let lastTime = 0;
function loop(ts) {
  const dt = ts - lastTime; lastTime = ts;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

// Keyboard
document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'Space') {
    e.preventDefault();
    if (gameState === 'gameover') init();
    else shoot();
  }
  if (e.code === 'Enter' && gameState === 'gameover') init();
});
document.addEventListener('keyup', e => { keys[e.code] = false; });

// Mobile controls
document.getElementById('m-left').addEventListener('touchstart', e => { e.preventDefault(); keys.mLeft = true; });
document.getElementById('m-left').addEventListener('touchend', () => { keys.mLeft = false; });
document.getElementById('m-right').addEventListener('touchstart', e => { e.preventDefault(); keys.mRight = true; });
document.getElementById('m-right').addEventListener('touchend', () => { keys.mRight = false; });
document.getElementById('m-fire').addEventListener('touchstart', e => {
  e.preventDefault();
  if (gameState === 'gameover') init();
  else shoot();
});
canvas.addEventListener('click', () => { if (gameState === 'gameover') init(); });

window.addEventListener('resize', () => { resize(); if (imagesLoaded >= 2) init(); });
</script>
</body>
</html>