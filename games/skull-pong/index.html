<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Skull Pong Ã¢Â€Â” Afterverse Arcade</title>
<link href="https://fonts.googleapis.com/css2?family=Creepster&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0a0a; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
canvas { display: block; max-width: 100vw; max-height: 100vh; object-fit: contain; touch-action: none; }
</style>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = 500, H = 700;
canvas.width = W; canvas.height = H;

// Audio
class AudioMgr {
  constructor() {
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    this.muted = false;
    this.volume = 0.5;
  }
  resume() { if (this.ctx.state === 'suspended') this.ctx.resume(); }
  play(freq, dur, type='square', vol=0.3) {
    if (this.muted) return;
    const o = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    o.type = type;
    o.frequency.value = freq;
    g.gain.value = vol * this.volume;
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
    o.connect(g); g.connect(this.ctx.destination);
    o.start(); o.stop(this.ctx.currentTime + dur);
  }
  hitSound() { this.play(400, 0.1, 'square', 0.4); }
  wallSound() { this.play(250, 0.08, 'triangle', 0.3); }
  scoreSound() { this.play(150, 0.4, 'sawtooth', 0.5); }
  startSound() { 
    this.play(330, 0.1); 
    setTimeout(() => this.play(440, 0.1), 100);
    setTimeout(() => this.play(550, 0.15), 200);
  }
  gameOverSound() {
    this.play(200, 0.3, 'sawtooth', 0.5);
    setTimeout(() => this.play(150, 0.3, 'sawtooth', 0.5), 200);
    setTimeout(() => this.play(100, 0.5, 'sawtooth', 0.6), 400);
  }
}
const audio = new AudioMgr();

// Background Music
const bgMusic = new Audio('hauntedsong1.mp3');
bgMusic.loop = true;
bgMusic.volume = 0.35;
let musicStarted = false;

function updateMusic() {
  if (audio.muted) {
    bgMusic.volume = 0;
  } else {
    bgMusic.volume = 0.35;
  }
  if (state === 'playing') {
    if (bgMusic.paused) {
      bgMusic.play().catch(() => {});
    }
    musicStarted = true;
  } else if (state === 'gameover') {
    bgMusic.pause();
    bgMusic.currentTime = 0;
    musicStarted = false;
  } else if (state === 'title') {
    bgMusic.pause();
    bgMusic.currentTime = 0;
    musicStarted = false;
  } else if (state === 'paused') {
    bgMusic.pause();
  }
}


// Game state
let state = 'title'; // title, countdown, playing, paused, gameover
let countdownTimer = 0;
let countdownNum = 3;

// Scores
const WIN_SCORE = 5;
let playerScore = 0, aiScore = 0;
let matchStartTime = 0, matchElapsed = 0;

// Ball
let ball = { x: W/2, y: H/2, vx: 4, vy: 4, r: 12, visualR: 18, speed: 5 };

// Ball sprites (3 cycling)
const ballImgs = [];
const ballSrcs = ['pongball.png','pongball2.png','eyeball.jpg','ball_guts.png','ball_bones.png','ball_tentacle.png','ball_hearts.png','ball_brain.png'];
let currentBallIdx = 0;
let ballImgsLoaded = 0;
ballSrcs.forEach((src, i) => {
  const img = new Image();
  img.onload = () => { ballImgsLoaded++; };
  img.src = src;
  ballImgs[i] = img;
});

// Floor image
const floorImg = new Image();
floorImg.src = 'floor.jpg';

// Paddle and equipment sprites
const topPaddleImg = new Image();
topPaddleImg.src = 'paddle_top.png';
const bottomPaddleImg = new Image();
bottomPaddleImg.src = 'paddle_bottom.png';
const chordImg = new Image();
chordImg.src = 'chord.png';
const dfibImg = new Image();
dfibImg.src = 'dfib.png';
const titleScreenImg = new Image();
titleScreenImg.src = 'skull_pong_title_screen.jpg';

// Hit flash effects
const hitFlashes = [];  // {x, y, type: 'lightning'|'red', life, maxLife}
function addHitFlash(x, y, type) {
  hitFlashes.push({ x, y, type, life: 8, maxLife: 8 });
}

function drawHitFlashes() {
  hitFlashes.forEach((f, idx) => {
    const t = f.life / f.maxLife;
    ctx.save();
    ctx.globalAlpha = t;
    if (f.type === 'lightning') {
      // Jagged lightning bolt burst
      ctx.shadowColor = '#ffff00';
      ctx.shadowBlur = 20 * t;
      ctx.strokeStyle = `rgba(255,255,${Math.floor(100 + 155*t)},${t})`;
      ctx.lineWidth = 2;
      const bolts = 5;
      for (let b = 0; b < bolts; b++) {
        const angle = (b / bolts) * Math.PI * 2 + (1 - t) * 0.5;
        const len = (20 + Math.random() * 15) * t;
        ctx.beginPath();
        ctx.moveTo(f.x, f.y);
        // Jagged: two segments
        const mx = f.x + Math.cos(angle) * len * 0.5 + (Math.random()-0.5)*8;
        const my = f.y + Math.sin(angle) * len * 0.5 + (Math.random()-0.5)*8;
        ctx.lineTo(mx, my);
        ctx.lineTo(f.x + Math.cos(angle) * len, f.y + Math.sin(angle) * len);
        ctx.stroke();
      }
      // Center flash
      ctx.fillStyle = `rgba(255,255,200,${t})`;
      ctx.beginPath();
      ctx.arc(f.x, f.y, 6 * t, 0, Math.PI * 2);
      ctx.fill();
    } else if (f.type === 'red') {
      // Red burst for wall hits
      ctx.shadowColor = '#ff2200';
      ctx.shadowBlur = 16 * t;
      const r = 18 * t;
      const grad = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, r);
      grad.addColorStop(0, `rgba(255,80,0,${t})`);
      grad.addColorStop(1, `rgba(180,0,0,0)`);
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(f.x, f.y, r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
    f.life--;
  });
  // Cull dead flashes
  for (let i = hitFlashes.length - 1; i >= 0; i--) {
    if (hitFlashes[i].life <= 0) hitFlashes.splice(i, 1);
  }
}

// Dfib timer (counts up from match start)
function drawDfib() {
  if (!dfibImg.complete || dfibImg.naturalWidth === 0) return;
  const DW = 110, DH = 77;
  const dx = W - DW - 4, dy = H/2 - DH/2;
  ctx.drawImage(dfibImg, dx, dy, DW, DH);
  // Timer overlay on dfib screen
  if (state === 'playing' && matchStartTime > 0) {
    const elapsed = Date.now() - matchStartTime;
    const secs = Math.floor(elapsed / 1000);
    const ms = Math.floor((elapsed % 1000) / 100);
    const timeStr = String(Math.floor(secs / 60)).padStart(2,'0') + ':' + 
                    String(secs % 60).padStart(2,'0') + '.' + ms;
    ctx.save();
    ctx.font = 'bold 9px monospace';
    ctx.fillStyle = '#00ff88';
    ctx.textAlign = 'center';
    ctx.shadowColor = '#00ff88';
    ctx.shadowBlur = 6;
    ctx.fillText(timeStr, dx + DW * 0.35, dy + DH * 0.42);
    ctx.restore();
  }
}

// Cord drawing: stretched chord.png from paddle edge to dfib
function drawCord(paddle, isTop) {
  if (!chordImg.complete || chordImg.naturalWidth === 0) return;
  const DW = 110, DH = 77;
  const dfibX = W - DW - 4;              // left edge of dfib
  const dfibConnY = H/2 - DH/2 + DH * 0.5; // vertical center of dfib
  // Paddle connector: top paddle = right end, bottom paddle = left end
  const padConnX = isTop ? (paddle.x + paddle.w) : paddle.x;
  const padConnY = paddle.y + paddle.h / 2;

  const dx = dfibX - padConnX;
  const dy = dfibConnY - padConnY;
  const cordLen = Math.sqrt(dx*dx + dy*dy);
  const angle = Math.atan2(dy, dx);

  ctx.save();
  ctx.globalAlpha = 0.88;

  // Draw the arc line shadow underneath
  ctx.beginPath();
  ctx.moveTo(padConnX, padConnY);
  const mx = (padConnX + dfibX) / 2;
  const my = (padConnY + dfibConnY) / 2 + cordLen * 0.08; // slight sag
  ctx.quadraticCurveTo(mx, my, dfibX, dfibConnY);
  ctx.strokeStyle = 'rgba(40,40,40,0.6)';
  ctx.lineWidth = 4;
  ctx.stroke();

  // Draw chord.png rotated along the diagonal
  const cordH = 14;
  ctx.translate(padConnX, padConnY);
  ctx.rotate(angle);
  ctx.drawImage(chordImg, 0, -cordH / 2, cordLen, cordH);

  ctx.restore();
}


// Blood splatters (GC-style, permanent, added on score)
const bloodSplatters = [];
function addBloodSplat(x, y) {
  const count = 6 + Math.floor(Math.random() * 4);
  const splat = { x, y, drops: [] };
  for (let i = 0; i < count; i++) {
    splat.drops.push({
      dx: (Math.random() - 0.5) * 80,
      dy: (Math.random() - 0.5) * 80,
      r:  4 + Math.random() * 9,
      alpha: 0.55 + Math.random() * 0.35
    });
  }
  // streak: a few elongated drops
  for (let i = 0; i < 3; i++) {
    const angle = Math.random() * Math.PI * 2;
    const dist = 20 + Math.random() * 40;
    splat.drops.push({
      dx: Math.cos(angle) * dist,
      dy: Math.sin(angle) * dist,
      r:  2 + Math.random() * 4,
      alpha: 0.4 + Math.random() * 0.25,
      streak: true,
      angle
    });
  }
  bloodSplatters.push(splat);
}

function drawBloodSplatters() {
  bloodSplatters.forEach(splat => {
    splat.drops.forEach(d => {
      ctx.save();
      ctx.globalAlpha = d.alpha;
      ctx.fillStyle = d.alpha > 0.7 ? '#8b0000' : '#6b0000';
      ctx.shadowColor = '#4a0000';
      ctx.shadowBlur = 4;
      ctx.beginPath();
      if (d.streak) {
        ctx.save();
        ctx.translate(splat.x + d.dx, splat.y + d.dy);
        ctx.rotate(d.angle);
        ctx.ellipse(0, 0, d.r * 2.5, d.r * 0.7, 0, 0, Math.PI * 2);
        ctx.restore();
      } else {
        ctx.arc(splat.x + d.dx, splat.y + d.dy, d.r, 0, Math.PI * 2);
      }
      ctx.fill();
      ctx.restore();
    });
  });
}

// Trail
const trail = [];
const TRAIL_MAX = 18;
// Skull animation
let skullAngle = 0;

// Paddles (defib)
const PAD_W = 80, PAD_H = 26, PAD_SPEED = 6;
let player = { x: W/2 - PAD_W/2, y: H - 50, w: PAD_W, h: PAD_H };
let ai = { x: W/2 - PAD_W/2, y: 30, w: PAD_W, h: PAD_H };
// Spacebar smash: arms a hit-boost window
let smashArmed = false;       // spacebar pressed, window open
let smashWindowEnd = 0;       // ms timestamp when window closes
let smashAnim = 0;            // 0-8 frame counter for paddle swing visual
const SMASH_WINDOW = 220;     // ms window after spacebar
const SMASH_BOOST = 1.45;     // speed multiplier on smash hit

// Particles
let particles = [];

// Input
let keys = {};
let touchX = null;
document.addEventListener('keydown', e => { keys[e.key] = true; handleKey(e.key); });
document.addEventListener('keyup', e => keys[e.key] = false);
canvas.addEventListener('touchstart', e => { e.preventDefault(); handleTouch(e); });
canvas.addEventListener('touchmove', e => { e.preventDefault(); touchX = e.touches[0].clientX / canvas.offsetWidth * W; });
canvas.addEventListener('touchend', () => touchX = null);
canvas.addEventListener('click', handleClick);

function handleKey(key) {
  if (key === 'm' || key === 'M') { audio.muted = !audio.muted; return; }
  if (state === 'title' && (key === 'e' || key === 'E' || key === ' ')) startGame();
  if (state === 'gameover' && (key === 'e' || key === 'E' || key === ' ')) backToTitle();
  if (state === 'playing' && (key === 'p' || key === 'P' || key === 'Escape')) {
    state = state === 'playing' ? 'paused' : 'playing';
  }
  if (state === 'paused' && (key === 'p' || key === 'P' || key === 'Escape')) state = 'playing';
  // Spacebar smash: arm a boost window during playing state
  if (state === 'playing' && key === ' ') {
    smashArmed = true;
    smashWindowEnd = Date.now() + SMASH_WINDOW;
  }
}
function handleTouch(e) {
  audio.resume();
  touchX = e.touches[0].clientX / canvas.offsetWidth * W;
  if (state === 'title') startGame();
  if (state === 'gameover') backToTitle();
}
function handleClick() {
  audio.resume();
  if (state === 'title') startGame();
  if (state === 'gameover') backToTitle();
}

function startGame() {
  audio.resume();
  audio.startSound();
  playerScore = 0; aiScore = 0; matchStartTime = 0; matchElapsed = 0;
  bloodSplatters.length = 0;
  resetBall();
  state = 'countdown';
  countdownNum = 3;
  countdownTimer = 0;
}
function backToTitle() { state = 'title'; }

function resetBall() {
  currentBallIdx = (currentBallIdx + 1) % ballImgs.length;
  ball.x = W/2; ball.y = H/2;
  const angle = (Math.random() * 0.5 + 0.25) * Math.PI * (Math.random() > 0.5 ? 1 : -1);
  const dir = Math.random() > 0.5 ? 1 : -1;
  ball.vx = Math.sin(angle) * ball.speed;
  ball.vy = Math.cos(angle) * ball.speed * dir;
}

function spawnParticles(x, y, color, count=8) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random()-0.5)*6,
      vy: (Math.random()-0.5)*6,
      life: 1,
      color,
      size: Math.random()*4+2
    });
  }
}

// Draw helpers
function drawTombstone(x, y, w, h, color) {
  const isPlayer = (color === '#22c55e');
  const img = isPlayer ? bottomPaddleImg : topPaddleImg;
  ctx.save();

  // Swing animation: player paddle lunges forward (up) then retracts
  let swingY = 0, scaleX = 1, scaleY = 1;
  if (isPlayer && smashAnim > 0) {
    const t = smashAnim / 8;  // 1.0 â†’ 0
    swingY = -Math.round(t * 10);          // lunge up to 10px
    scaleX = 1 + t * 0.12;                 // slight widen on hit
    scaleY = 1 - t * 0.08;                 // slight squish
  }

  const cx = x + w / 2, cy = y + h / 2;
  ctx.translate(cx, cy + swingY);
  ctx.scale(scaleX, scaleY);
  ctx.translate(-cx, -cy);

  if (img.complete && img.naturalWidth > 0) {
    ctx.shadowColor = color;
    ctx.shadowBlur = isPlayer && smashAnim > 0 ? 28 : 14;
    const pad = 4;
    ctx.drawImage(img, x - pad, y - pad, w + pad*2, h + pad*2);
  } else {
    ctx.fillStyle = '#1a1a2e';
    ctx.shadowColor = color;
    ctx.shadowBlur = 18;
    ctx.fillRect(x, y, w, h);
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.strokeRect(x+1, y+1, w-2, h-2);
  }
  ctx.restore();
}

function drawSkull(x, y, r) {
  // Draw fading red trail
  trail.forEach((p, idx) => {
    const frac = idx / TRAIL_MAX;
    const alpha = frac * 0.55;
    const radius = r * (0.35 + frac * 0.55);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = '#ff1a1a';
    ctx.shadowColor = '#ff0000';
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  });

  // Draw ball sprite (cycling)
  const img = ballImgs[currentBallIdx];
  const size = r * 2;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(skullAngle);
  if (img && img.complete && img.naturalWidth > 0) {
    const offscreen = document.createElement('canvas');
    offscreen.width = offscreen.height = Math.ceil(size * 2);
    const oc = offscreen.getContext('2d');
    oc.drawImage(img, 0, 0, offscreen.width, offscreen.height);
    const id = oc.getImageData(0, 0, offscreen.width, offscreen.height);
    const d = id.data;
    for (let i = 0; i < d.length; i += 4) {
      if (d[i] > 180 && d[i+1] < 80 && d[i+2] > 180) d[i+3] = 0;
    }
    oc.putImageData(id, 0, 0);
    ctx.shadowColor = '#a855f7';
    ctx.shadowBlur = 16;
    ctx.drawImage(offscreen, -size, -size, size*2, size*2);
  } else {
    ctx.font = `${size}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = '#a855f7';
    ctx.shadowBlur = 20;
    ctx.fillText('ðŸ’€', 0, 0);
  }
  ctx.restore();
}

function drawCenterLine() {
  ctx.setLineDash([10, 10]);
  ctx.strokeStyle = 'rgba(168,85,247,0.3)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, H/2); ctx.lineTo(W, H/2);
  ctx.stroke();
  ctx.setLineDash([]);
}

function drawScore() {
  ctx.font = '48px Creepster';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#a855f7';
  ctx.shadowColor = '#a855f7';
  ctx.shadowBlur = 10;
  ctx.fillText(aiScore, W/2 - 60, H/2 - 20);
  ctx.fillText(playerScore, W/2 + 60, H/2 + 45);
  ctx.shadowBlur = 0;
}

function drawMuteIndicator() {
  ctx.font = '14px monospace';
  ctx.textAlign = 'right';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText(audio.muted ? '[M] Muted' : '[M] Sound', W - 10, H - 10);
}

// Title screen
function drawTitle() {
  const t = Date.now() / 1000;
  // Title screen image background
  if (titleScreenImg.complete && titleScreenImg.naturalWidth > 0) {
    ctx.drawImage(titleScreenImg, 0, 0, W, H);
    // Overlay to ensure text legibility
    ctx.fillStyle = 'rgba(5,0,15,0.52)';
    ctx.fillRect(0, 0, W, H);
  } else {
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(0, 0, W, H);
  }

  // Title
  ctx.font = '64px Creepster';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#a855f7';
  ctx.shadowColor = '#a855f7';
  ctx.shadowBlur = 30;
  ctx.fillText('SKULL PONG', W/2, 200);
  ctx.shadowBlur = 0;

  // Subtitle
  ctx.font = '20px Creepster';
  ctx.fillStyle = '#c084fc';
  ctx.fillText('First to ' + WIN_SCORE + ' â€” fastest time wins!', W/2, 250);

  // Instructions
  ctx.font = '18px Creepster';
  ctx.fillStyle = '#e9d5ff';
  ctx.fillText('Arrow Keys / Touch to Move', W/2, 380);
  ctx.fillText('[M] Mute  [P] Pause', W/2, 410);

  // Start prompt
  const pulse = Math.sin(t * 3) * 0.3 + 0.7;
  ctx.globalAlpha = pulse;
  ctx.font = '32px Creepster';
  ctx.fillStyle = '#f87171';
  ctx.fillText('Press E or Tap to Start', W/2, 500);
  ctx.globalAlpha = 1;

  // Credit
  ctx.font = '16px Creepster';
  ctx.fillStyle = 'rgba(168,85,247,0.6)';
  ctx.fillText('- A JURN Production -', W/2, H - 30);

  drawMuteIndicator();
}

// Game Over
function drawGameOver() {
  ctx.fillStyle = 'rgba(10,10,10,0.85)';
  ctx.fillRect(0, 0, W, H);

  const winner = playerScore >= WIN_SCORE ? 'YOU WIN!' : 'YOU LOSE!';
  const color = playerScore >= WIN_SCORE ? '#22c55e' : '#f87171';

  ctx.font = '56px Creepster';
  ctx.textAlign = 'center';
  ctx.fillStyle = color;
  ctx.shadowColor = color;
  ctx.shadowBlur = 25;
  ctx.fillText(winner, W/2, 250);
  ctx.shadowBlur = 0;

  ctx.font = '28px Creepster';
  ctx.fillStyle = '#e9d5ff';
  ctx.fillText(`${playerScore} Ã¢Â€Â” ${aiScore}`, W/2, 320);

  const t = Date.now() / 1000;
  const pulse = Math.sin(t * 3) * 0.3 + 0.7;
  ctx.globalAlpha = pulse;
  ctx.font = '24px Creepster';
  ctx.fillStyle = '#c084fc';
  ctx.fillText('Press E or Tap to Continue', W/2, 420);
  ctx.globalAlpha = 1;

  drawMuteIndicator();
}

// Update
function update() {
  if (state === 'countdown') {
    countdownTimer++;
    if (countdownTimer >= 60) { countdownTimer = 0; countdownNum--; }
    if (countdownNum <= 0) { state = 'playing'; if (matchStartTime === 0) matchStartTime = Date.now(); }
    return;
  }
  if (state !== 'playing') return;

  // Player input
  if (keys['ArrowLeft'] || keys['a'] || keys['A']) player.x -= PAD_SPEED;
  if (keys['ArrowRight'] || keys['d'] || keys['D']) player.x += PAD_SPEED;
  if (touchX !== null) {
    const target = touchX - player.w/2;
    player.x += (target - player.x) * 0.15;
  }
  player.x = Math.max(0, Math.min(W - player.w, player.x));
  // Smash animation tick + window expiry
  if (smashAnim > 0) smashAnim--;
  if (smashArmed && Date.now() > smashWindowEnd) smashArmed = false;

  // AI movement
  const aiTarget = ball.x - ai.w/2;
  const aiSpeed = 3.5 + Math.min(playerScore + aiScore, 10) * 0.15;
  if (ai.x < aiTarget - 10) ai.x += aiSpeed;
  else if (ai.x > aiTarget + 10) ai.x -= aiSpeed;
  ai.x = Math.max(0, Math.min(W - ai.w, ai.x));

  // Ball movement
  ball.x += ball.vx;
  ball.y += ball.vy;
  skullAngle += ball.vx * 0.02;

  // Trail
  trail.push({ x: ball.x, y: ball.y, age: 0 });
  if (trail.length > TRAIL_MAX) trail.shift();
  trail.forEach(p => p.age++);

  // Wall bounce
  if (ball.x - ball.r <= 0 || ball.x + ball.r >= W) {
    ball.vx *= -1;
    ball.x = Math.max(ball.r, Math.min(W - ball.r, ball.x));
    audio.wallSound();
    spawnParticles(ball.x, ball.y, '#cc1100', 4);
    addHitFlash(ball.x, ball.y, 'red');
  }

  // Paddle collision - player
  if (ball.vy > 0 && ball.y + ball.r >= player.y && ball.y - ball.r <= player.y + player.h &&
      ball.x >= player.x && ball.x <= player.x + player.w) {
    const isSmash = smashArmed && Date.now() <= smashWindowEnd;
    smashArmed = false;
    const boost = isSmash ? SMASH_BOOST : 1.0;
    ball.vy = (-Math.abs(ball.vy) - 0.2) * boost;
    ball.vx = ((ball.x - (player.x + player.w/2)) / (player.w/2)) * 5 * boost;
    if (isSmash) {
      smashAnim = 8;  // trigger swing animation frames
      spawnParticles(ball.x, player.y, '#ffffff', 10);
      addHitFlash(ball.x, player.y - 5, 'lightning');
    }
    audio.hitSound();
    spawnParticles(ball.x, player.y, '#ffff00', 5);
    addHitFlash(ball.x, player.y, 'lightning');
  }

  // Paddle collision Ã¢Â€Â” AI
  if (ball.vy < 0 && ball.y - ball.r <= ai.y + ai.h && ball.y + ball.r >= ai.y &&
      ball.x >= ai.x && ball.x <= ai.x + ai.w) {
    ball.vy = Math.abs(ball.vy) + 0.2;
    const offset = (ball.x - (ai.x + ai.w/2)) / (ai.w/2);
    ball.vx = offset * 5;
    audio.hitSound();
    spawnParticles(ball.x, ai.y + ai.h, '#ffff00', 5);
    addHitFlash(ball.x, ai.y + ai.h, 'lightning');
  }

  // Speed cap
  const spd = Math.sqrt(ball.vx*ball.vx + ball.vy*ball.vy);
  const maxSpd = 9;
  if (spd > maxSpd) { ball.vx *= maxSpd/spd; ball.vy *= maxSpd/spd; }

  // Score
  if (ball.y < -20) {
    playerScore++;
    addBloodSplat(ball.x, 20 + Math.random() * 60);
    audio.scoreSound();
    spawnParticles(W/2, 0, '#22c55e', 15);
    if (playerScore >= WIN_SCORE) { state = 'gameover'; matchElapsed = Date.now() - matchStartTime; audio.gameOverSound(); setTimeout(() => spShowOverlay(matchElapsed, true), 400); }
    else resetBall();
  }
  if (ball.y > H + 20) {
    aiScore++;
    addBloodSplat(ball.x, H - 20 - Math.random() * 60);
    audio.scoreSound();
    spawnParticles(W/2, H, '#f87171', 15);
    if (aiScore >= WIN_SCORE) { state = 'gameover'; audio.gameOverSound(); setTimeout(() => spShowOverlay(0, false), 400); }
    else resetBall();
  }

  // Particles
  particles.forEach(p => {
    p.x += p.vx; p.y += p.vy;
    p.life -= 0.03;
    p.vy += 0.1;
  });
  particles = particles.filter(p => p.life > 0);
}

// Render
function render() {
  // Floor image background
  ctx.save();
  if (floorImg.complete && floorImg.naturalWidth > 0) {
    ctx.drawImage(floorImg, 0, 0, W, H);
    // Darken slightly so game elements pop
    ctx.fillStyle = 'rgba(0,0,0,0.28)';
    ctx.fillRect(0, 0, W, H);
  } else {
    ctx.fillStyle = '#111118';
    ctx.fillRect(0, 0, W, H);
  }
  ctx.restore();
  // Blood splatters (GC-style, accumulate on score)
  drawBloodSplatters();

  if (state === 'title') { drawTitle(); return; }
  if (state === 'gameover') { drawGameOver(); return; }

  // Game field
  drawCenterLine();
  drawScore();

  // Paddles
  drawTombstone(player.x, player.y, player.w, player.h, '#22c55e');
  drawTombstone(ai.x, ai.y, ai.w, ai.h, '#f87171');

  // Cords connecting paddles to dfib
  drawCord(player, false);
  drawCord(ai, true);
  // Dfib unit on right wall
  drawDfib();


  // Ball
  drawSkull(ball.x, ball.y, ball.visualR);

  // Particles
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;
  drawHitFlashes();

  // Countdown overlay
  if (state === 'countdown') {
    ctx.fillStyle = 'rgba(10,10,10,0.6)';
    ctx.fillRect(0, 0, W, H);
    const colors = ['#22c55e', '#eab308', '#f87171'];
    const scale = 1 + (countdownTimer/60) * 0.5;
    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.scale(scale, scale);
    ctx.font = '80px Creepster';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = colors[3 - countdownNum] || '#f87171';
    ctx.fillText(countdownNum, 0, 0);
    ctx.restore();
  }

  // Paused
  if (state === 'paused') {
    ctx.fillStyle = 'rgba(10,10,10,0.7)';
    ctx.fillRect(0, 0, W, H);
    ctx.font = '48px Creepster';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#a855f7';
    ctx.fillText('PAUSED', W/2, H/2);
    ctx.font = '20px Creepster';
    ctx.fillStyle = '#c084fc';
    ctx.fillText('Press P to Resume', W/2, H/2 + 50);
  }

  drawMuteIndicator();
}

function loop() { updateMusic();
  update();
  render();
  requestAnimationFrame(loop);
}
loop();

const firebaseConfig = {
  apiKey: "AIzaSyCO1jJVET2TBOMfrJD839jxU0ENYShQ1Fg",
  authDomain: "pitstop-wall.firebaseapp.com",
  databaseURL: "https://pitstop-wall-default-rtdb.firebaseio.com",
  projectId: "pitstop-wall",
  storageBucket: "pitstop-wall.firebasestorage.app",
  messagingSenderId: "767668528451",
  appId: "1:767668528451:web:107ef2d7230f7560fdfbf6"
};
firebase.initializeApp(firebaseConfig);
const spHsRef = firebase.database().ref('highscores/skull-pong');
let spCachedScores = [];
let spMyEntry = null;
let spBestScore = 0;

spHsRef.orderByChild('score').limitToFirst(10).on('value', snap => {
  const d = snap.val();
  spCachedScores = d
    ? Object.entries(d).map(([k,v]) => ({...v, key:k})).sort((a,b) => a.score - b.score)
    : [];
  spBestScore = spCachedScores.length > 0 ? spCachedScores[0].score : 0;
});

function spIsHighScore(timeMs) {
  if (!timeMs) return false;
  return spCachedScores.length < 10 || timeMs < (spCachedScores[spCachedScores.length-1]?.score || Infinity);
}

function spSaveScore(name, s) {
  spMyEntry = { name, score: s, timestamp: Date.now() };
  spHsRef.push({ name, score: s, timestamp: Date.now() });
}

function spRenderLeaderboard() {
  const rows = document.getElementById('spLbRows');
  const medals = ['\u{1F947}','\u{1F948}','\u{1F949}'];
  const colors = ['gold','silver','bronze'];
  rows.innerHTML = spCachedScores.slice(0,10).map((s,i) => {
    const isMe = spMyEntry && s.name===spMyEntry.name && s.score===spMyEntry.score;
    const cls = isMe ? 'me' : (colors[i]||'normal');
    const rank = medals[i] || ((i+1)+'.');
    return '<div class="sp-lb-row '+cls+'"><span>'+rank+' '+(s.name||'???')+'</span><span>'+(s.score?(s.score/1000).toFixed(1)+'s':'--')+'</span></div>';
  }).join('');
  document.getElementById('spLeaderboard').style.display = 'block';
}

function spFormatTime(ms) {
  if (!ms) return '--';
  return (ms / 1000).toFixed(1) + 's';
}

function spShowOverlay(timeMs, playerWon) {
  const bestLine = document.getElementById('spBestLine');
  bestLine.textContent = '';
  document.getElementById('spInitialsSection').style.display = 'none';
  document.getElementById('spLeaderboard').style.display = 'none';
  spMyEntry = null;

  if (playerWon) {
    document.getElementById('spFinalScore').textContent = spFormatTime(timeMs);
    if (spIsHighScore(timeMs)) {
      bestLine.textContent = 'ðŸ† FASTEST TIME!';
      bestLine.style.color = '#eab308';
      document.getElementById('spInitialsSection').style.display = 'block';
      const input = document.getElementById('spInitialsInput');
      input.value = '';
      setTimeout(() => input.focus(), 400);
      const submitFn = () => {
        const name = input.value.toUpperCase().replace(/[^A-Z]/g,'').slice(0,3);
        if (!name) return;
        spSaveScore(name, timeMs);
        document.getElementById('spInitialsSection').style.display = 'none';
        setTimeout(() => spRenderLeaderboard(), 600);
      };
      document.getElementById('spInitialsSubmit').onclick = submitFn;
      input.onkeydown = e => { if (e.key==='Enter') submitFn(); };
    } else {
      if (spCachedScores.length > 0) {
        bestLine.textContent = 'Best: ' + spFormatTime(spCachedScores[0].score);
        bestLine.style.color = '#c084fc';
      }
      spRenderLeaderboard();
    }
  } else {
    document.getElementById('spFinalScore').textContent = 'YOU LOSE';
    spRenderLeaderboard();
  }
  document.getElementById('spOverlay').classList.add('active');
}

function spHideOverlay() {
  document.getElementById('spOverlay').classList.remove('active');
}

document.getElementById('spPlayAgain').onclick = () => { spHideOverlay(); startGame(); };
document.getElementById('spTitleBtn').onclick  = () => { spHideOverlay(); backToTitle(); };

</script>

<style id="sp-lb-styles">
#spOverlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.82);
  z-index: 9999;
  justify-content: center;
  align-items: center;
}
#spOverlay.active { display: flex; }
#spPanel {
  background: #0d0d1a;
  border: 1px solid #7c3aed;
  border-radius: 8px;
  padding: 24px 28px;
  min-width: 280px;
  text-align: center;
  font-family: 'Creepster', cursive;
  color: #e9d5ff;
  box-shadow: 0 0 30px #7c3aed88;
}
#spPanel h2 { font-size: 2rem; color: #f87171; margin-bottom: 10px; }
#spScoreLine { font-size: 1.5rem; margin-bottom: 4px; }
#spBestLine { font-size: 1rem; min-height: 1.4em; margin-bottom: 8px; }
#spInitialsSection { margin-bottom: 10px; }
#spInitialsLabel { font-size: 0.8rem; color: #c084fc; margin-bottom: 6px; }
#spInitialsInput {
  width: 80px; font-size: 1.6rem; text-align: center;
  background: #1a0a2e; border: 1px solid #7c3aed; color: #e9d5ff;
  padding: 4px 8px; border-radius: 4px; font-family: monospace;
  text-transform: uppercase; letter-spacing: 0.2em;
}
#spInitialsSubmit {
  display: block; margin: 8px auto 0;
  background: #7c3aed; color: #fff; border: none;
  padding: 6px 18px; border-radius: 4px; cursor: pointer;
  font-family: 'Creepster', cursive; font-size: 1rem;
}
#spLeaderboard { margin: 8px 0 12px; }
.sp-lb-title { color: rgba(255,255,255,0.4); font-size: 0.75rem; margin-bottom: 5px; letter-spacing: 0.08em; }
.sp-lb-row { display: flex; justify-content: space-between; padding: 2px 4px; font-size: 0.95rem; }
.sp-lb-row.gold   { color: #ffd700; }
.sp-lb-row.silver { color: #c0c0c0; }
.sp-lb-row.bronze { color: #cd7f32; }
.sp-lb-row.normal { color: rgba(255,255,255,0.55); }
.sp-lb-row.me     { color: #c084fc; font-weight: bold; }
#spButtons { display: flex; gap: 12px; justify-content: center; margin-top: 4px; }
.sp-btn {
  background: #1a0a2e; border: 1px solid #7c3aed; color: #e9d5ff;
  padding: 7px 16px; border-radius: 4px; cursor: pointer;
  font-family: 'Creepster', cursive; font-size: 1rem;
}
.sp-btn:hover { background: #2d1b69; }
</style>
<div id="spOverlay">
  <div id="spPanel">
    <h2>GAME OVER</h2>
    <div id="spScoreLine">Time: <span id="spFinalScore">--</span></div>
    <div id="spBestLine"></div>
    <div id="spInitialsSection" style="display:none;">
      <div id="spInitialsLabel">NEW HIGH SCORE â€” enter your initials</div>
      <input id="spInitialsInput" maxlength="3" autocomplete="off" spellcheck="false" />
      <button id="spInitialsSubmit">SUBMIT</button>
    </div>
    <div id="spLeaderboard" style="display:none;">
      <div class="sp-lb-title">TOP SCORES</div>
      <div id="spLbRows"></div>
    </div>
    <div id="spButtons">
      <button class="sp-btn" id="spPlayAgain">&#9654; PLAY AGAIN</button>
      <button class="sp-btn" id="spTitleBtn">&#11013; TITLE</button>
    </div>
  </div>
</div>
</body>
</html>