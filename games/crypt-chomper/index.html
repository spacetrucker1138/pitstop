<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Crypt Chomper ‚Äî Afterverse Arcade</title>
<link href="https://fonts.googleapis.com/css2?family=Creepster&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0a0a; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
canvas { display: block; max-width: 100vw; max-height: 100vh; object-fit: contain; touch-action: none; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const TILE = 28;
const MAP_DATA = [
  "############################",
  "#............##............#",
  "#.####.#####.##.#####.####.#",
  "#O####.#####.##.#####.####O#",
  "#.####.#####.##.#####.####.#",
  "#..........................#",
  "#.####.##.########.##.####.#",
  "#.####.##.########.##.####.#",
  "#......##....##....##......#",
  "######.##### ## #####.######",
  "     #.##### ## #####.#     ",
  "     #.##          ##.#     ",
  "     #.## ###--### ##.#     ",
  "######.## #      # ##.######",
  "      .   #      #   .      ",
  "######.## #      # ##.######",
  "     #.## ######## ##.#     ",
  "     #.##          ##.#     ",
  "     #.## ######## ##.#     ",
  "######.## ######## ##.######",
  "#............##............#",
  "#.####.#####.##.#####.####.#",
  "#.####.#####.##.#####.####.#",
  "#O..##................##..O#",
  "###.##.##.########.##.##.###",
  "###.##.##.########.##.##.###",
  "#......##....##....##......#",
  "#.##########.##.##########.#",
  "#.##########.##.##########.#",
  "#..........................#",
  "############################"
];

const ROWS = MAP_DATA.length;
const COLS = MAP_DATA[0].length;
const W = COLS * TILE;
const H = ROWS * TILE + 80; // extra for HUD
canvas.width = W; canvas.height = H;
const HUD_Y = ROWS * TILE;

// Audio
class AudioMgr {
  constructor() {
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    this.muted = false;
    this.volume = 0.4;
  }
  resume() { if (this.ctx.state === 'suspended') this.ctx.resume(); }
  play(freq, dur, type='square', vol=0.3) {
    if (this.muted) return;
    const o = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = vol * this.volume;
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
    o.connect(g); g.connect(this.ctx.destination);
    o.start(); o.stop(this.ctx.currentTime + dur);
  }
  chomp() { this.play(400 + Math.random()*100, 0.05, 'triangle', 0.2); }
  powerUp() { [500,600,700,800].forEach((f,i) => setTimeout(() => this.play(f, 0.1, 'square', 0.5), i*50)); }
  eatGhost() { this.play(800, 0.1, 'square', 0.5); setTimeout(() => this.play(1200, 0.15, 'square', 0.5), 80); }
  die() { [400,350,300,250,200,150].forEach((f,i) => setTimeout(() => this.play(f, 0.15, 'sawtooth', 0.4), i*100)); }
  start() { [330,440,550].forEach((f,i) => setTimeout(() => this.play(f, 0.1, 'square', 0.4), i*100)); }
}
const audio = new AudioMgr();

// Game state
let state = 'title';
let map = [];
let player, ghosts;
let score = 0, bestScore = 0, lives = 3, level = 1;
let dotsLeft = 0, totalDots = 0;
let powerTimer = 0;
let particles = [];
let countdownNum = 3, countdownTimer = 0;
let moveQueue = null;
let frameCount = 0;

try { bestScore = parseInt(localStorage.getItem('cryptchomper_best')) || 0; } catch(e) {}

function buildMap() {
  map = [];
  dotsLeft = 0;
  for (let r = 0; r < ROWS; r++) {
    map[r] = [];
    for (let c = 0; c < COLS; c++) {
      const ch = MAP_DATA[r][c];
      if (ch === '#') map[r][c] = 1;       // wall
      else if (ch === '.') { map[r][c] = 2; dotsLeft++; } // dot
      else if (ch === 'O') { map[r][c] = 3; dotsLeft++; } // power pellet
      else if (ch === '-') map[r][c] = 4;   // ghost door
      else map[r][c] = 0;                   // empty
    }
  }
  totalDots = dotsLeft;
}

function initEntities() {
  // Player starts bottom center
  player = { col: 14, row: 23, dir: 'left', nextDir: null, moveProgress: 0, mouthAngle: 0 };

  // 4 ghosts with different behaviors
  ghosts = [
    { col: 13, row: 14, dir: 'up', color: '#f87171', emoji: 'üëª', mode: 'scatter', homeCol: 1, homeRow: 1 },
    { col: 14, row: 14, dir: 'up', color: '#60a5fa', emoji: 'üëª', mode: 'scatter', homeCol: COLS-2, homeRow: 1 },
    { col: 13, row: 13, dir: 'down', color: '#4ade80', emoji: 'ü¶á', mode: 'scatter', homeCol: 1, homeRow: ROWS-2 },
    { col: 14, row: 13, dir: 'down', color: '#c084fc', emoji: 'üï∑Ô∏è', mode: 'scatter', homeCol: COLS-2, homeRow: ROWS-2 },
  ];
}

function canMove(col, row, dir) {
  let nc = col, nr = row;
  if (dir === 'left') nc--;
  if (dir === 'right') nc++;
  if (dir === 'up') nr--;
  if (dir === 'down') nr++;
  // Tunnel wrap
  if (nc < 0) nc = COLS - 1;
  if (nc >= COLS) nc = 0;
  if (nr < 0 || nr >= ROWS) return false;
  const tile = map[nr][nc];
  return tile !== 1; // walls block
}

function canMoveGhost(col, row, dir) {
  let nc = col, nr = row;
  if (dir === 'left') nc--;
  if (dir === 'right') nc++;
  if (dir === 'up') nr--;
  if (dir === 'down') nr++;
  if (nc < 0) nc = COLS - 1;
  if (nc >= COLS) nc = 0;
  if (nr < 0 || nr >= ROWS) return false;
  const tile = map[nr][nc];
  return tile !== 1;
}

function moveEntity(e) {
  if (e.dir === 'left') e.col--;
  if (e.dir === 'right') e.col++;
  if (e.dir === 'up') e.row--;
  if (e.dir === 'down') e.row++;
  // Tunnel wrap
  if (e.col < 0) e.col = COLS - 1;
  if (e.col >= COLS) e.col = 0;
}

const OPPOSITE = { left: 'right', right: 'left', up: 'down', down: 'up' };
const DIRS = ['up', 'down', 'left', 'right'];

function ghostAI(ghost) {
  // Get available directions (not backwards, not walls)
  const available = DIRS.filter(d => d !== OPPOSITE[ghost.dir] && canMoveGhost(ghost.col, ghost.row, d));
  if (available.length === 0) {
    // Dead end - reverse
    ghost.dir = OPPOSITE[ghost.dir];
    return;
  }
  if (available.length === 1) {
    ghost.dir = available[0];
    return;
  }

  // Target based on mode
  let targetCol, targetRow;
  if (powerTimer > 0) {
    // Frightened ‚Äî random
    ghost.dir = available[Math.floor(Math.random() * available.length)];
    return;
  } else {
    // Chase player (simplified)
    targetCol = player.col;
    targetRow = player.row;
  }

  // Pick direction that minimizes distance to target
  let bestDist = Infinity, bestDir = available[0];
  for (const d of available) {
    let nc = ghost.col, nr = ghost.row;
    if (d === 'left') nc--; if (d === 'right') nc++;
    if (d === 'up') nr--; if (d === 'down') nr++;
    const dist = (nc - targetCol)**2 + (nr - targetRow)**2;
    if (dist < bestDist) { bestDist = dist; bestDir = d; }
  }
  ghost.dir = bestDir;
}

// Input
document.addEventListener('keydown', e => {
  if (e.key === 'm' || e.key === 'M') { audio.muted = !audio.muted; return; }
  if (state === 'title' && (e.key === 'e' || e.key === 'E' || e.key === ' ')) { startGame(); return; }
  if (state === 'gameover' && (e.key === 'e' || e.key === 'E' || e.key === ' ')) { state = 'title'; return; }
  if (state === 'playing' && (e.key === 'p' || e.key === 'P' || e.key === 'Escape')) { state = 'paused'; return; }
  if (state === 'paused' && (e.key === 'p' || e.key === 'P' || e.key === 'Escape')) { state = 'playing'; return; }

  if (state === 'playing') {
    if (e.key === 'ArrowLeft' || e.key === 'a') moveQueue = 'left';
    if (e.key === 'ArrowRight' || e.key === 'd') moveQueue = 'right';
    if (e.key === 'ArrowUp' || e.key === 'w') moveQueue = 'up';
    if (e.key === 'ArrowDown' || e.key === 's') moveQueue = 'down';
    e.preventDefault();
  }
});

// Touch - swipe controls
let touchStartX = 0, touchStartY = 0;
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  audio.resume();
  if (state === 'title') { startGame(); return; }
  if (state === 'gameover') { state = 'title'; return; }
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
});
canvas.addEventListener('touchend', e => {
  e.preventDefault();
  if (state !== 'playing') return;
  const dx = e.changedTouches[0].clientX - touchStartX;
  const dy = e.changedTouches[0].clientY - touchStartY;
  if (Math.abs(dx) > Math.abs(dy)) {
    moveQueue = dx > 0 ? 'right' : 'left';
  } else {
    moveQueue = dy > 0 ? 'down' : 'up';
  }
});
canvas.addEventListener('click', () => {
  audio.resume();
  if (state === 'title') startGame();
  if (state === 'gameover') state = 'title';
});

function startGame() {
  audio.resume();
  audio.start();
  buildMap();
  initEntities();
  score = 0; lives = 3; level = 1; powerTimer = 0;
  particles = []; moveQueue = null;
  state = 'countdown';
  countdownNum = 3; countdownTimer = 0;
}

function playerDie() {
  lives--;
  audio.die();
  // Death particles
  const px = player.col * TILE + TILE/2;
  const py = player.row * TILE + TILE/2;
  for (let i = 0; i < 12; i++) {
    particles.push({
      x: px, y: py,
      vx: (Math.random()-0.5)*6, vy: (Math.random()-0.5)*6,
      life: 1, color: '#a855f7', size: Math.random()*4+2
    });
  }

  if (lives <= 0) {
    state = 'gameover';
    if (score > bestScore) { bestScore = score; try { localStorage.setItem('cryptchomper_best', bestScore); } catch(e) {} }
  } else {
    // Reset positions
    initEntities();
    powerTimer = 0;
    moveQueue = null;
  }
}

let moveCounter = 0;
const MOVE_RATE = 6; // player moves every N frames
const GHOST_RATE = 8;

function update() {
  frameCount++;

  if (state === 'countdown') {
    countdownTimer++;
    if (countdownTimer >= 60) { countdownTimer = 0; countdownNum--; }
    if (countdownNum <= 0) state = 'playing';
    return;
  }
  if (state !== 'playing') return;

  moveCounter++;

  // Player movement
  if (moveCounter % MOVE_RATE === 0) {
    // Try queued direction
    if (moveQueue && canMove(player.col, player.row, moveQueue)) {
      player.dir = moveQueue;
      moveQueue = null;
    }
    // Move in current direction
    if (canMove(player.col, player.row, player.dir)) {
      moveEntity(player);
    }

    // Animate mouth
    player.mouthAngle = (player.mouthAngle + 0.3) % (Math.PI * 2);

    // Check dot
    const tile = map[player.row][player.col];
    if (tile === 2) {
      map[player.row][player.col] = 0;
      dotsLeft--;
      score += 10;
      audio.chomp();
    } else if (tile === 3) {
      map[player.row][player.col] = 0;
      dotsLeft--;
      score += 50;
      powerTimer = 300; // 5 seconds at 60fps
      audio.powerUp();
      // Reverse all ghosts
      ghosts.forEach(g => g.dir = OPPOSITE[g.dir]);
    }

    // Level clear
    if (dotsLeft <= 0) {
      level++;
      buildMap();
      initEntities();
      powerTimer = 0;
      moveQueue = null;
      state = 'countdown';
      countdownNum = 3; countdownTimer = 0;
      return;
    }
  }

  // Ghost movement
  const ghostRate = powerTimer > 0 ? GHOST_RATE + 4 : Math.max(5, GHOST_RATE - Math.floor(level/3));
  if (moveCounter % ghostRate === 0) {
    for (const ghost of ghosts) {
      ghostAI(ghost);
      if (canMoveGhost(ghost.col, ghost.row, ghost.dir)) {
        moveEntity(ghost);
      }
    }
  }

  // Ghost collision
  for (const ghost of ghosts) {
    if (ghost.col === player.col && ghost.row === player.row) {
      if (powerTimer > 0) {
        // Eat ghost
        score += 200;
        audio.eatGhost();
        ghost.col = 13 + Math.round(Math.random());
        ghost.row = 14;
        ghost.dir = 'up';
        const px = player.col * TILE + TILE/2;
        const py = player.row * TILE + TILE/2;
        for (let i = 0; i < 8; i++) {
          particles.push({
            x: px, y: py,
            vx: (Math.random()-0.5)*6, vy: (Math.random()-0.5)*6 - 2,
            life: 1, color: ghost.color, size: Math.random()*3+2
          });
        }
      } else {
        playerDie();
        return;
      }
    }
  }

  // Power timer
  if (powerTimer > 0) powerTimer--;

  // Particles
  particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.vy += 0.1; p.life -= 0.025; });
  particles = particles.filter(p => p.life > 0);
}

function drawMap() {
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const tile = map[r][c];
      const x = c * TILE, y = r * TILE;

      if (tile === 1) {
        // Wall ‚Äî purple stone
        ctx.fillStyle = '#2d1060';
        ctx.fillRect(x, y, TILE, TILE);
        // Edge detection for better wall rendering
        ctx.strokeStyle = '#5b30a0';
        ctx.lineWidth = 1.5;
        // Draw border only on sides adjacent to non-wall
        if (r > 0 && map[r-1][c] !== 1) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x+TILE, y); ctx.stroke(); }
        if (r < ROWS-1 && map[r+1][c] !== 1) { ctx.beginPath(); ctx.moveTo(x, y+TILE); ctx.lineTo(x+TILE, y+TILE); ctx.stroke(); }
        if (c > 0 && map[r][c-1] !== 1) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y+TILE); ctx.stroke(); }
        if (c < COLS-1 && map[r][c+1] !== 1) { ctx.beginPath(); ctx.moveTo(x+TILE, y); ctx.lineTo(x+TILE, y+TILE); ctx.stroke(); }
      } else if (tile === 4) {
        // Ghost door
        ctx.fillStyle = '#7c3aed';
        ctx.fillRect(x, y + TILE/2 - 2, TILE, 4);
      } else if (tile === 2) {
        // Dot ‚Äî bone pellet
        ctx.fillStyle = '#d4bfff';
        ctx.beginPath();
        ctx.arc(x + TILE/2, y + TILE/2, 3, 0, Math.PI*2);
        ctx.fill();
      } else if (tile === 3) {
        // Power pellet ‚Äî pulsing
        const pulse = Math.sin(frameCount * 0.1) * 3 + 8;
        ctx.fillStyle = '#eab308';
        ctx.shadowColor = '#eab308';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(x + TILE/2, y + TILE/2, pulse, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }
  }
}

function drawPlayer() {
  const x = player.col * TILE + TILE/2;
  const y = player.row * TILE + TILE/2;

  // Skull emoji with mouth animation
  ctx.save();
  ctx.translate(x, y);
  ctx.shadowColor = '#a855f7';
  ctx.shadowBlur = 15;
  ctx.font = `${TILE}px serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('üíÄ', 0, 0);
  ctx.shadowBlur = 0;
  ctx.restore();
}

function drawGhosts() {
  for (const ghost of ghosts) {
    const x = ghost.col * TILE + TILE/2;
    const y = ghost.row * TILE + TILE/2;

    ctx.save();
    ctx.translate(x, y);

    if (powerTimer > 0) {
      // Frightened ‚Äî blue, flashing if almost over
      if (powerTimer < 90 && Math.floor(frameCount/8) % 2 === 0) {
        ctx.globalAlpha = 0.5;
      }
      ctx.shadowColor = '#3b82f6';
      ctx.shadowBlur = 12;
      ctx.font = `${TILE-2}px serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('üò±', 0, 0);
    } else {
      ctx.shadowColor = ghost.color;
      ctx.shadowBlur = 12;
      ctx.font = `${TILE-2}px serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(ghost.emoji, 0, 0);
    }

    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
    ctx.restore();
  }
}

function drawHUD() {
  const y = HUD_Y + 10;
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, HUD_Y, W, 80);

  // Score
  ctx.font = '18px Creepster';
  ctx.textAlign = 'left';
  ctx.fillStyle = '#a855f7';
  ctx.fillText('Score: ' + score, 10, y + 20);

  // Level
  ctx.textAlign = 'center';
  ctx.fillStyle = '#c084fc';
  ctx.fillText('Level ' + level, W/2, y + 20);

  // Lives
  ctx.textAlign = 'right';
  ctx.fillStyle = '#e9d5ff';
  ctx.fillText('üíÄ'.repeat(lives), W - 10, y + 20);

  // Dots left
  ctx.textAlign = 'center';
  ctx.font = '14px Creepster';
  ctx.fillStyle = 'rgba(168,85,247,0.5)';
  ctx.fillText(dotsLeft + ' bones left', W/2, y + 45);

  // Power indicator
  if (powerTimer > 0) {
    ctx.fillStyle = '#eab308';
    const barW = (powerTimer / 300) * 100;
    ctx.fillRect(W/2 - 50, y + 52, barW, 6);
    ctx.strokeStyle = '#eab308';
    ctx.strokeRect(W/2 - 50, y + 52, 100, 6);
  }

  // Mute
  ctx.font = '12px monospace';
  ctx.textAlign = 'right';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText(audio.muted ? 'üîá M ‚Äî Muted' : 'üîä M ‚Äî Sound', W - 8, y + 68);
}

function drawTitle() {
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, W, H);

  const t = Date.now()/1000;

  // Floating ghosts
  const emojis = ['üëª','ü¶á','üï∑Ô∏è','üíÄ','‚ò†Ô∏è'];
  for (let i = 0; i < 5; i++) {
    ctx.font = '30px serif';
    ctx.textAlign = 'center';
    ctx.globalAlpha = 0.15;
    ctx.fillText(emojis[i], W*(i+1)/6, 130 + Math.sin(t+i*1.3)*20);
  }
  ctx.globalAlpha = 1;

  ctx.font = '48px Creepster';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#a855f7';
  ctx.shadowColor = '#a855f7';
  ctx.shadowBlur = 30;
  ctx.fillText('CRYPT CHOMPER', W/2, 250);
  ctx.shadowBlur = 0;

  ctx.font = '18px Creepster';
  ctx.fillStyle = '#c084fc';
  ctx.fillText('Eat the bones. Dodge the ghouls.', W/2, 290);
  ctx.fillText('Grab power pellets to eat them back!', W/2, 315);

  if (bestScore > 0) {
    ctx.font = '20px Creepster';
    ctx.fillStyle = '#eab308';
    ctx.fillText('\u{1F3C6} Best: ' + bestScore, W/2, 365);
  }

  ctx.font = '16px Creepster';
  ctx.fillStyle = '#e9d5ff';
  ctx.fillText('Arrow Keys / WASD / Swipe to Move', W/2, 440);
  ctx.fillText('M ‚Äî Mute | P ‚Äî Pause', W/2, 465);

  const pulse = Math.sin(t*3)*0.3+0.7;
  ctx.globalAlpha = pulse;
  ctx.font = '28px Creepster';
  ctx.fillStyle = '#f87171';
  ctx.fillText('Press E or Tap to Start', W/2, 540);
  ctx.globalAlpha = 1;

  ctx.font = '14px Creepster';
  ctx.fillStyle = 'rgba(168,85,247,0.6)';
  ctx.fillText('\u2620 A JURN Production \u2620', W/2, H - 30);

  // Mute
  ctx.font = '12px monospace';
  ctx.textAlign = 'right';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText(audio.muted ? 'üîá M ‚Äî Muted' : 'üîä M ‚Äî Sound', W - 8, H - 8);
}

function drawGameOver() {
  ctx.fillStyle = 'rgba(10,10,10,0.88)';
  ctx.fillRect(0, 0, W, H);

  ctx.font = '52px Creepster';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#f87171';
  ctx.shadowColor = '#f87171';
  ctx.shadowBlur = 25;
  ctx.fillText('GAME OVER', W/2, 250);
  ctx.shadowBlur = 0;

  ctx.font = '28px Creepster';
  ctx.fillStyle = '#e9d5ff';
  ctx.fillText('Score: ' + score, W/2, 320);
  ctx.fillText('Level: ' + level, W/2, 355);

  if (score >= bestScore && score > 0) {
    ctx.fillStyle = '#eab308';
    ctx.font = '24px Creepster';
    ctx.fillText('\u{1F3C6} NEW BEST!', W/2, 405);
  }

  const t = Date.now()/1000;
  ctx.globalAlpha = Math.sin(t*3)*0.3+0.7;
  ctx.font = '22px Creepster';
  ctx.fillStyle = '#c084fc';
  ctx.fillText('Press E or Tap to Continue', W/2, 490);
  ctx.globalAlpha = 1;
}

function render() {
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, W, H);

  if (state === 'title') { drawTitle(); return; }
  if (state === 'gameover') { drawGameOver(); return; }

  drawMap();
  drawPlayer();
  drawGhosts();
  drawHUD();

  // Particles
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;

  // Countdown
  if (state === 'countdown') {
    ctx.fillStyle = 'rgba(10,10,10,0.6)';
    ctx.fillRect(0, 0, W, H);
    const colors = ['#22c55e','#eab308','#f87171'];
    const scale = 1 + (countdownTimer/60)*0.5;
    ctx.save();
    ctx.translate(W/2, ROWS*TILE/2);
    ctx.scale(scale, scale);
    ctx.font = '80px Creepster';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = colors[3-countdownNum] || '#f87171';
    ctx.fillText(countdownNum, 0, 0);
    ctx.restore();
  }

  // Paused
  if (state === 'paused') {
    ctx.fillStyle = 'rgba(10,10,10,0.7)';
    ctx.fillRect(0, 0, W, H);
    ctx.font = '48px Creepster';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#a855f7';
    ctx.fillText('PAUSED', W/2, ROWS*TILE/2);
    ctx.font = '20px Creepster';
    ctx.fillStyle = '#c084fc';
    ctx.fillText('Press P to Resume', W/2, ROWS*TILE/2 + 50);
  }
}

function loop() { update(); render(); requestAnimationFrame(loop); }
loop();
</script>
</body>
</html>