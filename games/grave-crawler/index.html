<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Grave Crawler — Afterverse Arcade</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Creepster&display=swap');
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #050508;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  min-height: 100vh; font-family: 'Creepster', cursive; overflow: hidden;
}
canvas { border: 2px solid rgba(191,0,255,0.3); border-radius: 8px; box-shadow: 0 0 30px rgba(191,0,255,0.15), 0 0 60px rgba(0,0,0,0.5); }
#ui {
  position: absolute; top: 0; left: 0; right: 0;
  display: flex; justify-content: space-between; padding: 15px 20px;
  pointer-events: none; z-index: 10;
}
.score-label { color: #39ff14; font-size: 1.4rem; text-shadow: 0 0 10px rgba(57,255,20,0.5); letter-spacing: 2px; }
.high-label { color: #bf00ff; font-size: 1.2rem; text-shadow: 0 0 10px rgba(191,0,255,0.5); }
#back-link {
  position: fixed; bottom: 15px; left: 50%; transform: translateX(-50%);
  color: #888; text-decoration: none; font-family: 'Inter', sans-serif; font-size: 0.85rem;
  transition: color 0.3s;
}
#back-link:hover { color: #39ff14; }
#mobile-controls {
  display: none; position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
  z-index: 100;
}
.d-pad { display: grid; grid-template-columns: 60px 60px 60px; grid-template-rows: 60px 60px 60px; gap: 4px; }
.d-btn {
  background: rgba(191,0,255,0.15); border: 1px solid rgba(191,0,255,0.3); border-radius: 8px;
  color: #bf00ff; font-size: 1.5rem; display: flex; align-items: center; justify-content: center;
  cursor: pointer; user-select: none; -webkit-user-select: none; touch-action: manipulation;
}
.d-btn:active { background: rgba(191,0,255,0.35); }
.d-blank { background: transparent; border: none; }
@media (pointer: coarse) { #mobile-controls { display: block; } }
</style>
</head>
<body>
<div id="ui">
  <div class="score-label">SCORE: <span id="score">0</span></div>
  <div class="high-label">BEST: <span id="high">0</span></div>
</div>
<canvas id="game"></canvas>
<div id="mobile-controls">
  <div class="d-pad">
    <div class="d-blank"></div>
    <div class="d-btn" data-dir="up">▲</div>
    <div class="d-blank"></div>
    <div class="d-btn" data-dir="left">◀</div>
    <div class="d-blank"></div>
    <div class="d-btn" data-dir="right">▶</div>
    <div class="d-blank"></div>
    <div class="d-btn" data-dir="down">▼</div>
    <div class="d-blank"></div>
  </div>
</div>
<a id="back-link" href="../../games.html">← Back to Afterverse Arcade</a>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const highEl = document.getElementById('high');

const CELL = 20;
let COLS, ROWS;
function resize() {
  const maxW = Math.min(window.innerWidth - 20, 600);
  const maxH = Math.min(window.innerHeight - 120, 600);
  COLS = Math.floor(maxW / CELL);
  ROWS = Math.floor(maxH / CELL);
  canvas.width = COLS * CELL;
  canvas.height = ROWS * CELL;
}
resize();

let snake, dir, nextDir, food, score, highScore, gameOver, speed, lastTime, moveTimer;

function loadHigh() { highScore = parseInt(localStorage.getItem('gc_high') || '0'); highEl.textContent = highScore; }
function saveHigh() { if (score > highScore) { highScore = score; localStorage.setItem('gc_high', highScore); highEl.textContent = highScore; } }

function init() {
  const midX = Math.floor(COLS / 2);
  const midY = Math.floor(ROWS / 2);
  snake = [{x: midX, y: midY}, {x: midX-1, y: midY}, {x: midX-2, y: midY}];
  dir = {x: 1, y: 0}; nextDir = {x: 1, y: 0};
  score = 0; scoreEl.textContent = '0';
  gameOver = false; speed = 120; moveTimer = 0;
  placeFood();
  loadHigh();
}

function placeFood() {
  let pos;
  do {
    pos = { x: Math.floor(Math.random() * COLS), y: Math.floor(Math.random() * ROWS) };
  } while (snake.some(s => s.x === pos.x && s.y === pos.y));
  food = pos;
}

function drawSkull(cx, cy, size) {
  ctx.save();
  ctx.translate(cx, cy);
  const s = size / 20;
  // skull shape
  ctx.fillStyle = '#e8e0d4';
  ctx.beginPath();
  ctx.arc(0, -2*s, 8*s, Math.PI, 0, false);
  ctx.lineTo(6*s, 6*s);
  ctx.quadraticCurveTo(3*s, 10*s, 0, 8*s);
  ctx.quadraticCurveTo(-3*s, 10*s, -6*s, 6*s);
  ctx.closePath();
  ctx.fill();
  // eyes
  ctx.fillStyle = '#bf00ff';
  ctx.shadowColor = '#bf00ff'; ctx.shadowBlur = 6;
  ctx.beginPath(); ctx.arc(-3*s, -1*s, 2*s, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(3*s, -1*s, 2*s, 0, Math.PI*2); ctx.fill();
  ctx.shadowBlur = 0;
  // nose
  ctx.fillStyle = '#333';
  ctx.beginPath(); ctx.moveTo(0, 2*s); ctx.lineTo(-1*s, 4*s); ctx.lineTo(1*s, 4*s); ctx.closePath(); ctx.fill();
  ctx.restore();
}

function drawBone(x, y, w, h, i) {
  const cx = x + w/2, cy = y + h/2;
  const glow = i === 0 ? 0.6 : 0.15 + (i / snake.length) * 0.15;
  ctx.save();
  // bone segment
  ctx.fillStyle = `rgba(232,224,212,${0.9 - i * 0.02})`;
  ctx.shadowColor = '#39ff14';
  ctx.shadowBlur = i === 0 ? 12 : 4;
  const r = Math.min(w, h) * 0.35;
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fill();
  // knobs for head
  if (i === 0) {
    ctx.fillStyle = '#39ff14';
    ctx.shadowColor = '#39ff14'; ctx.shadowBlur = 8;
    const eyeOff = r * 0.35;
    ctx.beginPath();
    ctx.arc(cx - eyeOff + dir.x * 2, cy - eyeOff + dir.y * 2, 2.5, 0, Math.PI*2);
    ctx.arc(cx + eyeOff + dir.x * 2, cy - eyeOff + dir.y * 2, 2.5, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.restore();
}

function draw() {
  // background
  ctx.fillStyle = '#050508';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  // grid lines
  ctx.strokeStyle = 'rgba(191,0,255,0.04)';
  ctx.lineWidth = 0.5;
  for (let x = 0; x <= COLS; x++) { ctx.beginPath(); ctx.moveTo(x*CELL, 0); ctx.lineTo(x*CELL, ROWS*CELL); ctx.stroke(); }
  for (let y = 0; y <= ROWS; y++) { ctx.beginPath(); ctx.moveTo(0, y*CELL); ctx.lineTo(COLS*CELL, y*CELL); ctx.stroke(); }

  // food (skull)
  drawSkull(food.x * CELL + CELL/2, food.y * CELL + CELL/2, CELL * 0.9);

  // snake
  for (let i = snake.length - 1; i >= 0; i--) {
    drawBone(snake[i].x * CELL, snake[i].y * CELL, CELL, CELL, i);
  }

  if (gameOver) {
    ctx.fillStyle = 'rgba(5,5,8,0.85)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#ff1744';
    ctx.font = '48px Creepster'; ctx.textAlign = 'center';
    ctx.shadowColor = '#ff1744'; ctx.shadowBlur = 20;
    ctx.fillText('DEAD', canvas.width/2, canvas.height/2 - 20);
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#e8e0d4';
    ctx.font = '20px Creepster';
    ctx.fillText('Score: ' + score, canvas.width/2, canvas.height/2 + 20);
    ctx.fillStyle = '#888';
    ctx.font = '16px Creepster';
    ctx.fillText('Press SPACE or Tap to rise again', canvas.width/2, canvas.height/2 + 55);
  }
}

function update(dt) {
  if (gameOver) return;
  moveTimer += dt;
  if (moveTimer < speed) return;
  moveTimer = 0;
  dir = {...nextDir};
  const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };
  // wall collision
  if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS) { endGame(); return; }
  // self collision
  if (snake.some(s => s.x === head.x && s.y === head.y)) { endGame(); return; }
  snake.unshift(head);
  if (head.x === food.x && head.y === food.y) {
    score++; scoreEl.textContent = score;
    if (speed > 60) speed -= 2;
    placeFood();
  } else {
    snake.pop();
  }
}

function endGame() { gameOver = true; saveHigh(); }

function loop(ts) {
  if (!lastTime) lastTime = ts;
  const dt = ts - lastTime;
  lastTime = ts;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

// controls
document.addEventListener('keydown', e => {
  if (gameOver && (e.code === 'Space' || e.code === 'Enter')) { init(); return; }
  const map = { ArrowUp: {x:0,y:-1}, ArrowDown: {x:0,y:1}, ArrowLeft: {x:-1,y:0}, ArrowRight: {x:1,y:0},
                KeyW: {x:0,y:-1}, KeyS: {x:0,y:1}, KeyA: {x:-1,y:0}, KeyD: {x:1,y:0} };
  if (map[e.code]) {
    const nd = map[e.code];
    if (nd.x !== -dir.x || nd.y !== -dir.y) nextDir = nd;
    e.preventDefault();
  }
});

// mobile d-pad
document.querySelectorAll('.d-btn').forEach(btn => {
  const dirMap = { up: {x:0,y:-1}, down: {x:0,y:1}, left: {x:-1,y:0}, right: {x:1,y:0} };
  btn.addEventListener('touchstart', e => {
    e.preventDefault();
    if (gameOver) { init(); return; }
    const nd = dirMap[btn.dataset.dir];
    if (nd && (nd.x !== -dir.x || nd.y !== -dir.y)) nextDir = nd;
  });
});

// tap to restart
canvas.addEventListener('click', () => { if (gameOver) init(); });

window.addEventListener('resize', () => { resize(); init(); });

init();
requestAnimationFrame(loop);
</script>
</body>
</html>