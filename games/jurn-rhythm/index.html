<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>JURN - Rhythm Attack</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Permanent+Marker&family=Press+Start+2P&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #000;
    overflow: hidden;
    font-family: 'Press Start 2P', monospace;
    color: #fff;
    user-select: none;
  }

  #game-container {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
  }

  /* Video backdrop */
  #video-backdrop {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    object-fit: cover;
    z-index: 0;
    opacity: 0.4;
    transition: filter 0.5s ease, opacity 0.5s ease;
  }

  /* Dark overlay on top of video */
  #video-overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: linear-gradient(180deg, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0.4) 40%, rgba(0,0,0,0.8) 100%);
    z-index: 1;
  }

  /* Game canvas */
  #game-canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 2;
  }

  /* HUD */
  #hud {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 3;
    pointer-events: none;
  }

  #score-display {
    position: absolute;
    top: 20px; right: 30px;
    text-align: right;
  }
  #score-display .score-label { font-size: 10px; color: #888; letter-spacing: 2px; }
  #score-display .score-value { font-size: 28px; color: #0ff; text-shadow: 0 0 20px #0ff; }

  #combo-display {
    position: absolute;
    top: 90px; right: 30px;
    text-align: right;
    opacity: 0;
    transition: opacity 0.2s;
  }
  #combo-display.active { opacity: 1; }
  #combo-display .combo-count { font-size: 36px; color: #f0f; text-shadow: 0 0 30px #f0f; }
  #combo-display .combo-label { font-size: 10px; color: #c0c; letter-spacing: 2px; }

  #multiplier-display {
    position: absolute;
    top: 160px; right: 30px;
    font-size: 14px;
    color: #ff0;
    text-shadow: 0 0 10px #ff0;
  }

  #difficulty-label {
    position: absolute;
    top: 20px; left: 50px;
    font-size: 10px;
    color: #888;
    letter-spacing: 2px;
    text-transform: uppercase;
  }

  /* Song progress bar */
  #progress-bar-container {
    position: absolute;
    top: 10px; left: 30px; right: 200px;
    height: 4px;
    background: rgba(255,255,255,0.1);
    border-radius: 2px;
  }
  #progress-bar {
    height: 100%;
    background: linear-gradient(90deg, #0ff, #f0f);
    border-radius: 2px;
    width: 0%;
    transition: width 0.5s linear;
  }

  /* Hit feedback */
  #hit-feedback {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    opacity: 0;
    pointer-events: none;
    z-index: 10;
  }
  #hit-feedback.perfect { color: #0ff; text-shadow: 0 0 30px #0ff; }
  #hit-feedback.great { color: #0f0; text-shadow: 0 0 20px #0f0; }
  #hit-feedback.good { color: #ff0; text-shadow: 0 0 15px #ff0; }
  #hit-feedback.miss { color: #f00; text-shadow: 0 0 15px #f00; }

  /* Rock meter */
  #rock-meter-container {
    position: absolute;
    left: 20px;
    top: 50%;
    transform: translateY(-50%);
    width: 20px;
    height: 300px;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 10px;
    overflow: hidden;
  }
  #rock-meter {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 50%;
    background: linear-gradient(0deg, #0f0, #ff0, #f00);
    border-radius: 0 0 10px 10px;
    transition: height 0.3s ease;
  }

  /* Start screen */
  #start-screen {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 100;
    background: rgba(0,0,0,0.95);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 15px;
  }
  #start-screen h1 {
    font-family: 'Permanent Marker', cursive;
    font-size: 64px;
    color: #0ff;
    text-shadow: 0 0 40px #0ff, 0 0 80px #0ff;
    letter-spacing: 10px;
  }
  #start-screen h2 {
    font-family: 'Permanent Marker', cursive;
    font-size: 24px;
    color: #f0f;
    text-shadow: 0 0 20px #f0f;
  }
  #start-screen .song-title {
    font-family: 'Press Start 2P', monospace;
    font-size: 12px;
    color: #ff0;
    margin-top: 10px;
  }
  #start-screen .instructions {
    font-size: 10px;
    color: #888;
    line-height: 2;
    text-align: center;
    margin-top: 15px;
  }
  #start-screen .instructions span { color: #0ff; }

  .difficulty-select {
    display: flex;
    gap: 20px;
    margin-top: 25px;
  }
  .diff-btn {
    font-family: 'Press Start 2P', monospace;
    font-size: 12px;
    border: 2px solid;
    padding: 15px 30px;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 2px;
    background: transparent;
    transition: all 0.2s;
    pointer-events: auto;
  }
  .diff-btn:hover {
    transform: scale(1.05);
  }
  .diff-easy {
    color: #0f0;
    border-color: #0f0;
    text-shadow: 0 0 10px #0f0;
  }
  .diff-easy:hover { background: rgba(0,255,0,0.15); box-shadow: 0 0 30px rgba(0,255,0,0.3); }
  .diff-hard {
    color: #f00;
    border-color: #f00;
    text-shadow: 0 0 10px #f00;
  }
  .diff-hard:hover { background: rgba(255,0,0,0.15); box-shadow: 0 0 30px rgba(255,0,0,0.3); }

  .diff-desc {
    font-size: 8px;
    color: #666;
    margin-top: 5px;
    text-align: center;
  }

  /* Results screen */
  #results-screen {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 100;
    background: rgba(0,0,0,0.95);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 12px;
  }
  #results-screen h1 {
    font-family: 'Permanent Marker', cursive;
    font-size: 48px;
    color: #0ff;
    text-shadow: 0 0 30px #0ff;
  }
  #results-screen .stat {
    font-size: 11px;
    color: #ccc;
    line-height: 2.5;
  }
  #results-screen .stat .val { color: #0ff; }
  #results-screen .grade {
    font-size: 72px;
    font-family: 'Permanent Marker', cursive;
    margin: 5px 0;
  }
  .grade-s { color: #0ff; text-shadow: 0 0 40px #0ff, 0 0 80px #0ff; }
  .grade-a { color: #0f0; text-shadow: 0 0 30px #0f0; }
  .grade-b { color: #ff0; text-shadow: 0 0 20px #ff0; }
  .grade-c { color: #f80; text-shadow: 0 0 20px #f80; }
  .grade-f { color: #f00; text-shadow: 0 0 20px #f00; }

  #results-screen .start-btn {
    font-family: 'Press Start 2P', monospace;
    font-size: 12px;
    color: #000;
    background: #0ff;
    border: none;
    padding: 12px 30px;
    cursor: pointer;
    letter-spacing: 2px;
    margin-top: 15px;
    pointer-events: auto;
  }

  /* Particles container */
  #particles {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 4;
    pointer-events: none;
  }

  /* Loading overlay */
  #loading-overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 200;
    background: #000;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 20px;
  }
  #loading-overlay .loading-text {
    font-size: 14px;
    color: #0ff;
    animation: loadPulse 1s ease-in-out infinite;
  }
  @keyframes loadPulse {
    0%, 100% { opacity: 0.5; }
    50% { opacity: 1; }
  }
  #loading-bar-outer {
    width: 300px; height: 6px;
    background: rgba(255,255,255,0.1);
    border-radius: 3px;
  }
  #loading-bar-inner {
    height: 100%;
    background: linear-gradient(90deg, #0ff, #f0f);
    border-radius: 3px;
    width: 0%;
    transition: width 0.3s;
  }

  /* Countdown */
  #countdown {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-family: 'Permanent Marker', cursive;
    font-size: 120px;
    color: #0ff;
    text-shadow: 0 0 60px #0ff;
    z-index: 50;
    opacity: 0;
    pointer-events: none;
  }
</style>
</head>
<body>
<div id="game-container">
  <video id="video-backdrop" autoplay loop muted playsinline></video>
  <div id="video-overlay"></div>
  <canvas id="game-canvas"></canvas>

  <div id="hud">
    <div id="progress-bar-container"><div id="progress-bar"></div></div>
    <div id="score-display">
      <div class="score-label">SCORE</div>
      <div class="score-value" id="score-value">0</div>
    </div>
    <div id="combo-display">
      <div class="combo-count" id="combo-count">0</div>
      <div class="combo-label">COMBO</div>
    </div>
    <div id="multiplier-display" id="multiplier-value"></div>
    <div id="difficulty-label"></div>
    <div id="rock-meter-container"><div id="rock-meter"></div></div>
    <div id="hit-feedback"></div>
  </div>

  <div id="countdown"></div>
  <div id="particles"></div>

  <!-- Loading screen -->
  <div id="loading-overlay">
    <div class="loading-text">LOADING TRACK...</div>
    <div id="loading-bar-outer"><div id="loading-bar-inner"></div></div>
  </div>

  <!-- Start screen -->
  <div id="start-screen">
    <h1>JURN</h1>
    <h2>RHYTHM ATTACK</h2>
    <div class="song-title">&#9835; GET READY FOR GET HAPPY &#9835;</div>
    <div class="instructions">
      <span>A</span> Bass (Taz) &nbsp;|&nbsp;
      <span>S</span> Drums (Bonecrush) &nbsp;|&nbsp;
      <span>D</span> Guitar (Riff-Rot) &nbsp;|&nbsp;
      <span>F</span> Vocals (Vox)<br><br>
      Hit the keys when notes reach the strike zone
    </div>
    <div class="difficulty-select">
      <div>
        <button class="diff-btn diff-easy" id="btn-easy">EASY</button>
        <div class="diff-desc">Chill vibes</div>
      </div>
      <div>
        <button class="diff-btn diff-hard" id="btn-hard">HARD</button>
        <div class="diff-desc">Mosh pit</div>
      </div>
    </div>
  </div>

  <!-- Results screen -->
  <div id="results-screen">
    <h1>SONG COMPLETE</h1>
    <div class="grade" id="result-grade"></div>
    <div class="stat">SCORE: <span class="val" id="result-score"></span></div>
    <div class="stat">MAX COMBO: <span class="val" id="result-combo"></span></div>
    <div class="stat">PERFECT: <span class="val" id="result-perfect"></span></div>
    <div class="stat">GREAT: <span class="val" id="result-great"></span></div>
    <div class="stat">GOOD: <span class="val" id="result-good"></span></div>
    <div class="stat">MISS: <span class="val" id="result-miss"></span></div>
    <div class="stat">ACCURACY: <span class="val" id="result-accuracy"></span></div>
    <button class="start-btn" id="restart-btn" style="margin-top:15px">PLAY AGAIN</button>
  </div>
</div>

<script>
// ============================================================
// CONFIGURATION
// ============================================================
const CONFIG = {
  BPM: 155,
  SONG_DURATION: 180,
  SCROLL_SPEED: 6,
  LANE_COUNT: 4,
  LANE_KEYS: ['a', 's', 'd', 'f'],
  LANE_COLORS: ['#f0f', '#0ff', '#0f0', '#ff0'],
  LANE_GLOW: ['rgba(255,0,255,', 'rgba(0,255,255,', 'rgba(0,255,0,', 'rgba(255,255,0,'],
  LANE_NAMES: ['TAZ', 'CRUSH', 'RIFF', 'VOX'],
  HIT_Y: 0.88,
  NOTE_RADIUS: 22,
  // Timing windows (ms)
  PERFECT_WINDOW: 50,
  GREAT_WINDOW: 100,
  GOOD_WINDOW: 150,
  // Scoring
  PERFECT_SCORE: 300,
  GREAT_SCORE: 200,
  GOOD_SCORE: 100,
  // Multiplier
  MULT_THRESHOLDS: [10, 30, 60, 100],
  MAX_MULTIPLIER: 5,
  // Rock meter
  ROCK_METER_MAX: 100,
  ROCK_METER_START: 50,
  ROCK_HIT_GAIN: 2,
  ROCK_MISS_PENALTY: 8,
  // Audio
  AUDIO_URL: 'audio/combined.mp3',
};

// ============================================================
// SONG STRUCTURE @ 155 BPM
// ============================================================
const SONG = {
  bpm: 155,
  msPerBeat: 60000 / 155,
  sections: [
    { name: 'intro',       startMs: 0,      endMs: 13000,  type: 'instrumental' },
    { name: 'verse1',      startMs: 13000,  endMs: 34000,  type: 'verse' },
    { name: 'chorus1',     startMs: 34000,  endMs: 58000,  type: 'chorus' },
    { name: 'postChorus1', startMs: 58000,  endMs: 83000,  type: 'post_chorus' },
    { name: 'break',       startMs: 83000,  endMs: 91000,  type: 'instrumental' },
    { name: 'verse2',      startMs: 91000,  endMs: 116000, type: 'verse' },
    { name: 'chorus2',     startMs: 116000, endMs: 130000, type: 'chorus' },
    { name: 'postChorus2', startMs: 130000, endMs: 150000, type: 'post_chorus' },
    { name: 'outro',       startMs: 150000, endMs: 180000, type: 'outro' },
  ]
};

// ============================================================
// BEATMAP GENERATOR — Two difficulty levels
// ============================================================
function generateBeatmap(difficulty) {
  const notes = [];
  const b = SONG.msPerBeat;
  const h = b / 2;

  for (const sec of SONG.sections) {
    let t = sec.startMs;
    const end = sec.endMs;

    if (difficulty === 'easy') {
      // ---- EASY: ~40-50% fewer notes, mostly single hits on strong beats ----
      switch (sec.type) {
        case 'instrumental':
          while (t < end) {
            notes.push({ time: t, lane: 1 });          // drums beat 1
            notes.push({ time: t + b, lane: 2 });      // guitar beat 2
            notes.push({ time: t + b*2, lane: 0 });    // bass beat 3
            notes.push({ time: t + b*3, lane: 1 });    // drums beat 4
            t += b * 4;
          }
          break;
        case 'verse':
          while (t < end) {
            notes.push({ time: t, lane: 3 });           // vocals beat 1
            notes.push({ time: t + b, lane: 1 });       // drums beat 2
            notes.push({ time: t + b*2, lane: 3 });     // vocals beat 3
            notes.push({ time: t + b*2, lane: 2 });     // guitar beat 3
            notes.push({ time: t + b*3, lane: 1 });     // drums beat 4
            t += b * 4;
          }
          break;
        case 'chorus':
          while (t < end) {
            // Chorus: still feels energetic but manageable
            notes.push({ time: t, lane: 0 });
            notes.push({ time: t, lane: 2 });
            notes.push({ time: t + b, lane: 1 });
            notes.push({ time: t + b, lane: 3 });
            notes.push({ time: t + b*2, lane: 0 });
            notes.push({ time: t + b*2, lane: 2 });
            notes.push({ time: t + b*3, lane: 1 });
            notes.push({ time: t + b*3, lane: 3 });
            t += b * 4;
          }
          break;
        case 'post_chorus':
          while (t < end) {
            notes.push({ time: t, lane: 0 });
            notes.push({ time: t + b, lane: 1 });
            notes.push({ time: t + b*2, lane: 2 });
            notes.push({ time: t + b*2, lane: 3 });
            notes.push({ time: t + b*3, lane: 1 });
            t += b * 4;
          }
          break;
        case 'outro':
          while (t < end - 3000) {
            notes.push({ time: t, lane: 0 });
            notes.push({ time: t, lane: 1 });
            notes.push({ time: t + b, lane: 2 });
            notes.push({ time: t + b, lane: 3 });
            notes.push({ time: t + b*2, lane: 1 });
            notes.push({ time: t + b*3, lane: 0 });
            notes.push({ time: t + b*3, lane: 2 });
            t += b * 4;
          }
          // Final chord
          notes.push({ time: end - 2000, lane: 0 });
          notes.push({ time: end - 2000, lane: 1 });
          notes.push({ time: end - 2000, lane: 2 });
          notes.push({ time: end - 2000, lane: 3 });
          break;
      }
    } else {
      // ---- HARD: Dense patterns, eighth notes, multi-lane hits ----
      switch (sec.type) {
        case 'instrumental':
          while (t < end) {
            notes.push({ time: t, lane: 1 });
            notes.push({ time: t, lane: 2 });
            notes.push({ time: t + h, lane: 0 });
            notes.push({ time: t + b, lane: 1 });
            notes.push({ time: t + b + h, lane: 2 });
            notes.push({ time: t + b*2, lane: 1 });
            notes.push({ time: t + b*2, lane: 0 });
            notes.push({ time: t + b*3, lane: 2 });
            notes.push({ time: t + b*3 + h, lane: 1 });
            t += b * 4;
          }
          break;
        case 'verse':
          while (t < end) {
            notes.push({ time: t, lane: 3 });
            notes.push({ time: t, lane: 1 });
            notes.push({ time: t + h, lane: 0 });
            notes.push({ time: t + b, lane: 1 });
            notes.push({ time: t + b, lane: 2 });
            notes.push({ time: t + b + h, lane: 3 });
            notes.push({ time: t + b*2, lane: 1 });
            notes.push({ time: t + b*2, lane: 3 });
            notes.push({ time: t + b*2 + h, lane: 0 });
            notes.push({ time: t + b*3, lane: 1 });
            notes.push({ time: t + b*3, lane: 2 });
            t += b * 4;
          }
          break;
        case 'chorus':
          while (t < end) {
            // Dense chorus — every lane active, eighth note subdivisions
            notes.push({ time: t, lane: 0 });
            notes.push({ time: t, lane: 1 });
            notes.push({ time: t, lane: 2 });
            notes.push({ time: t, lane: 3 });
            notes.push({ time: t + h, lane: 1 });
            notes.push({ time: t + h, lane: 2 });
            notes.push({ time: t + b, lane: 3 });
            notes.push({ time: t + b, lane: 0 });
            notes.push({ time: t + b, lane: 1 });
            notes.push({ time: t + b + h, lane: 2 });
            notes.push({ time: t + b*2, lane: 0 });
            notes.push({ time: t + b*2, lane: 1 });
            notes.push({ time: t + b*2, lane: 2 });
            notes.push({ time: t + b*2 + h, lane: 3 });
            notes.push({ time: t + b*3, lane: 1 });
            notes.push({ time: t + b*3, lane: 2 });
            notes.push({ time: t + b*3 + h, lane: 0 });
            notes.push({ time: t + b*3 + h, lane: 1 });
            t += b * 4;
          }
          break;
        case 'post_chorus':
          while (t < end) {
            notes.push({ time: t, lane: 0 });
            notes.push({ time: t, lane: 2 });
            notes.push({ time: t + h, lane: 1 });
            notes.push({ time: t + b, lane: 3 });
            notes.push({ time: t + b, lane: 1 });
            notes.push({ time: t + b + h, lane: 0 });
            notes.push({ time: t + b + h, lane: 2 });
            notes.push({ time: t + b*2, lane: 1 });
            notes.push({ time: t + b*2 + h, lane: 3 });
            notes.push({ time: t + b*3, lane: 0 });
            notes.push({ time: t + b*3, lane: 1 });
            notes.push({ time: t + b*3, lane: 2 });
            notes.push({ time: t + b*3 + h, lane: 1 });
            t += b * 4;
          }
          break;
        case 'outro':
          while (t < end - 3000) {
            // Dense all-lane assault
            notes.push({ time: t, lane: 0 });
            notes.push({ time: t, lane: 1 });
            notes.push({ time: t + h, lane: 2 });
            notes.push({ time: t + h, lane: 3 });
            notes.push({ time: t + b, lane: 0 });
            notes.push({ time: t + b, lane: 1 });
            notes.push({ time: t + b + h, lane: 2 });
            notes.push({ time: t + b + h, lane: 3 });
            notes.push({ time: t + b*2, lane: 0 });
            notes.push({ time: t + b*2, lane: 1 });
            notes.push({ time: t + b*2, lane: 2 });
            notes.push({ time: t + b*2, lane: 3 });
            notes.push({ time: t + b*3, lane: 1 });
            notes.push({ time: t + b*3 + h, lane: 0 });
            notes.push({ time: t + b*3 + h, lane: 2 });
            t += b * 4;
          }
          notes.push({ time: end - 2000, lane: 0 });
          notes.push({ time: end - 2000, lane: 1 });
          notes.push({ time: end - 2000, lane: 2 });
          notes.push({ time: end - 2000, lane: 3 });
          break;
      }
    }
  }

  notes.sort((a, b) => a.time - b.time);
  return notes;
}

// ============================================================
// GAME ENGINE
// ============================================================
class JURNRhythmGame {
  constructor() {
    this.canvas = document.getElementById('game-canvas');
    this.ctx = this.canvas.getContext('2d');
    this.video = document.getElementById('video-backdrop');
    this.audio = null;
    this.audioLoaded = false;
    this.difficulty = 'easy';

    // State
    this.state = 'start';
    this.score = 0;
    this.combo = 0;
    this.maxCombo = 0;
    this.multiplier = 1;
    this.rockMeter = CONFIG.ROCK_METER_START;
    this.stats = { perfect: 0, great: 0, good: 0, miss: 0 };
    this.totalNotes = 0;

    // Notes
    this.beatmap = [];
    this.activeNotes = [];
    this.nextNoteIndex = 0;

    // Input
    this.keysDown = {};
    this.keyFlash = [0, 0, 0, 0];

    // Timing
    this.songStartTime = 0;
    this.lastFrameTime = 0;
    this.countdownActive = false;

    // Visual
    this.particles = [];
    this.hitFeedbackTimer = 0;

    this.resize();
    this.bindEvents();
    this.preloadAudio();
  }

  resize() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
    this.W = this.canvas.width;
    this.H = this.canvas.height;

    const totalLaneWidth = Math.min(400, this.W * 0.45);
    const laneWidth = totalLaneWidth / CONFIG.LANE_COUNT;
    const startX = (this.W - totalLaneWidth) / 2;

    this.lanes = [];
    for (let i = 0; i < CONFIG.LANE_COUNT; i++) {
      this.lanes.push({
        x: startX + laneWidth * i + laneWidth / 2,
        width: laneWidth,
        left: startX + laneWidth * i,
      });
    }
    this.laneLeft = startX;
    this.laneRight = startX + totalLaneWidth;
    this.strikeY = this.H * CONFIG.HIT_Y;
  }

  preloadAudio() {
    this.audio = new Audio();
    this.audio.crossOrigin = 'anonymous';
    this.audio.preload = 'auto';
    this.audio.src = CONFIG.AUDIO_URL;

    this.audio.addEventListener('canplaythrough', () => {
      this.audioLoaded = true;
      console.log('Audio loaded and ready');
    });
    this.audio.addEventListener('error', (e) => {
      console.log('Audio not found — running in silent mode. Place combined.mp3 in audio/ folder.');
      this.audioLoaded = false;
    });
    // Trigger load
    this.audio.load();
  }

  bindEvents() {
    window.addEventListener('resize', () => this.resize());

    window.addEventListener('keydown', (e) => {
      if (this.state !== 'playing') return;
      const lane = CONFIG.LANE_KEYS.indexOf(e.key.toLowerCase());
      if (lane === -1) return;
      e.preventDefault();
      if (!this.keysDown[lane]) {
        this.keysDown[lane] = true;
        this.keyFlash[lane] = 1;
        this.checkHit(lane);
      }
    });

    window.addEventListener('keyup', (e) => {
      const lane = CONFIG.LANE_KEYS.indexOf(e.key.toLowerCase());
      if (lane === -1) return;
      this.keysDown[lane] = false;
    });

    document.getElementById('btn-easy').addEventListener('click', () => this.startGame('easy'));
    document.getElementById('btn-hard').addEventListener('click', () => this.startGame('hard'));
    document.getElementById('restart-btn').addEventListener('click', () => {
      document.getElementById('results-screen').style.display = 'none';
      document.getElementById('start-screen').style.display = 'flex';
    });
  }

  async startGame(difficulty) {
    this.difficulty = difficulty;
    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('difficulty-label').textContent = difficulty.toUpperCase();

    // Generate beatmap for selected difficulty
    this.beatmap = generateBeatmap(difficulty);
    this.totalNotes = this.beatmap.length;
    this.activeNotes = [];
    this.nextNoteIndex = 0;

    // Reset state
    this.score = 0;
    this.combo = 0;
    this.maxCombo = 0;
    this.multiplier = 1;
    this.rockMeter = CONFIG.ROCK_METER_START;
    this.stats = { perfect: 0, great: 0, good: 0, miss: 0 };
    this.particles = [];
    this.keysDown = {};
    this.keyFlash = [0, 0, 0, 0];

    // Try to play video
    try { this.video.play(); } catch(e) {}

    // Countdown
    await this.doCountdown();

    // Start audio
    if (this.audioLoaded) {
      this.audio.currentTime = 0;
      this.audio.volume = 0.7;
      try { await this.audio.play(); } catch(e) { console.log('Audio play blocked'); }
    }

    // Start game loop
    this.state = 'playing';
    this.songStartTime = performance.now();
    this.lastFrameTime = performance.now();
    this.gameLoop();
  }

  async doCountdown() {
    const el = document.getElementById('countdown');
    const counts = ['3', '2', '1', 'GO!'];
    for (let i = 0; i < counts.length; i++) {
      el.textContent = counts[i];
      el.style.opacity = '1';
      el.style.transform = 'translate(-50%, -50%) scale(1.5)';
      el.style.transition = 'none';
      await new Promise(r => setTimeout(r, 50));
      el.style.transition = 'all 0.5s ease-out';
      el.style.transform = 'translate(-50%, -50%) scale(1)';
      el.style.opacity = '0.8';
      await new Promise(r => setTimeout(r, 500));
      el.style.opacity = '0';
      await new Promise(r => setTimeout(r, i < 3 ? 200 : 100));
    }
  }

  getSongTime() {
    return performance.now() - this.songStartTime;
  }

  get lookAheadMs() {
    const pixelsToTravel = this.strikeY;
    const framesNeeded = pixelsToTravel / CONFIG.SCROLL_SPEED;
    return framesNeeded * (1000 / 60);
  }

  checkHit(lane) {
    const songTime = this.getSongTime();
    let bestNote = null;
    let bestDelta = Infinity;

    for (const note of this.activeNotes) {
      if (note.lane !== lane || note.hit || note.missed) continue;
      const delta = Math.abs(songTime - note.time);
      if (delta < bestDelta) {
        bestDelta = delta;
        bestNote = note;
      }
    }

    if (bestNote && bestDelta <= CONFIG.GOOD_WINDOW) {
      bestNote.hit = true;
      bestNote.hitTime = performance.now();
      let rating, points;

      if (bestDelta <= CONFIG.PERFECT_WINDOW) {
        rating = 'PERFECT'; points = CONFIG.PERFECT_SCORE; this.stats.perfect++;
      } else if (bestDelta <= CONFIG.GREAT_WINDOW) {
        rating = 'GREAT'; points = CONFIG.GREAT_SCORE; this.stats.great++;
      } else {
        rating = 'GOOD'; points = CONFIG.GOOD_SCORE; this.stats.good++;
      }

      this.combo++;
      if (this.combo > this.maxCombo) this.maxCombo = this.combo;
      this.updateMultiplier();
      this.score += points * this.multiplier;
      this.rockMeter = Math.min(CONFIG.ROCK_METER_MAX, this.rockMeter + CONFIG.ROCK_HIT_GAIN);

      this.showHitFeedback(rating, lane);
      this.spawnHitParticles(lane, rating);
    }
  }

  onMiss(note) {
    note.missed = true;
    this.stats.miss++;
    this.combo = 0;
    this.multiplier = 1;
    this.rockMeter = Math.max(0, this.rockMeter - CONFIG.ROCK_MISS_PENALTY);
    this.showHitFeedback('MISS', note.lane);
  }

  updateMultiplier() {
    let mult = 1;
    for (let i = 0; i < CONFIG.MULT_THRESHOLDS.length; i++) {
      if (this.combo >= CONFIG.MULT_THRESHOLDS[i]) mult = i + 2;
    }
    this.multiplier = Math.min(mult, CONFIG.MAX_MULTIPLIER);
  }

  showHitFeedback(rating, lane) {
    const fb = document.getElementById('hit-feedback');
    fb.textContent = rating;
    fb.className = rating.toLowerCase();
    fb.style.opacity = '1';
    fb.style.left = this.lanes[lane].x + 'px';
    fb.style.top = (this.strikeY - 60) + 'px';
    fb.style.transform = 'translate(-50%, -50%) scale(1.2)';
    fb.style.transition = 'none';

    requestAnimationFrame(() => {
      fb.style.transition = 'all 0.4s ease-out';
      fb.style.transform = 'translate(-50%, -80%) scale(1)';
      fb.style.opacity = '0';
    });
  }

  spawnHitParticles(lane, rating) {
    const x = this.lanes[lane].x;
    const y = this.strikeY;
    const color = CONFIG.LANE_COLORS[lane];
    const count = rating === 'PERFECT' ? 18 : rating === 'GREAT' ? 12 : 8;
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count + (Math.random() - 0.5) * 0.5;
      const speed = 2 + Math.random() * 5;
      this.particles.push({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed - 2,
        life: 1,
        decay: 0.015 + Math.random() * 0.02,
        size: 2 + Math.random() * 4,
        color,
      });
    }
  }

  // ============================================================
  // GAME LOOP
  // ============================================================
  gameLoop() {
    if (this.state !== 'playing') return;

    const now = performance.now();
    this.lastFrameTime = now;
    const songTime = this.getSongTime();

    // End check
    if (songTime > CONFIG.SONG_DURATION * 1000 + 2000) {
      this.endGame();
      return;
    }

    // Spawn notes within look-ahead
    while (this.nextNoteIndex < this.beatmap.length) {
      const note = this.beatmap[this.nextNoteIndex];
      if (note.time <= songTime + this.lookAheadMs) {
        this.activeNotes.push({ ...note, hit: false, missed: false, hitTime: 0, y: 0 });
        this.nextNoteIndex++;
      } else break;
    }

    // Update note positions
    for (const note of this.activeNotes) {
      const timeUntilHit = note.time - songTime;
      const progressRatio = 1 - (timeUntilHit / this.lookAheadMs);
      note.y = progressRatio * this.strikeY;

      if (!note.hit && !note.missed && songTime - note.time > CONFIG.GOOD_WINDOW) {
        this.onMiss(note);
      }
    }

    // Remove dead notes
    this.activeNotes = this.activeNotes.filter(n => {
      if (n.hit) return (now - n.hitTime) < 300;
      if (n.missed) return n.y < this.H + 50;
      return true;
    });

    // Update particles
    this.particles = this.particles.filter(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.12;
      p.life -= p.decay;
      return p.life > 0;
    });

    // Key flash decay
    for (let i = 0; i < 4; i++) this.keyFlash[i] *= 0.85;

    // Video effects based on rock meter
    if (this.rockMeter > 70) {
      this.video.style.filter = 'saturate(1.4) brightness(1.15)';
      this.video.style.opacity = '0.5';
    } else if (this.rockMeter > 40) {
      this.video.style.filter = 'none';
      this.video.style.opacity = '0.4';
    } else if (this.rockMeter > 15) {
      this.video.style.filter = 'grayscale(50%) brightness(0.6)';
      this.video.style.opacity = '0.25';
    } else {
      this.video.style.filter = 'grayscale(80%) brightness(0.3) sepia(30%)';
      this.video.style.opacity = '0.15';
    }

    this.render(songTime);
    this.updateHUD(songTime);
    requestAnimationFrame(() => this.gameLoop());
  }

  // ============================================================
  // RENDERING
  // ============================================================
  render(songTime) {
    const ctx = this.ctx;
    const W = this.W;
    const H = this.H;
    ctx.clearRect(0, 0, W, H);

    // Lane backgrounds
    for (let i = 0; i < CONFIG.LANE_COUNT; i++) {
      const lane = this.lanes[i];

      // Alternating lane shade
      ctx.fillStyle = i % 2 === 0 ? 'rgba(255,255,255,0.02)' : 'rgba(255,255,255,0.04)';
      ctx.fillRect(lane.left, 0, lane.width, H);

      // Lane dividers
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(lane.left, 0);
      ctx.lineTo(lane.left, H);
      ctx.stroke();

      // Key press glow
      if (this.keyFlash[i] > 0.05) {
        const grad = ctx.createLinearGradient(lane.left, this.strikeY, lane.left, this.strikeY - 250);
        grad.addColorStop(0, CONFIG.LANE_GLOW[i] + (this.keyFlash[i] * 0.4).toFixed(2) + ')');
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.fillRect(lane.left, this.strikeY - 250, lane.width, 250);
      }
    }

    // Outer lane borders
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(this.laneLeft, 0);
    ctx.lineTo(this.laneLeft, H);
    ctx.moveTo(this.laneRight, 0);
    ctx.lineTo(this.laneRight, H);
    ctx.stroke();

    // Strike zone
    const szGrad = ctx.createLinearGradient(this.laneLeft, this.strikeY - 3, this.laneLeft, this.strikeY + 3);
    szGrad.addColorStop(0, 'rgba(255,255,255,0.0)');
    szGrad.addColorStop(0.5, 'rgba(255,255,255,0.35)');
    szGrad.addColorStop(1, 'rgba(255,255,255,0.0)');
    ctx.fillStyle = szGrad;
    ctx.fillRect(this.laneLeft, this.strikeY - 3, this.laneRight - this.laneLeft, 6);

    // Receptors
    for (let i = 0; i < CONFIG.LANE_COUNT; i++) {
      const lane = this.lanes[i];
      const pressed = this.keysDown[i];

      // Outer ring
      ctx.beginPath();
      ctx.arc(lane.x, this.strikeY, CONFIG.NOTE_RADIUS + 4, 0, Math.PI * 2);
      ctx.strokeStyle = pressed ? CONFIG.LANE_COLORS[i] : 'rgba(255,255,255,0.15)';
      ctx.lineWidth = pressed ? 3 : 1.5;
      ctx.stroke();

      // Inner glow when pressed
      if (pressed) {
        ctx.beginPath();
        ctx.arc(lane.x, this.strikeY, CONFIG.NOTE_RADIUS + 2, 0, Math.PI * 2);
        ctx.fillStyle = CONFIG.LANE_GLOW[i] + '0.25)';
        ctx.fill();
      }

      // Key label
      ctx.font = '14px "Press Start 2P"';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = pressed ? CONFIG.LANE_COLORS[i] : 'rgba(255,255,255,0.25)';
      ctx.fillText(CONFIG.LANE_KEYS[i].toUpperCase(), lane.x, this.strikeY);
    }

    // Notes
    for (const note of this.activeNotes) {
      const lane = this.lanes[note.lane];
      const color = CONFIG.LANE_COLORS[note.lane];

      if (note.hit) {
        // Hit note — expanding ring animation
        const elapsed = performance.now() - note.hitTime;
        const progress = elapsed / 300;
        const radius = CONFIG.NOTE_RADIUS + progress * 30;
        const alpha = 1 - progress;
        ctx.beginPath();
        ctx.arc(lane.x, this.strikeY, radius, 0, Math.PI * 2);
        ctx.strokeStyle = color;
        ctx.globalAlpha = alpha * 0.6;
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.globalAlpha = 1;
        continue;
      }

      const alpha = note.missed ? 0.25 : 1;

      // Glow
      if (!note.missed) {
        ctx.beginPath();
        ctx.arc(lane.x, note.y, CONFIG.NOTE_RADIUS + 10, 0, Math.PI * 2);
        const glow = ctx.createRadialGradient(lane.x, note.y, 0, lane.x, note.y, CONFIG.NOTE_RADIUS + 10);
        glow.addColorStop(0, CONFIG.LANE_GLOW[note.lane] + '0.35)');
        glow.addColorStop(1, 'transparent');
        ctx.fillStyle = glow;
        ctx.fill();
      }

      // Note body
      ctx.beginPath();
      ctx.arc(lane.x, note.y, CONFIG.NOTE_RADIUS, 0, Math.PI * 2);
      ctx.fillStyle = note.missed ? 'rgba(80,80,80,0.3)' : color;
      ctx.globalAlpha = alpha;
      ctx.fill();
      ctx.globalAlpha = 1;

      // Border
      ctx.strokeStyle = note.missed ? 'rgba(255,0,0,0.2)' : 'rgba(255,255,255,0.5)';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Inner shine
      if (!note.missed) {
        ctx.beginPath();
        ctx.arc(lane.x - 5, note.y - 5, CONFIG.NOTE_RADIUS * 0.35, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fill();
      }
    }

    // Particles
    for (const p of this.particles) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
      ctx.fillStyle = p.color;
      ctx.globalAlpha = p.life * 0.8;
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Lane names at bottom
    ctx.font = '11px "Permanent Marker"';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    for (let i = 0; i < CONFIG.LANE_COUNT; i++) {
      ctx.fillStyle = CONFIG.LANE_COLORS[i];
      ctx.globalAlpha = 0.4;
      ctx.fillText(CONFIG.LANE_NAMES[i], this.lanes[i].x, this.strikeY + 32);
    }
    ctx.globalAlpha = 1;

    // Beat pulse (subtle screen flash on each beat at high combo)
    if (this.combo > 20) {
      const beatPhase = (songTime % SONG.msPerBeat) / SONG.msPerBeat;
      if (beatPhase < 0.08) {
        const intensity = 0.04 * (1 - beatPhase / 0.08) * Math.min(this.combo / 50, 1);
        ctx.fillStyle = `rgba(0,255,255,${intensity})`;
        ctx.fillRect(0, 0, W, H);
      }
    }
  }

  updateHUD(songTime) {
    document.getElementById('score-value').textContent = this.score.toLocaleString();

    const comboEl = document.getElementById('combo-display');
    if (this.combo > 1) {
      comboEl.classList.add('active');
      document.getElementById('combo-count').textContent = this.combo;
    } else {
      comboEl.classList.remove('active');
    }

    document.getElementById('multiplier-display').textContent =
      this.multiplier > 1 ? this.multiplier + 'x' : '';

    const progress = Math.max(0, Math.min(100, (songTime / (CONFIG.SONG_DURATION * 1000)) * 100));
    document.getElementById('progress-bar').style.width = progress + '%';

    const rm = document.getElementById('rock-meter');
    rm.style.height = this.rockMeter + '%';
    if (this.rockMeter > 70) rm.style.background = 'linear-gradient(0deg, #0f0, #0ff)';
    else if (this.rockMeter > 40) rm.style.background = 'linear-gradient(0deg, #ff0, #0f0)';
    else rm.style.background = 'linear-gradient(0deg, #f00, #ff0)';
  }

  endGame() {
    this.state = 'results';
    if (this.audio) { this.audio.pause(); this.audio.currentTime = 0; }

    const totalHits = this.stats.perfect + this.stats.great + this.stats.good;
    const totalJudged = totalHits + this.stats.miss;
    const accuracy = totalJudged > 0
      ? ((this.stats.perfect * 100 + this.stats.great * 80 + this.stats.good * 50) / (totalJudged * 100) * 100)
      : 0;

    let grade, gradeClass;
    if (accuracy >= 95) { grade = 'S'; gradeClass = 'grade-s'; }
    else if (accuracy >= 85) { grade = 'A'; gradeClass = 'grade-a'; }
    else if (accuracy >= 70) { grade = 'B'; gradeClass = 'grade-b'; }
    else if (accuracy >= 50) { grade = 'C'; gradeClass = 'grade-c'; }
    else { grade = 'F'; gradeClass = 'grade-f'; }

    document.getElementById('results-screen').style.display = 'flex';
    document.getElementById('result-grade').textContent = grade;
    document.getElementById('result-grade').className = 'grade ' + gradeClass;
    document.getElementById('result-score').textContent = this.score.toLocaleString();
    document.getElementById('result-combo').textContent = this.maxCombo;
    document.getElementById('result-perfect').textContent = this.stats.perfect;
    document.getElementById('result-great').textContent = this.stats.great;
    document.getElementById('result-good').textContent = this.stats.good;
    document.getElementById('result-miss').textContent = this.stats.miss;
    document.getElementById('result-accuracy').textContent = accuracy.toFixed(1) + '%';
  }
}

// Init
const game = new JURNRhythmGame();
</script>
</body>
</html>