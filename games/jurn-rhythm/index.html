<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>JURN - Get Ready for Get Happy</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Permanent+Marker&family=Press+Start+2P&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #000;
    overflow: hidden;
    font-family: 'Press Start 2P', monospace;
    color: #fff;
    user-select: none;
  }

  #game-container {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
  }

  /* Video backdrop */
  #video-backdrop {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    object-fit: cover;
    z-index: 0;
    opacity: 0.4;
    transition: filter 0.5s ease, opacity 0.5s ease;
  }

  /* Dark overlay on top of video */
  #video-overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: linear-gradient(180deg, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0.4) 40%, rgba(0,0,0,0.8) 100%);
    z-index: 1;
  }

  /* Game canvas */
  #game-canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 2;
  }

  /* HUD */
  #hud {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 3;
    pointer-events: none;
  }

  #score-display {
    position: absolute;
    top: 20px; right: 30px;
    text-align: right;
  }
  #score-display .score-label { font-size: 10px; color: #888; letter-spacing: 2px; }
  #score-display .score-value { font-size: 28px; color: #0ff; text-shadow: 0 0 20px #0ff; }

  #combo-display {
    position: absolute;
    top: 90px; right: 30px;
    text-align: right;
    opacity: 0;
    transition: opacity 0.2s;
  }
  #combo-display.active { opacity: 1; }
  #combo-display .combo-count { font-size: 36px; color: #f0f; text-shadow: 0 0 30px #f0f; }
  #combo-display .combo-label { font-size: 10px; color: #c0c; letter-spacing: 2px; }

  #multiplier-display {
    position: absolute;
    top: 160px; right: 30px;
    font-size: 14px;
    color: #ff0;
    text-shadow: 0 0 10px #ff0;
  }

  /* Song progress bar */
  #progress-bar-container {
    position: absolute;
    top: 10px; left: 30px; right: 200px;
    height: 4px;
    background: rgba(255,255,255,0.1);
    border-radius: 2px;
  }
  #progress-bar {
    height: 100%;
    background: linear-gradient(90deg, #0ff, #f0f);
    border-radius: 2px;
    width: 0%;
    transition: width 0.5s linear;
  }

  /* Hit feedback */
  #hit-feedback {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    opacity: 0;
    transition: opacity 0.1s;
    pointer-events: none;
    z-index: 10;
  }
  #hit-feedback.perfect { color: #0ff; text-shadow: 0 0 30px #0ff; }
  #hit-feedback.great { color: #0f0; text-shadow: 0 0 20px #0f0; }
  #hit-feedback.good { color: #ff0; text-shadow: 0 0 15px #ff0; }
  #hit-feedback.miss { color: #f00; text-shadow: 0 0 15px #f00; }

  /* Rock meter */
  #rock-meter-container {
    position: absolute;
    left: 20px;
    top: 50%;
    transform: translateY(-50%);
    width: 20px;
    height: 300px;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 10px;
    overflow: hidden;
  }
  #rock-meter {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 50%;
    background: linear-gradient(0deg, #0f0, #ff0, #f00);
    border-radius: 0 0 10px 10px;
    transition: height 0.3s ease;
  }
  #rock-meter-label {
    position: absolute;
    left: 15px;
    top: 50%;
    transform: translateY(-50%) rotate(-90deg);
    transform-origin: left center;
    font-size: 8px;
    color: #666;
    letter-spacing: 3px;
    white-space: nowrap;
  }

  /* Lane labels at bottom */
  .lane-label {
    position: absolute;
    bottom: 45px;
    font-size: 14px;
    font-family: 'Permanent Marker', cursive;
    letter-spacing: 1px;
    opacity: 0.6;
    text-align: center;
    width: 80px;
  }

  /* Start screen */
  #start-screen {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 100;
    background: rgba(0,0,0,0.95);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 20px;
  }
  #start-screen h1 {
    font-family: 'Permanent Marker', cursive;
    font-size: 64px;
    color: #0ff;
    text-shadow: 0 0 40px #0ff, 0 0 80px #0ff;
    letter-spacing: 10px;
  }
  #start-screen h2 {
    font-family: 'Permanent Marker', cursive;
    font-size: 24px;
    color: #f0f;
    text-shadow: 0 0 20px #f0f;
  }
  #start-screen .song-title {
    font-family: 'Press Start 2P', monospace;
    font-size: 12px;
    color: #ff0;
    margin-top: 20px;
  }
  #start-screen .instructions {
    font-size: 10px;
    color: #888;
    line-height: 2;
    text-align: center;
    margin-top: 30px;
  }
  #start-screen .instructions span { color: #0ff; }
  #start-screen .start-btn {
    margin-top: 30px;
    font-family: 'Press Start 2P', monospace;
    font-size: 14px;
    color: #000;
    background: #0ff;
    border: none;
    padding: 15px 40px;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 2px;
    animation: pulse 1.5s ease-in-out infinite;
    pointer-events: auto;
  }
  @keyframes pulse {
    0%, 100% { box-shadow: 0 0 20px #0ff; }
    50% { box-shadow: 0 0 40px #0ff, 0 0 60px #0ff; }
  }

  /* Results screen */
  #results-screen {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 100;
    background: rgba(0,0,0,0.95);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 15px;
  }
  #results-screen h1 {
    font-family: 'Permanent Marker', cursive;
    font-size: 48px;
    color: #0ff;
    text-shadow: 0 0 30px #0ff;
  }
  #results-screen .stat {
    font-size: 12px;
    color: #ccc;
    line-height: 2.5;
  }
  #results-screen .stat .val { color: #0ff; }
  #results-screen .grade {
    font-size: 72px;
    font-family: 'Permanent Marker', cursive;
    margin: 10px 0;
  }
  .grade-s { color: #0ff; text-shadow: 0 0 40px #0ff, 0 0 80px #0ff; }
  .grade-a { color: #0f0; text-shadow: 0 0 30px #0f0; }
  .grade-b { color: #ff0; text-shadow: 0 0 20px #ff0; }
  .grade-c { color: #f80; text-shadow: 0 0 20px #f80; }
  .grade-f { color: #f00; text-shadow: 0 0 20px #f00; }

  /* Key press flash */
  .key-flash {
    position: absolute;
    bottom: 0;
    height: 100%;
    opacity: 0;
    pointer-events: none;
    z-index: 1;
  }

  /* Particle container */
  #particles {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 4;
    pointer-events: none;
  }
</style>
</head>
<body>
<div id="game-container">
  <!-- Video backdrop -->
  <video id="video-backdrop" autoplay loop muted playsinline></video>
  <div id="video-overlay"></div>

  <!-- Game canvas -->
  <canvas id="game-canvas"></canvas>

  <!-- HUD -->
  <div id="hud">
    <div id="progress-bar-container"><div id="progress-bar"></div></div>
    <div id="score-display">
      <div class="score-label">SCORE</div>
      <div class="score-value" id="score-value">0</div>
    </div>
    <div id="combo-display">
      <div class="combo-count" id="combo-count">0</div>
      <div class="combo-label">COMBO</div>
    </div>
    <div id="multiplier-display" id="multiplier-value"></div>
    <div id="rock-meter-container">
      <div id="rock-meter"></div>
    </div>
    <div id="hit-feedback"></div>
  </div>

  <!-- Particles -->
  <div id="particles"></div>

  <!-- Start screen -->
  <div id="start-screen">
    <h1>JURN</h1>
    <h2>RHYTHM ATTACK</h2>
    <div class="song-title">♫ GET READY FOR GET HAPPY ♫</div>
    <div class="instructions">
      <span>A</span> Bass (Taz) &nbsp; | &nbsp;
      <span>S</span> Drums (Bonecrush) &nbsp; | &nbsp;
      <span>D</span> Guitar (Riff-Rot) &nbsp; | &nbsp;
      <span>F</span> Vocals (Vox)<br><br>
      Hit the keys when notes reach the strike zone
    </div>
    <button class="start-btn" id="start-btn">PRESS TO ROCK</button>
  </div>

  <!-- Results screen -->
  <div id="results-screen">
    <h1>SONG COMPLETE</h1>
    <div class="grade" id="result-grade"></div>
    <div class="stat">SCORE: <span class="val" id="result-score"></span></div>
    <div class="stat">MAX COMBO: <span class="val" id="result-combo"></span></div>
    <div class="stat">PERFECT: <span class="val" id="result-perfect"></span></div>
    <div class="stat">GREAT: <span class="val" id="result-great"></span></div>
    <div class="stat">GOOD: <span class="val" id="result-good"></span></div>
    <div class="stat">MISS: <span class="val" id="result-miss"></span></div>
    <div class="stat">ACCURACY: <span class="val" id="result-accuracy"></span></div>
    <button class="start-btn" id="restart-btn" style="margin-top:20px">PLAY AGAIN</button>
  </div>
</div>

<script>
// ===== CONFIGURATION =====
const CONFIG = {
  BPM: 155,
  SONG_DURATION: 180, // seconds
  SCROLL_SPEED: 6, // pixels per frame (adjustable)
  LANE_COUNT: 4,
  LANE_KEYS: ['a', 's', 'd', 'f'],
  LANE_COLORS: ['#f0f', '#0ff', '#0f0', '#ff0'], // Bass, Drums, Guitar, Vocals
  LANE_GLOW: ['rgba(255,0,255,0.3)', 'rgba(0,255,255,0.3)', 'rgba(0,255,0,0.3)', 'rgba(255,255,0,0.3)'],
  LANE_NAMES: ['TAZ', 'CRUSH', 'RIFF', 'VOX'],
  HIT_Y: 0.88, // strike zone Y position (% of canvas height)
  NOTE_RADIUS: 22,
  // Timing windows (ms)
  PERFECT_WINDOW: 45,
  GREAT_WINDOW: 90,
  GOOD_WINDOW: 140,
  // Scoring
  PERFECT_SCORE: 300,
  GREAT_SCORE: 200,
  GOOD_SCORE: 100,
  // Multiplier thresholds
  MULT_THRESHOLDS: [10, 30, 60, 100],
  MAX_MULTIPLIER: 5,
  // Rock meter
  ROCK_METER_MAX: 100,
  ROCK_METER_START: 50,
  ROCK_HIT_GAIN: 2,
  ROCK_MISS_PENALTY: 8,
};

// ===== SONG STRUCTURE =====
// Song structure for "Get Ready for Get Happy" at 155 BPM, F Major
const SONG_STRUCTURE = {
  bpm: 155,
  beatsPerMeasure: 4,
  msPerBeat: 60000 / 155, // ~387ms
  sections: [
    { name: 'intro',       startMs: 0,     endMs: 13000,  type: 'instrumental' },
    { name: 'verse1',      startMs: 13000, endMs: 34000,  type: 'verse' },
    { name: 'chorus1',     startMs: 34000, endMs: 58000,  type: 'chorus' },
    { name: 'postChorus1', startMs: 58000, endMs: 83000,  type: 'post_chorus' },
    { name: 'break',       startMs: 83000, endMs: 91000,  type: 'instrumental' },
    { name: 'verse2',      startMs: 91000, endMs: 116000, type: 'verse' },
    { name: 'chorus2',     startMs: 116000,endMs: 130000, type: 'chorus' },
    { name: 'postChorus2', startMs: 130000,endMs: 150000, type: 'post_chorus' },
    { name: 'outro',       startMs: 150000,endMs: 180000, type: 'outro' },
  ]
};

// ===== BEATMAP GENERATOR =====
// Generates a procedural beatmap based on song structure and BPM.
// This creates a playable chart — later Bobby can replace with hand-charted beatmap.
function generateBeatmap() {
  const notes = [];
  const msPerBeat = SONG_STRUCTURE.msPerBeat;
  const msPerHalf = msPerBeat / 2;
  const msPerQuarter = msPerBeat / 4;

  for (const section of SONG_STRUCTURE.sections) {
    let t = section.startMs;
    const end = section.endMs;

    switch (section.type) {
      case 'instrumental':
        // Intro/break: drums + guitar on beat, bass on offbeats
        while (t < end) {
          // Beat 1: drums + guitar
          notes.push({ time: t, lane: 1 }); // drums
          notes.push({ time: t, lane: 2 }); // guitar
          // Beat 1.5: bass
          notes.push({ time: t + msPerHalf, lane: 0 }); // bass
          // Beat 2: drums
          notes.push({ time: t + msPerBeat, lane: 1 });
          // Beat 2.5: guitar
          notes.push({ time: t + msPerBeat + msPerHalf, lane: 2 });
          // Beat 3: drums + bass
          notes.push({ time: t + msPerBeat * 2, lane: 1 });
          notes.push({ time: t + msPerBeat * 2, lane: 0 });
          // Beat 4: guitar
          notes.push({ time: t + msPerBeat * 3, lane: 2 });
          // Beat 4.5: drums
          notes.push({ time: t + msPerBeat * 3 + msPerHalf, lane: 1 });
          t += msPerBeat * 4; // advance one measure
        }
        break;

      case 'verse':
        // Verse: vocals lead, sparse guitar/bass support, steady drums
        while (t < end) {
          // Vocals on beats 1 and 3
          notes.push({ time: t, lane: 3 }); // vocals
          notes.push({ time: t + msPerBeat * 2, lane: 3 }); // vocals
          // Drums steady on every beat
          notes.push({ time: t, lane: 1 });
          notes.push({ time: t + msPerBeat, lane: 1 });
          notes.push({ time: t + msPerBeat * 2, lane: 1 });
          notes.push({ time: t + msPerBeat * 3, lane: 1 });
          // Bass on beat 1 and 3
          notes.push({ time: t + msPerHalf, lane: 0 });
          notes.push({ time: t + msPerBeat * 2 + msPerHalf, lane: 0 });
          // Guitar accent on beat 2 and 4
          notes.push({ time: t + msPerBeat, lane: 2 });
          notes.push({ time: t + msPerBeat * 3, lane: 2 });
          t += msPerBeat * 4;
        }
        break;

      case 'chorus':
        // Chorus: all lanes active, dense patterns, power chords
        while (t < end) {
          // All four on beat 1
          notes.push({ time: t, lane: 0 });
          notes.push({ time: t, lane: 1 });
          notes.push({ time: t, lane: 2 });
          notes.push({ time: t, lane: 3 });
          // Guitar + drums eighth notes
          notes.push({ time: t + msPerHalf, lane: 1 });
          notes.push({ time: t + msPerHalf, lane: 2 });
          // Beat 2: vocals + bass
          notes.push({ time: t + msPerBeat, lane: 3 });
          notes.push({ time: t + msPerBeat, lane: 0 });
          notes.push({ time: t + msPerBeat, lane: 1 });
          // Offbeat guitar
          notes.push({ time: t + msPerBeat + msPerHalf, lane: 2 });
          // Beat 3: power hit
          notes.push({ time: t + msPerBeat * 2, lane: 0 });
          notes.push({ time: t + msPerBeat * 2, lane: 1 });
          notes.push({ time: t + msPerBeat * 2, lane: 2 });
          // Vocal flourish
          notes.push({ time: t + msPerBeat * 2 + msPerHalf, lane: 3 });
          // Beat 4: drums + guitar rapid
          notes.push({ time: t + msPerBeat * 3, lane: 1 });
          notes.push({ time: t + msPerBeat * 3, lane: 2 });
          notes.push({ time: t + msPerBeat * 3 + msPerHalf, lane: 0 });
          notes.push({ time: t + msPerBeat * 3 + msPerHalf, lane: 1 });
          t += msPerBeat * 4;
        }
        break;

      case 'post_chorus':
        // Post-chorus: driving energy, syncopated
        while (t < end) {
          // Syncopated bass and guitar
          notes.push({ time: t, lane: 0 });
          notes.push({ time: t, lane: 2 });
          notes.push({ time: t + msPerHalf, lane: 1 });
          notes.push({ time: t + msPerBeat, lane: 3 });
          notes.push({ time: t + msPerBeat, lane: 1 });
          notes.push({ time: t + msPerBeat + msPerHalf, lane: 0 });
          notes.push({ time: t + msPerBeat + msPerHalf, lane: 2 });
          notes.push({ time: t + msPerBeat * 2, lane: 1 });
          notes.push({ time: t + msPerBeat * 2 + msPerHalf, lane: 3 });
          notes.push({ time: t + msPerBeat * 3, lane: 0 });
          notes.push({ time: t + msPerBeat * 3, lane: 1 });
          notes.push({ time: t + msPerBeat * 3, lane: 2 });
          notes.push({ time: t + msPerBeat * 3 + msPerHalf, lane: 1 });
          t += msPerBeat * 4;
        }
        break;

      case 'outro':
        // Outro: building intensity, then final hit
        while (t < end - 3000) {
          // Dense all-lane patterns
          notes.push({ time: t, lane: 0 });
          notes.push({ time: t, lane: 1 });
          notes.push({ time: t + msPerHalf, lane: 2 });
          notes.push({ time: t + msPerHalf, lane: 3 });
          notes.push({ time: t + msPerBeat, lane: 0 });
          notes.push({ time: t + msPerBeat, lane: 1 });
          notes.push({ time: t + msPerBeat + msPerHalf, lane: 2 });
          notes.push({ time: t + msPerBeat + msPerHalf, lane: 3 });
          notes.push({ time: t + msPerBeat * 2, lane: 0 });
          notes.push({ time: t + msPerBeat * 2, lane: 1 });
          notes.push({ time: t + msPerBeat * 2, lane: 2 });
          notes.push({ time: t + msPerBeat * 2, lane: 3 });
          notes.push({ time: t + msPerBeat * 3, lane: 1 });
          notes.push({ time: t + msPerBeat * 3 + msPerHalf, lane: 0 });
          notes.push({ time: t + msPerBeat * 3 + msPerHalf, lane: 2 });
          t += msPerBeat * 4;
        }
        // Final chord — all lanes
        notes.push({ time: end - 2000, lane: 0 });
        notes.push({ time: end - 2000, lane: 1 });
        notes.push({ time: end - 2000, lane: 2 });
        notes.push({ time: end - 2000, lane: 3 });
        break;
    }
  }

  // Sort by time
  notes.sort((a, b) => a.time - b.time);
  return notes;
}

// ===== GAME ENGINE =====
class JURNRhythmGame {
  constructor() {
    this.canvas = document.getElementById('game-canvas');
    this.ctx = this.canvas.getContext('2d');
    this.video = document.getElementById('video-backdrop');
    this.audio = null;
    this.audioCtx = null;

    // State
    this.state = 'start'; // start, playing, paused, results
    this.score = 0;
    this.combo = 0;
    this.maxCombo = 0;
    this.multiplier = 1;
    this.rockMeter = CONFIG.ROCK_METER_START;
    this.stats = { perfect: 0, great: 0, good: 0, miss: 0 };
    this.totalNotes = 0;

    // Notes
    this.beatmap = [];
    this.activeNotes = []; // notes currently on screen
    this.nextNoteIndex = 0;

    // Input
    this.keysDown = {};
    this.keyFlash = [0, 0, 0, 0]; // flash intensity per lane

    // Timing
    this.songStartTime = 0;
    this.songPosition = 0; // ms
    this.lastFrameTime = 0;

    // Visual
    this.particles = [];
    this.hitEffects = [];
    this.screenShake = 0;

    this.resize();
    this.bindEvents();
  }

  resize() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
    this.W = this.canvas.width;
    this.H = this.canvas.height;

    // Lane geometry
    const totalLaneWidth = Math.min(400, this.W * 0.45);
    const laneWidth = totalLaneWidth / CONFIG.LANE_COUNT;
    const startX = (this.W - totalLaneWidth) / 2;

    this.lanes = [];
    for (let i = 0; i < CONFIG.LANE_COUNT; i++) {
      this.lanes.push({
        x: startX + laneWidth * i + laneWidth / 2,
        width: laneWidth,
        left: startX + laneWidth * i,
      });
    }
    this.laneLeft = startX;
    this.laneRight = startX + totalLaneWidth;
    this.strikeY = this.H * CONFIG.HIT_Y;
  }

  bindEvents() {
    window.addEventListener('resize', () => this.resize());

    window.addEventListener('keydown', (e) => {
      if (this.state !== 'playing') return;
      const lane = CONFIG.LANE_KEYS.indexOf(e.key.toLowerCase());
      if (lane === -1) return;
      e.preventDefault();
      if (!this.keysDown[lane]) {
        this.keysDown[lane] = true;
        this.keyFlash[lane] = 1;
        this.checkHit(lane);
      }
    });

    window.addEventListener('keyup', (e) => {
      const lane = CONFIG.LANE_KEYS.indexOf(e.key.toLowerCase());
      if (lane === -1) return;
      this.keysDown[lane] = false;
    });

    document.getElementById('start-btn').addEventListener('click', () => this.startGame());
    document.getElementById('restart-btn').addEventListener('click', () => {
      document.getElementById('results-screen').style.display = 'none';
      document.getElementById('start-screen').style.display = 'flex';
    });
  }

  async startGame() {
    document.getElementById('start-screen').style.display = 'none';

    // Generate beatmap
    this.beatmap = generateBeatmap();
    this.totalNotes = this.beatmap.length;
    this.activeNotes = [];
    this.nextNoteIndex = 0;

    // Reset state
    this.score = 0;
    this.combo = 0;
    this.maxCombo = 0;
    this.multiplier = 1;
    this.rockMeter = CONFIG.ROCK_METER_START;
    this.stats = { perfect: 0, great: 0, good: 0, miss: 0 };
    this.particles = [];
    this.hitEffects = [];

    // Load audio
    // Use the audio element approach for simplicity
    if (!this.audio) {
      this.audio = new Audio();
      this.audio.crossOrigin = 'anonymous';
      // The song URL will be set when assets are loaded
      // For now we use a placeholder approach - the game works visually without audio
    }

    // Try to play video
    try {
      this.video.play();
    } catch(e) {}

    // Start game loop
    this.state = 'playing';
    this.songStartTime = performance.now() + 2000; // 2 second lead-in
    this.lastFrameTime = performance.now();
    this.gameLoop();
  }

  getSongTime() {
    return performance.now() - this.songStartTime;
  }

  // How far ahead (in ms) to spawn notes before they reach the strike zone
  get lookAheadMs() {
    const pixelsToTravel = this.strikeY;
    const framesNeeded = pixelsToTravel / CONFIG.SCROLL_SPEED;
    return framesNeeded * (1000 / 60); // assuming 60fps
  }

  checkHit(lane) {
    const songTime = this.getSongTime();
    let bestNote = null;
    let bestDelta = Infinity;

    for (const note of this.activeNotes) {
      if (note.lane !== lane || note.hit || note.missed) continue;
      const delta = Math.abs(songTime - note.time);
      if (delta < bestDelta) {
        bestDelta = delta;
        bestNote = note;
      }
    }

    if (bestNote && bestDelta <= CONFIG.GOOD_WINDOW) {
      bestNote.hit = true;
      let rating, points;

      if (bestDelta <= CONFIG.PERFECT_WINDOW) {
        rating = 'PERFECT';
        points = CONFIG.PERFECT_SCORE;
        this.stats.perfect++;
      } else if (bestDelta <= CONFIG.GREAT_WINDOW) {
        rating = 'GREAT';
        points = CONFIG.GREAT_SCORE;
        this.stats.great++;
      } else {
        rating = 'GOOD';
        points = CONFIG.GOOD_SCORE;
        this.stats.good++;
      }

      this.combo++;
      if (this.combo > this.maxCombo) this.maxCombo = this.combo;
      this.updateMultiplier();
      this.score += points * this.multiplier;
      this.rockMeter = Math.min(CONFIG.ROCK_METER_MAX, this.rockMeter + CONFIG.ROCK_HIT_GAIN);

      this.showHitFeedback(rating, lane);
      this.spawnHitParticles(lane);
      this.hitEffects.push({ lane, time: performance.now(), type: rating });
    }
  }

  onMiss(note) {
    note.missed = true;
    this.stats.miss++;
    this.combo = 0;
    this.multiplier = 1;
    this.rockMeter = Math.max(0, this.rockMeter - CONFIG.ROCK_MISS_PENALTY);
    this.showHitFeedback('MISS', note.lane);

    // Video desaturation effect on miss
    if (this.rockMeter < 30) {
      this.video.style.filter = 'grayscale(70%) brightness(0.5)';
      this.video.style.opacity = '0.2';
    }
  }

  updateMultiplier() {
    let mult = 1;
    for (let i = 0; i < CONFIG.MULT_THRESHOLDS.length; i++) {
      if (this.combo >= CONFIG.MULT_THRESHOLDS[i]) mult = i + 2;
    }
    this.multiplier = Math.min(mult, CONFIG.MAX_MULTIPLIER);
  }

  showHitFeedback(rating, lane) {
    const fb = document.getElementById('hit-feedback');
    fb.textContent = rating;
    fb.className = '';
    fb.classList.add(rating.toLowerCase());
    fb.style.opacity = '1';
    fb.style.left = this.lanes[lane].x + 'px';
    fb.style.top = (this.strikeY - 60) + 'px';
    fb.style.transform = 'translate(-50%, -50%)';
    setTimeout(() => { fb.style.opacity = '0'; }, 400);
  }

  spawnHitParticles(lane) {
    const x = this.lanes[lane].x;
    const y = this.strikeY;
    const color = CONFIG.LANE_COLORS[lane];
    for (let i = 0; i < 12; i++) {
      this.particles.push({
        x, y,
        vx: (Math.random() - 0.5) * 8,
        vy: -Math.random() * 6 - 2,
        life: 1,
        decay: 0.02 + Math.random() * 0.02,
        size: 2 + Math.random() * 4,
        color,
      });
    }
  }

  // ===== RENDERING =====
  gameLoop() {
    if (this.state !== 'playing') return;

    const now = performance.now();
    const dt = now - this.lastFrameTime;
    this.lastFrameTime = now;

    const songTime = this.getSongTime();

    // Check if song is over
    if (songTime > CONFIG.SONG_DURATION * 1000 + 3000) {
      this.endGame();
      return;
    }

    // Spawn notes that are within look-ahead window
    while (this.nextNoteIndex < this.beatmap.length) {
      const note = this.beatmap[this.nextNoteIndex];
      if (note.time <= songTime + this.lookAheadMs) {
        this.activeNotes.push({
          ...note,
          hit: false,
          missed: false,
          y: 0, // will be calculated
        });
        this.nextNoteIndex++;
      } else break;
    }

    // Update active notes positions
    for (const note of this.activeNotes) {
      const timeUntilHit = note.time - songTime;
      const progressRatio = 1 - (timeUntilHit / this.lookAheadMs);
      note.y = progressRatio * this.strikeY;

      // Check for miss (note passed strike zone)
      if (!note.hit && !note.missed && songTime - note.time > CONFIG.GOOD_WINDOW) {
        this.onMiss(note);
      }
    }

    // Remove dead notes
    this.activeNotes = this.activeNotes.filter(n => {
      if (n.hit) return n.y < this.strikeY + 100;
      if (n.missed) return n.y < this.H + 50;
      return true;
    });

    // Update particles
    this.particles = this.particles.filter(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.15;
      p.life -= p.decay;
      return p.life > 0;
    });

    // Update key flash decay
    for (let i = 0; i < 4; i++) {
      this.keyFlash[i] *= 0.85;
    }

    // Update video effects based on rock meter
    if (this.rockMeter > 70) {
      this.video.style.filter = 'saturate(1.3) brightness(1.1)';
      this.video.style.opacity = '0.5';
    } else if (this.rockMeter > 40) {
      this.video.style.filter = 'none';
      this.video.style.opacity = '0.4';
    } else {
      this.video.style.filter = 'grayscale(50%) brightness(0.6)';
      this.video.style.opacity = '0.25';
    }

    // Screen shake decay
    this.screenShake *= 0.9;

    this.render(songTime);
    this.updateHUD(songTime);

    requestAnimationFrame(() => this.gameLoop());
  }

  render(songTime) {
    const ctx = this.ctx;
    const W = this.W;
    const H = this.H;

    ctx.clearRect(0, 0, W, H);

    // Apply screen shake
    ctx.save();
    if (this.screenShake > 0.5) {
      ctx.translate(
        (Math.random() - 0.5) * this.screenShake * 2,
        (Math.random() - 0.5) * this.screenShake * 2
      );
    }

    // Draw lane backgrounds
    for (let i = 0; i < CONFIG.LANE_COUNT; i++) {
      const lane = this.lanes[i];
      // Lane stripe
      ctx.fillStyle = `rgba(255,255,255,0.03)`;
      ctx.fillRect(lane.left, 0, lane.width, H);

      // Lane dividers
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(lane.left, 0);
      ctx.lineTo(lane.left, H);
      ctx.stroke();

      // Key press flash
      if (this.keyFlash[i] > 0.05) {
        const grad = ctx.createLinearGradient(lane.left, this.strikeY, lane.left, this.strikeY - 200);
        grad.addColorStop(0, CONFIG.LANE_GLOW[i].replace('0.3', (this.keyFlash[i] * 0.5).toFixed(2)));
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.fillRect(lane.left, this.strikeY - 200, lane.width, 200);
      }
    }

    // Outer lane borders
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(this.laneLeft, 0);
    ctx.lineTo(this.laneLeft, H);
    ctx.moveTo(this.laneRight, 0);
    ctx.lineTo(this.laneRight, H);
    ctx.stroke();

    // Strike zone line
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(this.laneLeft, this.strikeY);
    ctx.lineTo(this.laneRight, this.strikeY);
    ctx.stroke();

    // Strike zone receptors (circles at bottom of each lane)
    for (let i = 0; i < CONFIG.LANE_COUNT; i++) {
      const lane = this.lanes[i];
      const isPressed = this.keysDown[i];

      // Outer ring
      ctx.beginPath();
      ctx.arc(lane.x, this.strikeY, CONFIG.NOTE_RADIUS + 4, 0, Math.PI * 2);
      ctx.strokeStyle = isPressed ? CONFIG.LANE_COLORS[i] : 'rgba(255,255,255,0.2)';
      ctx.lineWidth = isPressed ? 3 : 1.5;
      ctx.stroke();

      // Inner glow when pressed
      if (isPressed) {
        ctx.beginPath();
        ctx.arc(lane.x, this.strikeY, CONFIG.NOTE_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = CONFIG.LANE_GLOW[i];
        ctx.fill();
      }

      // Key label
      ctx.font = '14px "Press Start 2P"';
      ctx.textAlign = 'center';
      ctx.fillStyle = isPressed ? CONFIG.LANE_COLORS[i] : 'rgba(255,255,255,0.3)';
      ctx.fillText(CONFIG.LANE_KEYS[i].toUpperCase(), lane.x, this.strikeY + 5);
    }

    // Draw notes
    for (const note of this.activeNotes) {
      if (note.hit) continue; // Don't draw hit notes

      const lane = this.lanes[note.lane];
      const color = CONFIG.LANE_COLORS[note.lane];
      const alpha = note.missed ? 0.3 : 1;

      // Note glow
      if (!note.missed) {
        ctx.beginPath();
        ctx.arc(lane.x, note.y, CONFIG.NOTE_RADIUS + 8, 0, Math.PI * 2);
        const glowGrad = ctx.createRadialGradient(lane.x, note.y, 0, lane.x, note.y, CONFIG.NOTE_RADIUS + 8);
        glowGrad.addColorStop(0, color.replace(')', `,${0.4 * alpha})`).replace('rgb', 'rgba'));
        glowGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = glowGrad;
        ctx.fill();
      }

      // Note body
      ctx.beginPath();
      ctx.arc(lane.x, note.y, CONFIG.NOTE_RADIUS, 0, Math.PI * 2);
      ctx.fillStyle = note.missed ? `rgba(100,100,100,0.4)` : color;
      ctx.globalAlpha = alpha;
      ctx.fill();
      ctx.globalAlpha = 1;

      // Note border
      ctx.strokeStyle = note.missed ? 'rgba(255,0,0,0.3)' : 'rgba(255,255,255,0.6)';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Inner highlight
      if (!note.missed) {
        ctx.beginPath();
        ctx.arc(lane.x - 4, note.y - 4, CONFIG.NOTE_RADIUS * 0.4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fill();
      }
    }

    // Draw particles
    for (const p of this.particles) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
      ctx.fillStyle = p.color;
      ctx.globalAlpha = p.life;
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // Lane labels at bottom
    ctx.font = '11px "Permanent Marker"';
    ctx.textAlign = 'center';
    for (let i = 0; i < CONFIG.LANE_COUNT; i++) {
      ctx.fillStyle = CONFIG.LANE_COLORS[i];
      ctx.globalAlpha = 0.5;
      ctx.fillText(CONFIG.LANE_NAMES[i], this.lanes[i].x, this.strikeY + 40);
    }
    ctx.globalAlpha = 1;

    // Beat pulse overlay (subtle flash on each beat)
    const beatPhase = (songTime % SONG_STRUCTURE.msPerBeat) / SONG_STRUCTURE.msPerBeat;
    if (beatPhase < 0.1 && this.combo > 10) {
      ctx.fillStyle = `rgba(0,255,255,${0.03 * (1 - beatPhase / 0.1)})`;
      ctx.fillRect(0, 0, W, H);
    }

    ctx.restore();
  }

  updateHUD(songTime) {
    document.getElementById('score-value').textContent = this.score.toLocaleString();

    const comboEl = document.getElementById('combo-display');
    if (this.combo > 1) {
      comboEl.classList.add('active');
      document.getElementById('combo-count').textContent = this.combo;
    } else {
      comboEl.classList.remove('active');
    }

    document.getElementById('multiplier-display').textContent =
      this.multiplier > 1 ? `${this.multiplier}x` : '';

    // Progress bar
    const progress = Math.max(0, Math.min(100, (songTime / (CONFIG.SONG_DURATION * 1000)) * 100));
    document.getElementById('progress-bar').style.width = progress + '%';

    // Rock meter
    document.getElementById('rock-meter').style.height = this.rockMeter + '%';

    // Rock meter color
    const rm = document.getElementById('rock-meter');
    if (this.rockMeter > 70) rm.style.background = 'linear-gradient(0deg, #0f0, #0ff)';
    else if (this.rockMeter > 40) rm.style.background = 'linear-gradient(0deg, #ff0, #0f0)';
    else rm.style.background = 'linear-gradient(0deg, #f00, #ff0)';
  }

  endGame() {
    this.state = 'results';

    // Calculate accuracy
    const totalHits = this.stats.perfect + this.stats.great + this.stats.good;
    const totalJudged = totalHits + this.stats.miss;
    const accuracy = totalJudged > 0
      ? ((this.stats.perfect * 100 + this.stats.great * 80 + this.stats.good * 50) / (totalJudged * 100) * 100)
      : 0;

    // Grade
    let grade, gradeClass;
    if (accuracy >= 95) { grade = 'S'; gradeClass = 'grade-s'; }
    else if (accuracy >= 85) { grade = 'A'; gradeClass = 'grade-a'; }
    else if (accuracy >= 70) { grade = 'B'; gradeClass = 'grade-b'; }
    else if (accuracy >= 50) { grade = 'C'; gradeClass = 'grade-c'; }
    else { grade = 'F'; gradeClass = 'grade-f'; }

    const rs = document.getElementById('results-screen');
    rs.style.display = 'flex';
    document.getElementById('result-grade').textContent = grade;
    document.getElementById('result-grade').className = 'grade ' + gradeClass;
    document.getElementById('result-score').textContent = this.score.toLocaleString();
    document.getElementById('result-combo').textContent = this.maxCombo;
    document.getElementById('result-perfect').textContent = this.stats.perfect;
    document.getElementById('result-great').textContent = this.stats.great;
    document.getElementById('result-good').textContent = this.stats.good;
    document.getElementById('result-miss').textContent = this.stats.miss;
    document.getElementById('result-accuracy').textContent = accuracy.toFixed(1) + '%';

    if (this.audio) this.audio.pause();
  }
}

// ===== INIT =====
const game = new JURNRhythmGame();
</script>
</body>
</html>