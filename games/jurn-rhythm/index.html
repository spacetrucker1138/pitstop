<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>PIT FURY by JURN</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Permanent+Marker&family=Press+Start+2P&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #000;
    overflow: hidden;
    font-family: 'Press Start 2P', monospace;
    color: #fff;
    user-select: none;
  }

  #game-container {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
  }

  /* Video backdrop */
  .bg-vid {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    object-fit: cover;
    z-index: 0;
    opacity: 0.4;
    transition: filter 0.8s ease;
    filter: saturate(1.2) brightness(0.8);
  }

  /* Dark overlay on top of video */
  #video-overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    background: linear-gradient(180deg, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0.4) 40%, rgba(0,0,0,0.8) 100%);
    z-index: 1;
  }

  /* Game canvas */
  #game-canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 2;
  }

  /* HUD */
  #hud {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 3;
    pointer-events: none;
  }

  #score-display {
    position: absolute;
    top: 20px; right: 30px;
    text-align: right;
  }
  #score-display .score-label { font-size: 10px; color: #888; letter-spacing: 2px; }
  #score-display .score-value { font-size: 28px; color: #0ff; text-shadow: 0 0 20px #0ff; }

  #combo-display {
    position: absolute;
    top: 90px; right: 30px;
    text-align: right;
    opacity: 0;
    transition: opacity 0.2s;
  }
  #combo-display.active { opacity: 1; }
  #combo-display .combo-count { font-size: 36px; color: #f0f; text-shadow: 0 0 30px #f0f; }
  #combo-display .combo-label { font-size: 10px; color: #c0c; letter-spacing: 2px; }

  #multiplier-display {
    position: absolute;
    top: 160px; right: 30px;
    font-size: 14px;
    color: #ff0;
    text-shadow: 0 0 10px #ff0;
  }

  #difficulty-label {
    position: absolute;
    top: 20px; left: 50px;
    font-size: 10px;
    color: #888;
    letter-spacing: 2px;
    text-transform: uppercase;
  }

  /* Song progress bar */
  #progress-bar-container {
    position: absolute;
    top: 10px; left: 30px; right: 200px;
    height: 4px;
    background: rgba(255,255,255,0.1);
    border-radius: 2px;
  }
  #progress-bar {
    height: 100%;
    background: linear-gradient(90deg, #0ff, #f0f);
    border-radius: 2px;
    width: 0%;
    transition: width 0.5s linear;
  }

  /* Hit feedback */
  #hit-feedback {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    opacity: 0;
    pointer-events: none;
    z-index: 10;
  }
  #hit-feedback.perfect { color: #0ff; text-shadow: 0 0 30px #0ff; }
  #hit-feedback.great { color: #0f0; text-shadow: 0 0 20px #0f0; }
  #hit-feedback.good { color: #ff0; text-shadow: 0 0 15px #ff0; }
  #hit-feedback.miss { color: #f00; text-shadow: 0 0 15px #f00; }
  #hit-feedback.bonus\! { color: #ffa500; text-shadow: 0 0 15px #ffa500; }

  /* Rock meter */
  #rock-meter-container {
    position: absolute;
    left: 20px;
    top: 50%;
    transform: translateY(-50%);
    width: 20px;
    height: 300px;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 10px;
    overflow: hidden;
  }
  #rock-meter {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 50%;
    background: linear-gradient(0deg, #0f0, #ff0, #f00);
    border-radius: 0 0 10px 10px;
    transition: height 0.3s ease;
  }

  /* Start screen */
  #start-screen {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 100;
    background: rgba(0,0,0,0.95);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 15px;
  }
  #start-screen h1 {
    font-family: 'Permanent Marker', cursive;
    font-size: 64px;
    color: #0ff;
    text-shadow: 0 0 40px #0ff, 0 0 80px #0ff;
    letter-spacing: 10px;
  }
  #start-screen h2 {
    font-family: 'Permanent Marker', cursive;
    font-size: 24px;
    color: #f0f;
    text-shadow: 0 0 20px #f0f;
  }
  #start-screen .song-title {
    font-family: 'Press Start 2P', monospace;
    font-size: 12px;
    color: #ff0;
    margin-top: 10px;
  }
  #start-screen .instructions {
    font-size: 10px;
    color: #888;
    line-height: 2;
    text-align: center;
    margin-top: 15px;
  }
  #start-screen .instructions span { color: #0ff; }

  .difficulty-select {
    display: flex;
    gap: 20px;
    margin-top: 25px;
  }
  .diff-btn {
    font-family: 'Press Start 2P', monospace;
    font-size: 12px;
    border: 2px solid;
    padding: 15px 30px;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 2px;
    background: transparent;
    transition: all 0.2s;
    pointer-events: auto;
  }
  .diff-btn:hover {
    transform: scale(1.05);
  }
  .diff-beginner {
    color: #0ff;
    border-color: #0ff;
    text-shadow: 0 0 10px #0ff;
    font-size: 10px;
  }
  .diff-beginner:hover { background: rgba(0,255,255,0.15); box-shadow: 0 0 30px rgba(0,255,255,0.3); }
  .diff-easy {
    color: #0f0;
    border-color: #0f0;
    text-shadow: 0 0 10px #0f0;
  }
  .diff-easy:hover { background: rgba(0,255,0,0.15); box-shadow: 0 0 30px rgba(0,255,0,0.3); }
  .diff-hard {
    color: #f00;
    border-color: #f00;
    text-shadow: 0 0 10px #f00;
  }
  .diff-hard:hover { background: rgba(255,0,0,0.15); box-shadow: 0 0 30px rgba(255,0,0,0.3); }

  .diff-desc {
    font-size: 8px;
    color: #666;
    margin-top: 5px;
    text-align: center;
  }

  /* Results screen */
  #results-screen {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 100;
    background: rgba(0,0,0,0.95);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 12px;
  }
  #results-screen h1 {
    font-family: 'Permanent Marker', cursive;
    font-size: 48px;
    color: #0ff;
    text-shadow: 0 0 30px #0ff;
  }
  #results-screen .stat {
    font-size: 11px;
    color: #ccc;
    line-height: 2.5;
  }
  #results-screen .stat .val { color: #0ff; }
  #results-screen .grade {
    font-size: 72px;
    font-family: 'Permanent Marker', cursive;
    margin: 5px 0;
  }
  .grade-s { color: #0ff; text-shadow: 0 0 40px #0ff, 0 0 80px #0ff; }
  .grade-a { color: #0f0; text-shadow: 0 0 30px #0f0; }
  .grade-b { color: #ff0; text-shadow: 0 0 20px #ff0; }
  .grade-c { color: #f80; text-shadow: 0 0 20px #f80; }
  .grade-f { color: #f00; text-shadow: 0 0 20px #f00; }

  #results-screen .start-btn {
    font-family: 'Press Start 2P', monospace;
    font-size: 12px;
    color: #000;
    background: #0ff;
    border: none;
    padding: 12px 30px;
    cursor: pointer;
    letter-spacing: 2px;
    margin-top: 15px;
    pointer-events: auto;
  }

  /* Particles container */
  #particles {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 4;
    pointer-events: none;
  }

  /* Loading overlay */
  #loading-overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 200;
    background: #000;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 20px;
  }
  #loading-overlay .loading-text {
    font-size: 14px;
    color: #0ff;
    animation: loadPulse 1s ease-in-out infinite;
  }
  @keyframes loadPulse {
    0%, 100% { opacity: 0.5; }
    50% { opacity: 1; }
  }
  #loading-bar-outer {
    width: 300px; height: 6px;
    background: rgba(255,255,255,0.1);
    border-radius: 3px;
  }
  #loading-bar-inner {
    height: 100%;
    background: linear-gradient(90deg, #0ff, #f0f);
    border-radius: 3px;
    width: 0%;
    transition: width 0.3s;
  }

  /* Countdown */
  #countdown {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-family: 'Permanent Marker', cursive;
    font-size: 120px;
    color: #0ff;
    text-shadow: 0 0 60px #0ff;
    z-index: 50;
    opacity: 0;
    pointer-events: none;
  }

  /* ============================================
     PIT FURY - SCREEN FLOW STYLES
     ============================================ */

  /* TITLE SCREEN */
  #title-screen {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 10;
    background: #000;
    overflow: hidden;
  }
  #title-bg-video {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    object-fit: cover;
    z-index: 0;
    opacity: 0.45;
    filter: saturate(1.4) brightness(0.7);
  }
  #title-art-area {
    position: relative;
    z-index: 2;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 30px;
  }
  #title-art-img {
    max-height: 65vh;
    max-width: 90vw;
    object-fit: contain;
    filter: drop-shadow(0 0 30px rgba(255, 100, 0, 0.6));
    animation: titleFloat 3s ease-in-out infinite;
  }
  @keyframes titleFloat {
    0%, 100% { transform: translateY(0px); filter: drop-shadow(0 0 30px rgba(255, 100, 0, 0.6)); }
    50% { transform: translateY(-8px); filter: drop-shadow(0 0 50px rgba(255, 100, 0, 0.9)); }
  }

  .title-press-start {
    position: relative;
    z-index: 2;
    font-family: 'Press Start 2P', monospace;
    font-size: 14px;
    color: #fff;
    letter-spacing: 4px;
    animation: blink 1s step-end infinite;
  }
  @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

  /* SONG SELECT SCREEN */
  #song-select-screen, #difficulty-screen {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 10;
    background: rgba(0,0,0,0.9);
    gap: 20px;
  }

  .screen-heading {
    font-family: 'Press Start 2P', monospace;
    font-size: 18px;
    color: #0ff;
    text-shadow: 0 0 20px #0ff;
    letter-spacing: 4px;
    margin-bottom: 10px;
  }

  .song-title-small {
    font-family: 'Press Start 2P', monospace;
    font-size: 10px;
    color: #f0f;
    text-shadow: 0 0 10px #f0f;
    letter-spacing: 2px;
    margin-bottom: 10px;
  }

  .song-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
    width: min(600px, 90vw);
  }

  .song-card {
    border: 2px solid #333;
    padding: 20px 24px;
    border-radius: 4px;
    background: rgba(255,255,255,0.04);
    cursor: pointer;
    transition: all 0.2s;
  }
  .song-card.active-song {
    border-color: #f0f;
    background: rgba(255,0,255,0.1);
    box-shadow: 0 0 20px rgba(255,0,255,0.3);
  }
  .song-card-title {
    font-family: 'Press Start 2P', monospace;
    font-size: 11px;
    color: #fff;
    margin-bottom: 8px;
  }
  .song-card-meta {
    font-family: 'Press Start 2P', monospace;
    font-size: 8px;
    color: #888;
    margin-bottom: 10px;
  }
  .song-card-keys {
    font-family: 'Press Start 2P', monospace;
    font-size: 8px;
    color: #aaa;
  }
  .key-badge {
    font-weight: bold;
    text-shadow: 0 0 8px currentColor;
  }

  .nav-btn {
    font-family: 'Press Start 2P', monospace;
    font-size: 13px;
    border: 2px solid #0ff;
    color: #0ff;
    background: transparent;
    padding: 14px 40px;
    cursor: pointer;
    letter-spacing: 3px;
    transition: all 0.2s;
    margin-top: 10px;
  }
  .nav-btn:hover {
    background: rgba(0,255,255,0.15);
    box-shadow: 0 0 20px rgba(0,255,255,0.4);
  }
  .back-btn {
    border-color: #888;
    color: #888;
    font-size: 10px;
    padding: 10px 24px;
    margin-top: 6px;
  }
  .back-btn:hover {
    background: rgba(136,136,136,0.1);
    box-shadow: none;
  }

  .back-to-title-btn {
    background: transparent;
    border-color: #888 !important;
    color: #888 !important;
  }
  .back-to-title-btn:hover {
    background: rgba(255,255,255,0.05) !important;
    box-shadow: none !important;
  }

</style>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
</head>
<body>
<div id="game-container">
  <video id="vid-main" class="bg-vid" muted loop playsinline></video>
  <div id="video-overlay"></div>
  <canvas id="game-canvas"></canvas>

  <div id="hud">
    <div id="progress-bar-container"><div id="progress-bar"></div></div>
    <div id="score-display">
      <div class="score-label">SCORE</div>
      <div class="score-value" id="score-value">0</div>
    </div>
    <div id="combo-display">
      <div class="combo-count" id="combo-count">0</div>
      <div class="combo-label">COMBO</div>
    </div>
    <div id="multiplier-display" id="multiplier-value"></div>
    <div id="difficulty-label"></div>
    <div id="rock-meter-container"><div id="rock-meter"></div></div>
    <div id="hit-feedback"></div>
  </div>

  <div id="countdown"></div>
  <div id="particles"></div>

  <!-- Loading screen -->
  <div id="loading-overlay">
    <div class="loading-text">LOADING TRACK...</div>
    <div id="loading-bar-outer"><div id="loading-bar-inner"></div></div>
  </div>

  <!-- TITLE SCREEN -->
  <div id="title-screen">
    <video id="title-bg-video" autoplay muted loop playsinline>
      <source src="videos/title_bg.mp4" type="video/mp4">
    </video>
    <div id="title-art-area">
      <img src="images/pit_fury_title_art.jpg" alt="Pit Fury - Rock of the Undead" id="title-art-img">
    </div>
    <div class="title-press-start">PRESS ANY KEY</div>
  </div>

  <!-- SONG SELECT SCREEN -->
  <div id="song-select-screen" style="display:none;">
    <h2 class="screen-heading">SELECT SONG</h2>
    <div class="song-list">
      <div class="song-card active-song" id="song-grgh">
        <div class="song-card-title">&#9835; GET READY FOR GET HAPPY &#9835;</div>
        <div class="song-card-meta">JURN Â· 3:00 Â· 155 BPM Â· F MAJOR</div>
        <div class="song-card-keys">
          <span class="key-badge" style="color:#f0f">A</span> Taz (Bass) &nbsp;
          <span class="key-badge" style="color:#0ff">S</span> Bonecrush (Drums) &nbsp;
          <span class="key-badge" style="color:#0f0">D</span> Riff-Rot (Guitar) &nbsp;
          <span class="key-badge" style="color:#ff0">F</span> Vox (Vocals)
        </div>
      </div>
      <div class="song-card" id="song-rage">
        <div class="song-card-title">&#9835; RAGE &#9835;</div>
        <div class="song-card-meta">THE JURN Â· 2:04 Â· 180 BPM</div>
        <div class="song-card-keys">
          <span class="key-badge" style="color:#f0f">A</span> Taz (Bass) &nbsp;
          <span class="key-badge" style="color:#0ff">S</span> Bonecrush (Drums) &nbsp;
          <span class="key-badge" style="color:#0f0">D</span> Riff-Rot (Guitar) &nbsp;
          <span class="key-badge" style="color:#ff0">F</span> Vox (Vocals)
        </div>
      </div>
    </div>
    <button class="nav-btn" id="btn-song-select">SELECT</button>
  </div>

  <!-- DIFFICULTY SELECT SCREEN -->
  <div id="difficulty-screen" style="display:none;">
    <h2 class="screen-heading">SELECT DIFFICULTY</h2>
    <div class="song-title-small">&#9835; GET READY FOR GET HAPPY &#9835;</div>
    <div class="difficulty-select">
      <div>
        <button class="diff-btn diff-beginner" id="btn-beginner">BEGINNER</button>
        <div class="diff-desc">A lane = free miss</div>
      </div>
      <div>
        <button class="diff-btn diff-easy" id="btn-easy">EASY</button>
        <div class="diff-desc">4 keys Â· chill</div>
      </div>
      <div>
        <button class="diff-btn diff-hard" id="btn-hard">HARD</button>
        <div class="diff-desc">4 keys Â· mosh pit</div>
      </div>
    </div>
    <button class="nav-btn back-btn" id="btn-diff-back">&#8592; BACK</button>
  </div>

  <!-- Results screen -->
  <div id="results-screen">
    <h1>SONG COMPLETE</h1>
    <div class="grade" id="result-grade"></div>
    <div class="stat">SCORE: <span class="val" id="result-score"></span></div>
    <div class="stat">MAX COMBO: <span class="val" id="result-combo"></span></div>
    <div class="stat">PERFECT: <span class="val" id="result-perfect"></span></div>
    <div class="stat">GREAT: <span class="val" id="result-great"></span></div>
    <div class="stat">GOOD: <span class="val" id="result-good"></span></div>
    <div class="stat">MISS: <span class="val" id="result-miss"></span></div>
    <div class="stat">ACCURACY: <span class="val" id="result-accuracy"></span></div>
    <div id="jrInitialsSection" style="display:none;margin:8px 0;">
      <div style="font-size:0.75rem;color:#0ff;margin-bottom:6px;letter-spacing:0.08em;">NEW HIGH SCORE — enter your initials</div>
      <input id="jrInitialsInput" maxlength="3" autocomplete="off" spellcheck="false"
        style="width:80px;font-size:1.6rem;text-align:center;background:#0a1a1a;border:1px solid #0ff;
               color:#0ff;padding:4px 8px;border-radius:4px;font-family:monospace;text-transform:uppercase;letter-spacing:0.2em;" />
      <button id="jrInitialsSubmit" style="display:block;margin:8px auto 0;background:#0ff;color:#000;
        border:none;padding:6px 18px;border-radius:4px;cursor:pointer;font-family:'Permanent Marker',cursive;font-size:1rem;">SUBMIT</button>
    </div>
    <div id="jrLeaderboard" style="display:none;margin:8px 0;min-width:220px;">
      <div style="color:rgba(255,255,255,0.4);font-size:0.75rem;margin-bottom:5px;letter-spacing:0.08em;text-align:center;">TOP SCORES</div>
      <div id="jrLbRows"></div>
    </div>
    <div style="display:flex;gap:20px;margin-top:15px;justify-content:center;">
      <button class="start-btn" id="restart-btn">PLAY AGAIN</button>
      <button class="start-btn back-to-title-btn" id="btn-title-btn">TITLE</button>
    </div>
  </div>
</div>

<script>
// ============================================================
// CONFIGURATION
// ============================================================
// CONFIG is derived from the active song at game start
// Static gameplay constants only â per-song values come from _activeSong
const CONFIG_BASE = {
  SCROLL_SPEED: 6,
  LANE_COUNT: 4,
  LANE_KEYS: ['a', 's', 'd', 'f'],
  HIT_Y: 0.88,
  NOTE_RADIUS: 22,
  PERFECT_WINDOW: 50,
  GREAT_WINDOW: 100,
  GOOD_WINDOW: 150,
  PERFECT_SCORE: 300,
  GREAT_SCORE: 200,
  GOOD_SCORE: 100,
  MULT_THRESHOLDS: [10, 30, 60, 100],
  MAX_MULTIPLIER: 5,
  ROCK_METER_MAX: 100,
  ROCK_METER_START: 50,
  ROCK_HIT_GAIN: 2,
  ROCK_MISS_PENALTY: 8,
  VOCALS_LANE: 3,
};

function buildConfig(song) {
  return Object.assign({}, CONFIG_BASE, {
    BPM: song.bpm,
    SONG_DURATION: song.duration,
    AUDIO_URL: song.audioUrl,
    STEM_URLS: song.stemUrls,
    LANE_COLORS: song.laneColors,
    LANE_GLOW:   song.laneGlow,
    LANE_NAMES:  song.laneNames,
  });
}


// ============================================================
// SONG STRUCTURE @ 155 BPM
// ============================================================

// âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
//  SONG CATALOG
// âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
const SONG_CATALOG = [
  {
    id: 'grgh',
    title: 'GET READY FOR GET HAPPY',
    meta: 'JURN Â· 3:00 Â· 155 BPM Â· F MAJOR',
    bpm: 155,
    duration: 180,
    audioUrl: 'audio/combined.mp3',
    stemUrls: [
      'audio/stems/bass.mp3',
      'audio/stems/drums.mp3',
      'audio/stems/guitar.mp3',
      'audio/stems/lead_vocals.mp3',
      'audio/stems/backing_vocals.mp3',
    ],
    laneNames:  ['TAZ', 'CRUSH', 'RIFF', 'VOX'],
    laneColors: ['#f0f', '#0ff', '#0f0', '#ff0'],
    laneGlow:   ['rgba(255,0,255,', 'rgba(0,255,255,', 'rgba(0,255,0,', 'rgba(255,255,0,'],
    videoClips: {
      taz:       'videos/taz.mp4',
      bonecrush: 'videos/bonecrush.mp4',
      rif:       'videos/rif.mp4',
      vox:       'videos/vox.mp4',
      fullband:  'videos/fullband.mp4',
      fullband1: 'videos/fullBand1.mp4',
      fullband2: 'videos/fullBand2.mp4',
    },
    sections: [
      { name: 'intro',       startMs: 0,      endMs: 13000,  type: 'instrumental' },
      { name: 'verse1',      startMs: 13000,  endMs: 34000,  type: 'verse' },
      { name: 'chorus1',     startMs: 34000,  endMs: 58000,  type: 'chorus' },
      { name: 'postChorus1', startMs: 58000,  endMs: 83000,  type: 'post_chorus' },
      { name: 'break',       startMs: 83000,  endMs: 91000,  type: 'instrumental' },
      { name: 'verse2',      startMs: 91000,  endMs: 116000, type: 'verse' },
      { name: 'chorus2',     startMs: 116000, endMs: 130000, type: 'chorus' },
      { name: 'postChorus2', startMs: 130000, endMs: 150000, type: 'post_chorus' },
      { name: 'outro',       startMs: 150000, endMs: 180000, type: 'outro' },
    ],
  },
  {
    id: 'rage',
    title: 'RAGE',
    meta: 'THE JURN Â· 2:04 Â· 180 BPM',
    bpm: 180,
    duration: 124,
    audioUrl: 'audio/rage/combined.mp3',
    stemUrls: [
      'audio/rage/stems/bass.mp3',
      'audio/rage/stems/drums.mp3',
      'audio/rage/stems/guitar.mp3',
      'audio/rage/stems/vocals.mp3',       // combined lead+backing
    ],
    laneNames:  ['TAZ', 'CRUSH', 'RIFF', 'VOX'],
    laneColors: ['#f0f', '#0ff', '#0f0', '#ff0'],
    laneGlow:   ['rgba(255,0,255,', 'rgba(0,255,255,', 'rgba(0,255,0,', 'rgba(255,255,0,'],
    videoClips: {
      taz:       'videos/taz.mp4',
      bonecrush: 'videos/bonecrush.mp4',
      rif:       'videos/rif.mp4',
      vox:       'videos/vox.mp4',
      fullband:  'videos/fullband.mp4',
      fullband1: 'videos/fullBand1.mp4',
      fullband2: 'videos/fullBand2.mp4',
    },
    sections: [
      { name: 'intro',      startMs: 0,      endMs: 12000,  type: 'instrumental' },
      { name: 'verse1',     startMs: 12000,  endMs: 30000,  type: 'verse' },
      { name: 'preChorus',  startMs: 30000,  endMs: 43000,  type: 'pre_chorus' },
      { name: 'chorus1',    startMs: 43000,  endMs: 64000,  type: 'chorus' },
      { name: 'bridge',     startMs: 64000,  endMs: 85000,  type: 'bridge' },
      { name: 'breakdown',  startMs: 85000,  endMs: 100000, type: 'breakdown' },
      { name: 'buildup',    startMs: 100000, endMs: 108000, type: 'instrumental' },
      { name: 'chorus2',    startMs: 108000, endMs: 117000, type: 'chorus' },
      { name: 'outro',      startMs: 117000, endMs: 124000, type: 'outro' },
    ],
  },
];

// Active song â default to first
let _activeSong = SONG_CATALOG[0];


// Tag each section with its occurrence index (for video alternation)

// Stamp section indices for all songs in catalog at startup
(function() {
  for (const song of SONG_CATALOG) {
    const _c = {};
    for (const s of song.sections) {
      s.index = (_c[s.type] || 0);
      _c[s.type] = (_c[s.type] || 0) + 1;
    }
  }
})();

// CONFIG is set when a song is selected; starts as first song default
let CONFIG = buildConfig(SONG_CATALOG[0]);

// ============================================================
// BEATMAP GENERATOR â Two difficulty levels
// ============================================================
function generateBeatmap(difficulty, songDef) {
  const song = songDef || _activeSong;
  const notes = [];
  const b = 60000 / song.bpm;
  const h = b / 2;
  const isBeginner = difficulty === 'beginner';

  for (const sec of song.sections) {
    let t = sec.startMs;
    const end = sec.endMs;

    if (isBeginner) {
      // BEGINNER: 3 lanes only (S=Drumsâ0, D=Guitarâ1, F=Vocalsâ2)
      // Sparse notes, only on the beat, one note at a time mostly
      switch (sec.type) {
        case 'instrumental':
          while (t < end) {
            notes.push({ time: t,       lane: 0 }); // drums beat 1
            notes.push({ time: t + b,   lane: 1 }); // guitar beat 2
            notes.push({ time: t + b*2, lane: 0 }); // drums beat 3
            notes.push({ time: t + b*3, lane: 1 }); // guitar beat 4
            t += b * 4;
          }
          break;
        case 'verse':
          while (t < end) {
            notes.push({ time: t,       lane: 2 }); // vocals beat 1
            notes.push({ time: t + b,   lane: 0 }); // drums beat 2
            notes.push({ time: t + b*2, lane: 2 }); // vocals beat 3
            notes.push({ time: t + b*3, lane: 0 }); // drums beat 4
            t += b * 4;
          }
          break;
        case 'chorus':
          while (t < end) {
            notes.push({ time: t,       lane: 0 });
            notes.push({ time: t,       lane: 1 });
            notes.push({ time: t + b,   lane: 2 });
            notes.push({ time: t + b,   lane: 0 });
            notes.push({ time: t + b*2, lane: 1 });
            notes.push({ time: t + b*2, lane: 2 });
            notes.push({ time: t + b*3, lane: 0 });
            notes.push({ time: t + b*3, lane: 1 });
            t += b * 4;
          }
          break;
        case 'post_chorus':
          while (t < end) {
            notes.push({ time: t,       lane: 1 });
            notes.push({ time: t + b,   lane: 0 });
            notes.push({ time: t + b*2, lane: 2 });
            notes.push({ time: t + b*3, lane: 0 });
            t += b * 4;
          }
          break;

        case 'pre_chorus':
          while (t < end) {
            notes.push({ time: t,       lane: 2 }); // vocals
            notes.push({ time: t + b,   lane: 0 }); // drums
            notes.push({ time: t + b*2, lane: 2 }); // vocals
            notes.push({ time: t + b*2, lane: 1 }); // guitar
            t += b * 4;
          }
          break;
        case 'bridge':
          while (t < end) {
            notes.push({ time: t,       lane: 1 }); // guitar
            notes.push({ time: t + b,   lane: 0 }); // drums
            notes.push({ time: t + b*2, lane: 2 }); // vocals
            notes.push({ time: t + b*3, lane: 0 }); // drums
            t += b * 4;
          }
          break;
        case 'breakdown':
          // Sparse â beginner gets a breather here
          while (t < end) {
            notes.push({ time: t,       lane: 0 }); // drums only
            notes.push({ time: t + b*2, lane: 1 }); // guitar
            t += b * 4;
          }
          break;
        case 'outro':
          while (t < end - 3000) {
            notes.push({ time: t,       lane: 0 });
            notes.push({ time: t,       lane: 1 });
            notes.push({ time: t + b,   lane: 2 });
            notes.push({ time: t + b*2, lane: 0 });
            notes.push({ time: t + b*2, lane: 1 });
            notes.push({ time: t + b*3, lane: 2 });
            t += b * 4;
          }
          notes.push({ time: end - 2000, lane: 0 });
          notes.push({ time: end - 2000, lane: 1 });
          notes.push({ time: end - 2000, lane: 2 });
          break;
      }
    } else if (difficulty === 'easy') {
      // ---- EASY: ~40-50% fewer notes, mostly single hits on strong beats ----
      switch (sec.type) {
        case 'instrumental':
          while (t < end) {
            notes.push({ time: t, lane: 1 });          // drums beat 1
            notes.push({ time: t + b, lane: 2 });      // guitar beat 2
            notes.push({ time: t + b*2, lane: 0 });    // bass beat 3
            notes.push({ time: t + b*3, lane: 1 });    // drums beat 4
            t += b * 4;
          }
          break;
        case 'verse':
          while (t < end) {
            notes.push({ time: t, lane: 3 });           // vocals beat 1
            notes.push({ time: t + b, lane: 1 });       // drums beat 2
            notes.push({ time: t + b*2, lane: 3 });     // vocals beat 3
            notes.push({ time: t + b*2, lane: 2 });     // guitar beat 3
            notes.push({ time: t + b*3, lane: 1 });     // drums beat 4
            t += b * 4;
          }
          break;
        case 'chorus':
          while (t < end) {
            // Chorus: still feels energetic but manageable
            notes.push({ time: t, lane: 0 });
            notes.push({ time: t, lane: 2 });
            notes.push({ time: t + b, lane: 1 });
            notes.push({ time: t + b, lane: 3 });
            notes.push({ time: t + b*2, lane: 0 });
            notes.push({ time: t + b*2, lane: 2 });
            notes.push({ time: t + b*3, lane: 1 });
            notes.push({ time: t + b*3, lane: 3 });
            t += b * 4;
          }
          break;
        case 'post_chorus':
          while (t < end) {
            notes.push({ time: t, lane: 0 });
            notes.push({ time: t + b, lane: 1 });
            notes.push({ time: t + b*2, lane: 2 });
            notes.push({ time: t + b*2, lane: 3 });
            notes.push({ time: t + b*3, lane: 1 });
            t += b * 4;
          }
          break;

        case 'pre_chorus':
          while (t < end) {
            notes.push({ time: t, lane: 3 });           // vocals
            notes.push({ time: t + b, lane: 1 });       // drums
            notes.push({ time: t + b, lane: 2 });       // guitar
            notes.push({ time: t + b*2, lane: 3 });     // vocals
            notes.push({ time: t + b*3, lane: 1 });     // drums
            t += b * 4;
          }
          break;
        case 'bridge':
          while (t < end) {
            notes.push({ time: t, lane: 2 });
            notes.push({ time: t, lane: 0 });
            notes.push({ time: t + b, lane: 1 });
            notes.push({ time: t + b*2, lane: 3 });
            notes.push({ time: t + b*2, lane: 2 });
            notes.push({ time: t + b*3, lane: 1 });
            t += b * 4;
          }
          break;
        case 'breakdown':
          // Half-time feel â sparse hits on every other beat
          while (t < end) {
            notes.push({ time: t, lane: 0 });
            notes.push({ time: t, lane: 1 });
            notes.push({ time: t + b*2, lane: 2 });
            notes.push({ time: t + b*2, lane: 3 });
            t += b * 4;
          }
          break;
        case 'outro':
          while (t < end - 3000) {
            notes.push({ time: t, lane: 0 });
            notes.push({ time: t, lane: 1 });
            notes.push({ time: t + b, lane: 2 });
            notes.push({ time: t + b, lane: 3 });
            notes.push({ time: t + b*2, lane: 1 });
            notes.push({ time: t + b*3, lane: 0 });
            notes.push({ time: t + b*3, lane: 2 });
            t += b * 4;
          }
          // Final chord
          notes.push({ time: end - 2000, lane: 0 });
          notes.push({ time: end - 2000, lane: 1 });
          notes.push({ time: end - 2000, lane: 2 });
          notes.push({ time: end - 2000, lane: 3 });
          break;
      }
    } else {
      // ---- HARD: Dense patterns, eighth notes, multi-lane hits ----
      switch (sec.type) {
        case 'instrumental':
          while (t < end) {
            notes.push({ time: t, lane: 1 });
            notes.push({ time: t, lane: 2 });
            notes.push({ time: t + h, lane: 0 });
            notes.push({ time: t + b, lane: 1 });
            notes.push({ time: t + b + h, lane: 2 });
            notes.push({ time: t + b*2, lane: 1 });
            notes.push({ time: t + b*2, lane: 0 });
            notes.push({ time: t + b*3, lane: 2 });
            notes.push({ time: t + b*3 + h, lane: 1 });
            t += b * 4;
          }
          break;
        case 'verse':
          while (t < end) {
            notes.push({ time: t, lane: 3 });
            notes.push({ time: t, lane: 1 });
            notes.push({ time: t + h, lane: 0 });
            notes.push({ time: t + b, lane: 1 });
            notes.push({ time: t + b, lane: 2 });
            notes.push({ time: t + b + h, lane: 3 });
            notes.push({ time: t + b*2, lane: 1 });
            notes.push({ time: t + b*2, lane: 3 });
            notes.push({ time: t + b*2 + h, lane: 0 });
            notes.push({ time: t + b*3, lane: 1 });
            notes.push({ time: t + b*3, lane: 2 });
            t += b * 4;
          }
          break;
        case 'chorus':
          while (t < end) {
            // Dense chorus â every lane active, eighth note subdivisions
            notes.push({ time: t, lane: 0 });
            notes.push({ time: t, lane: 1 });
            notes.push({ time: t, lane: 2 });
            notes.push({ time: t, lane: 3 });
            notes.push({ time: t + h, lane: 1 });
            notes.push({ time: t + h, lane: 2 });
            notes.push({ time: t + b, lane: 3 });
            notes.push({ time: t + b, lane: 0 });
            notes.push({ time: t + b, lane: 1 });
            notes.push({ time: t + b + h, lane: 2 });
            notes.push({ time: t + b*2, lane: 0 });
            notes.push({ time: t + b*2, lane: 1 });
            notes.push({ time: t + b*2, lane: 2 });
            notes.push({ time: t + b*2 + h, lane: 3 });
            notes.push({ time: t + b*3, lane: 1 });
            notes.push({ time: t + b*3, lane: 2 });
            notes.push({ time: t + b*3 + h, lane: 0 });
            notes.push({ time: t + b*3 + h, lane: 1 });
            t += b * 4;
          }
          break;
        case 'post_chorus':
          while (t < end) {
            notes.push({ time: t, lane: 0 });
            notes.push({ time: t, lane: 2 });
            notes.push({ time: t + h, lane: 1 });
            notes.push({ time: t + b, lane: 3 });
            notes.push({ time: t + b, lane: 1 });
            notes.push({ time: t + b + h, lane: 0 });
            notes.push({ time: t + b + h, lane: 2 });
            notes.push({ time: t + b*2, lane: 1 });
            notes.push({ time: t + b*2 + h, lane: 3 });
            notes.push({ time: t + b*3, lane: 0 });
            notes.push({ time: t + b*3, lane: 1 });
            notes.push({ time: t + b*3, lane: 2 });
            notes.push({ time: t + b*3 + h, lane: 1 });
            t += b * 4;
          }
          break;

        case 'pre_chorus':
          while (t < end) {
            notes.push({ time: t, lane: 3 });
            notes.push({ time: t, lane: 1 });
            notes.push({ time: t + h, lane: 0 });
            notes.push({ time: t + b, lane: 1 });
            notes.push({ time: t + b, lane: 3 });
            notes.push({ time: t + b + h, lane: 2 });
            notes.push({ time: t + b*2, lane: 3 });
            notes.push({ time: t + b*2, lane: 1 });
            notes.push({ time: t + b*2 + h, lane: 0 });
            notes.push({ time: t + b*3, lane: 2 });
            notes.push({ time: t + b*3, lane: 1 });
            t += b * 4;
          }
          break;
        case 'bridge':
          while (t < end) {
            notes.push({ time: t, lane: 0 });
            notes.push({ time: t, lane: 2 });
            notes.push({ time: t + h, lane: 1 });
            notes.push({ time: t + h, lane: 3 });
            notes.push({ time: t + b, lane: 2 });
            notes.push({ time: t + b + h, lane: 0 });
            notes.push({ time: t + b*2, lane: 1 });
            notes.push({ time: t + b*2, lane: 3 });
            notes.push({ time: t + b*2 + h, lane: 2 });
            notes.push({ time: t + b*3, lane: 0 });
            notes.push({ time: t + b*3, lane: 1 });
            notes.push({ time: t + b*3 + h, lane: 2 });
            t += b * 4;
          }
          break;
        case 'breakdown':
          // Heavy half-time: big chords on the 1 and 3, driving eighth on 2
          while (t < end) {
            notes.push({ time: t, lane: 0 });
            notes.push({ time: t, lane: 1 });
            notes.push({ time: t, lane: 2 });
            notes.push({ time: t + h, lane: 3 });
            notes.push({ time: t + b, lane: 1 });
            notes.push({ time: t + b + h, lane: 2 });
            notes.push({ time: t + b*2, lane: 0 });
            notes.push({ time: t + b*2, lane: 1 });
            notes.push({ time: t + b*2, lane: 3 });
            notes.push({ time: t + b*3, lane: 2 });
            notes.push({ time: t + b*3 + h, lane: 1 });
            t += b * 4;
          }
          break;
        case 'outro':
          while (t < end - 3000) {
            // Dense all-lane assault
            notes.push({ time: t, lane: 0 });
            notes.push({ time: t, lane: 1 });
            notes.push({ time: t + h, lane: 2 });
            notes.push({ time: t + h, lane: 3 });
            notes.push({ time: t + b, lane: 0 });
            notes.push({ time: t + b, lane: 1 });
            notes.push({ time: t + b + h, lane: 2 });
            notes.push({ time: t + b + h, lane: 3 });
            notes.push({ time: t + b*2, lane: 0 });
            notes.push({ time: t + b*2, lane: 1 });
            notes.push({ time: t + b*2, lane: 2 });
            notes.push({ time: t + b*2, lane: 3 });
            notes.push({ time: t + b*3, lane: 1 });
            notes.push({ time: t + b*3 + h, lane: 0 });
            notes.push({ time: t + b*3 + h, lane: 2 });
            t += b * 4;
          }
          notes.push({ time: end - 2000, lane: 0 });
          notes.push({ time: end - 2000, lane: 1 });
          notes.push({ time: end - 2000, lane: 2 });
          notes.push({ time: end - 2000, lane: 3 });
          break;
      }
    }
  }

  notes.sort((a, b) => a.time - b.time);
  return notes;
}

// ----------------------------------------------------------------
// VideoBackdrop â manages dual-buffered video crossfade
// ----------------------------------------------------------------
class VideoBackdrop {
  constructor() {
    this.vid = document.getElementById('vid-main');
    this.currentSrc = null;

    this.clips = (_activeSong && _activeSong.videoClips) ? _activeSong.videoClips : {
      taz:       'videos/taz.mp4',
      bonecrush: 'videos/bonecrush.mp4',
      rif:       'videos/rif.mp4',
      vox:       'videos/vox.mp4',
      fullband:  'videos/fullband.mp4',
      fullband1: 'videos/fullBand1.mp4',
      fullband2: 'videos/fullBand2.mp4',
    };
    this.laneClip     = ['taz', 'bonecrush', 'rif', 'vox'];
    this.fullBandPool = ['fullband', 'fullband1', 'fullband2'];
    this.fullBandIdx  = 0;
  }

  _nextFullBand() {
    const k = this.fullBandPool[this.fullBandIdx % this.fullBandPool.length];
    this.fullBandIdx++;
    return k;
  }

  _play(clipKey) {
    if (!this.vid) return;
    const src = this.clips[clipKey];
    if (!src) return;
    if (src === this.currentSrc) return;
    this.currentSrc = src;
    this.vid.src = src;
    this.vid.currentTime = 0;
    this.vid.play().catch(() => {});
  }

  showBand(variant) {
    if (variant === 'chorus')     this._play('fullband2');
    else if (variant === 'outro') this._play('fullband1');
    else                          this._play(this._nextFullBand());
  }

  showLane(laneIdx) {
    const key = this.laneClip[laneIdx];
    if (key) this._play(key);
  }

  setRockFilter(rockPct) {
    if (!this.vid) return;
    if (rockPct > 0.6) {
      this.vid.style.filter = 'saturate(1.3) brightness(0.9)';
    } else if (rockPct > 0.3) {
      this.vid.style.filter = 'saturate(0.8) brightness(0.6)';
    } else {
      this.vid.style.filter = 'grayscale(70%) brightness(0.4)';
    }
  }

  stop() {
    if (!this.vid) return;
    this.vid.pause();
    this.vid.src = '';
    this.currentSrc = null;
  }
}


// ============================================================
// GAME ENGINE
// ============================================================
class JURNRhythmGame {
  constructor() {
    this.canvas = document.getElementById('game-canvas');
    this.ctx = this.canvas.getContext('2d');
    this.backdrop = new VideoBackdrop();
    this.audio = null;
    this.audioLoaded = false;
    this.difficulty = 'easy';

    // State
    this.state = 'start';
    this.score = 0;
    this.combo = 0;
    this.maxCombo = 0;
    this.multiplier = 1;
    this.rockMeter = CONFIG.ROCK_METER_START;
    this.stats = { perfect: 0, great: 0, good: 0, miss: 0 };
    this.totalNotes = 0;

    // Notes
    this.beatmap = [];
    this.activeNotes = [];
    this.nextNoteIndex = 0;

    // Input
    this.keysDown = {};
    this.keyFlash = [0, 0, 0, 0];
    this.missFlash = [0, 0, 0, 0];
    this.screenShake = 0;
    this.missFlash = [0, 0, 0, 0];
    this.screenShake = 0;

    // Timing
    this.songStartTime = 0;
    this.lastFrameTime = 0;
    this.countdownActive = false;

    // Visual
    this.particles = [];
    this.hitFeedbackTimer = 0;

    this.resize();
    this.bindEvents();
    this.preloadAudio();
  }

  resize() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
    this.W = this.canvas.width;
    this.H = this.canvas.height;

    const totalLaneWidth = Math.min(400, this.W * 0.45);
    const laneWidth = totalLaneWidth / CONFIG.LANE_COUNT;
    const startX = (this.W - totalLaneWidth) / 2;

    this.lanes = [];
    for (let i = 0; i < CONFIG.LANE_COUNT; i++) {
      this.lanes.push({
        x: startX + laneWidth * i + laneWidth / 2,
        width: laneWidth,
        left: startX + laneWidth * i,
      });
    }
    this.laneLeft = startX;
    this.laneRight = startX + totalLaneWidth;
    this.strikeY = this.H * CONFIG.HIT_Y;
  }

  preloadAudio() {
    // Try to load stems first; fall back to combined track
    this.stems = [];
    this.stemsLoaded = 0;
    this.stemsReady = false;
    this.laneActive = [true, true, true, true]; // per-lane active state

    const stemCount = CONFIG.STEM_URLS.length;
    let stemSuccessCount = 0;
    let stemErrorCount = 0;

    const checkStemsReady = () => {
      if (stemSuccessCount + stemErrorCount === stemCount) {
        if (stemSuccessCount === stemCount) {
          this.stemsReady = true;
          this.audioLoaded = true;
          console.log('All stems loaded');
        } else {
          // Fall back to combined track
          console.log('Some stems failed â falling back to combined.mp3');
          this.loadCombinedAudio();
        }
      }
    };

    CONFIG.STEM_URLS.forEach((url, i) => {
      const a = new Audio();
      a.crossOrigin = 'anonymous';
      a.preload = 'auto';
      a.src = url;
      a.loop = false;
      a.addEventListener('canplaythrough', () => { stemSuccessCount++; checkStemsReady(); }, { once: true });
      a.addEventListener('error', () => { stemErrorCount++; checkStemsReady(); }, { once: true });
      a.load();
      this.stems.push(a);
    });

    // Also pre-load the fallback combined track
    this.audio = new Audio();
    this.audio.crossOrigin = 'anonymous';
    this.audio.preload = 'auto';
    this.audio.src = CONFIG.AUDIO_URL;
    this.audio.addEventListener('canplaythrough', () => {
      if (!this.stemsReady) { this.audioLoaded = true; }
      console.log('Combined audio loaded');
    }, { once: true });
    this.audio.addEventListener('error', () => {
      if (!this.stemsReady) { console.log('No audio found â silent mode'); this.audioLoaded = false; }
    }, { once: true });
    this.audio.load();
  }

  loadCombinedAudio() {
    // Just use this.audio (already loading)
    this.stemsReady = false;
  }

  // Mute or restore a stem lane (0-indexed). Vocals lane is always exempt.
  setStemActive(laneIndex, active) {
    if (laneIndex === CONFIG.VOCALS_LANE) return; // vocals never mute
    if (laneIndex >= this.stems.length) return;

    // Check if this lane is section-protected (e.g., guitar during breakdown/bridge)
    const songTime = this.getSongTime ? this.getSongTime() : 0;
    const sec = _activeSong.sections.find(s => songTime >= s.startMs && songTime < s.endMs);
    const protectedTypes = ['breakdown', 'bridge', 'outro'];
    if (!active && sec && protectedTypes.includes(sec.type)) {
      // Don't mute non-vocal lanes in sparse sections â too few notes to recover
      return;
    }

    this.laneActive[laneIndex] = active;
    this.stems[laneIndex].volume = active ? 1.0 : 0.0;

    // Track mute timestamp for decay restore
    if (!active) {
      if (!this._mutedAt) this._mutedAt = {};
      this._mutedAt[laneIndex] = performance.now();
    } else {
      if (this._mutedAt) delete this._mutedAt[laneIndex];
    }
  }

  // Called every frame â auto-restore stems muted for too long with no upcoming notes
  _tickStemDecay() {
    if (!this.stemsReady || !this._mutedAt) return;
    const now = performance.now();
    const songTime = this.getSongTime ? this.getSongTime() : 0;
    const DECAY_MS = 4000; // restore after 4s of silence on that lane

    for (const [laneStr, mutedAt] of Object.entries(this._mutedAt)) {
      const lane = parseInt(laneStr);
      if (now - mutedAt < DECAY_MS) continue;
      // Check if there's an upcoming note on this lane within 3 beats
      const lookAhead = 60000 / CONFIG.BPM * 3;
      const hasUpcoming = this.beatmap && this.beatmap.some(
        n => n.lane === lane && n.time > songTime && n.time < songTime + lookAhead && !n.hit && !n.missed
      );
      if (!hasUpcoming) {
        this.setStemActive(lane, true);
      }
    }
  }

  playStems() {
    if (!this.stemsReady) return;
    const now = this.stems[0].currentTime; // sync point
    this.stems.forEach((stem, i) => {
      stem.currentTime = 0;
      stem.volume = 1.0;
      stem.play().catch(() => {});
    });
    // Backing vocals (index 4) rides along with overall playback â never muted independently
    this.laneActive = [true, true, true, true];
  }

  stopStems() {
    this.stems.forEach(stem => { try { stem.pause(); stem.currentTime = 0; } catch(e){} });
  }

  bindEvents() {
    window.addEventListener('resize', () => this.resize());

    window.addEventListener('keydown', (e) => {
      if (this.state !== 'playing') return;
      const lane = CONFIG.LANE_KEYS.indexOf(e.key.toLowerCase());
      if (lane === -1) return;
      e.preventDefault();
      if (!this.keysDown[lane]) {
        this.keysDown[lane] = true;
        this.keyFlash[lane] = 1;
        this.checkHit(lane);
      }
    });

    window.addEventListener('keyup', (e) => {
      const lane = CONFIG.LANE_KEYS.indexOf(e.key.toLowerCase());
      if (lane === -1) return;
      this.keysDown[lane] = false;
    });

    // ---- Title Screen: any key press goes to song select ----
    const titleScreen = document.getElementById('title-screen');
    const goToSongSelect = () => {
      titleScreen.style.display = 'none';
      document.getElementById('song-select-screen').style.display = 'flex';
    };
    titleScreen.addEventListener('click', goToSongSelect);
    document.addEventListener('keydown', (e) => {
      if (document.getElementById('title-screen').style.display !== 'none') {
        goToSongSelect();
      }
    });

    // ---- Song Select: song card clicks set active song ----
    document.querySelectorAll('.song-card').forEach(card => {
      card.addEventListener('click', () => {
        document.querySelectorAll('.song-card').forEach(c => c.classList.remove('active-song'));
        card.classList.add('active-song');
        const sid = card.id.replace('song-', '');
        const found = SONG_CATALOG.find(s => s.id === sid);
        if (found) {
          _activeSong = found;
          CONFIG = buildConfig(found);
          // Reload audio for new selection
          this.preloadAudio();
          // Update the difficulty screen song title display
          const titleEl = document.querySelector('.song-title-small');
          if (titleEl) titleEl.textContent = 'â« ' + found.title + ' â«';
        }
      });
    });

    // ---- Song Select: SELECT button goes to difficulty ----
    document.getElementById('btn-song-select').addEventListener('click', () => {
      document.getElementById('song-select-screen').style.display = 'none';
      document.getElementById('difficulty-screen').style.display = 'flex';
    });

    // ---- Difficulty Screen: difficulty buttons start game ----
    document.getElementById('btn-beginner').addEventListener('click', () => {
      document.getElementById('difficulty-screen').style.display = 'none';
      this.startGame('beginner');
    });
    document.getElementById('btn-easy').addEventListener('click', () => {
      document.getElementById('difficulty-screen').style.display = 'none';
      this.startGame('easy');
    });
    document.getElementById('btn-hard').addEventListener('click', () => {
      document.getElementById('difficulty-screen').style.display = 'none';
      this.startGame('hard');
    });

    // ---- Difficulty back button ----
    document.getElementById('btn-diff-back').addEventListener('click', () => {
      document.getElementById('difficulty-screen').style.display = 'none';
      document.getElementById('song-select-screen').style.display = 'flex';
    });

    // ---- Results: Play Again ----
    document.getElementById('restart-btn').addEventListener('click', () => {
      document.getElementById('results-screen').style.display = 'none';
      document.getElementById('difficulty-screen').style.display = 'flex';
    });

    // ---- Results: Back to Title ----
    document.getElementById('btn-title-btn').addEventListener('click', () => {
      document.getElementById('results-screen').style.display = 'none';
      document.getElementById('title-screen').style.display = 'flex';
    });
  }

  async startGame(difficulty) {
    this.difficulty = difficulty;
    document.getElementById('difficulty-label').textContent = difficulty.toUpperCase();

    // Rebuild CONFIG from active song (in case song was changed on select screen)
    CONFIG = buildConfig(_activeSong);

    // Generate beatmap for selected difficulty
    this.beatmap = generateBeatmap(difficulty, _activeSong);
    this.totalNotes = this.beatmap.length;
    this.activeNotes = [];
    this.nextNoteIndex = 0;

    // Configure difficulty modifiers
    // Beginner: all 4 lanes visible, but lane 0 (A/Bass) is a bonus lane â misses don't count
    this.bonusLane = (difficulty === 'beginner') ? 0 : -1;
    this.activeLaneCount = 4;
    this.activeLaneKeys = CONFIG.LANE_KEYS;
    this.activeLaneNames = CONFIG.LANE_NAMES;
    this.activeLaneColors = CONFIG.LANE_COLORS;
    this.activeLaneGlow = CONFIG.LANE_GLOW;
    this.resize();

    // Reset state
    this.score = 0;
    this.combo = 0;
    this.maxCombo = 0;
    this.multiplier = 1;
    this.rockMeter = CONFIG.ROCK_METER_START;
    this.stats = { perfect: 0, great: 0, good: 0, miss: 0 };
    this.particles = [];
    this.keysDown = {};
    this.keyFlash = [0, 0, 0, 0];
    this.missFlash = [0, 0, 0, 0];
    this.screenShake = 0;
    this.missFlash = [0, 0, 0, 0];
    this.screenShake = 0;

    // Start video backdrop (must be within click gesture for autoplay to work)
    try {
      this.backdrop.showBand('default');
    } catch(e) { console.warn('Video backdrop init failed:', e); }
    this.lastVideoSection = null;

    // Countdown
    await this.doCountdown();

    // Start audio â stems if loaded, fallback to combined
    if (this.stemsReady) {
      this.laneActive = [true, true, true, true];
      this.playStems();
    } else if (this.audioLoaded) {
      this.audio.currentTime = 0;
      this.audio.volume = 0.7;
      try { await this.audio.play(); } catch(e) { console.log('Audio play blocked'); }
    }

    // Start game loop
    this.state = 'playing';
    this.songStartTime = performance.now();
    this.lastFrameTime = performance.now();
    this.gameLoop();
  }

  async doCountdown() {
    const el = document.getElementById('countdown');
    const counts = ['3', '2', '1', 'GO!'];
    for (let i = 0; i < counts.length; i++) {
      el.textContent = counts[i];
      el.style.opacity = '1';
      el.style.transform = 'translate(-50%, -50%) scale(1.5)';
      el.style.transition = 'none';
      await new Promise(r => setTimeout(r, 50));
      el.style.transition = 'all 0.5s ease-out';
      el.style.transform = 'translate(-50%, -50%) scale(1)';
      el.style.opacity = '0.8';
      await new Promise(r => setTimeout(r, 500));
      el.style.opacity = '0';
      await new Promise(r => setTimeout(r, i < 3 ? 200 : 100));
    }
  }

  getSongTime() {
    return performance.now() - this.songStartTime;
  }

  get lookAheadMs() {
    const pixelsToTravel = this.strikeY;
    const framesNeeded = pixelsToTravel / CONFIG.SCROLL_SPEED;
    return framesNeeded * (1000 / 60);
  }

  _updateVideoSection() {
    if (!this.backdrop) return;
    const t = this.gameTime || this.getSongTime();
    const sec = _activeSong.sections.find(s => t >= s.startMs && t < s.endMs);
    if (!sec) return;

    // Determine which video should be playing
    const key = sec.type + '_' + sec.index;
    if (key === this.lastVideoSection) {
      this.backdrop.setRockFilter(this.rockMeter / CONFIG.ROCK_METER_MAX);
      return;
    }
    this.lastVideoSection = key;

    // Refresh backdrop clips in case song changed
    this.backdrop.clips = _activeSong.videoClips;

    // Restore all stems on section change â new section = fresh start
    if (this.stemsReady) {
      this._mutedAt = {};
      this.stems.forEach((stem, i) => {
        if (i < CONFIG.LANE_COUNT) {
          stem.volume = 1.0;
          this.laneActive[i] = true;
        }
      });
    }

    // Switch video based on section type
    switch (sec.type) {
      case 'intro':
        this.backdrop.showBand('default');
        break;
      case 'verse':
        this.backdrop.showBand('default');
        break;
      case 'pre_chorus':
        this.backdrop.showLane(3); // Vox lead-in
        break;
      case 'chorus':
        this.backdrop.showBand('chorus');
        break;
      case 'post_chorus': {
        const spotlightLane = (sec.index || 0) % 4;
        this.backdrop.showLane(spotlightLane);
        break;
      }
      case 'bridge':
        this.backdrop.showBand('default');
        break;
      case 'breakdown':
        this.backdrop.showLane(1); // Bonecrush â heavy drums
        break;
      case 'break':
        this.backdrop.showLane(1);
        break;
      case 'outro':
        this.backdrop.showBand('outro');
        break;
      default:
        this.backdrop.showBand('default');
    }

    this.backdrop.setRockFilter(this.rockMeter / CONFIG.ROCK_METER_MAX);
  }

  checkHit(lane) {
    const songTime = this.getSongTime();
    let bestNote = null;
    let bestDelta = Infinity;

    for (const note of this.activeNotes) {
      if (note.lane !== lane || note.hit || note.missed) continue;
      const delta = Math.abs(songTime - note.time);
      if (delta < bestDelta) {
        bestDelta = delta;
        bestNote = note;
      }
    }

    if (bestNote && bestDelta <= CONFIG.GOOD_WINDOW) {
      bestNote.hit = true;
      bestNote.hitTime = performance.now();
      let rating, points;

      if (bestDelta <= CONFIG.PERFECT_WINDOW) {
        rating = 'PERFECT'; points = CONFIG.PERFECT_SCORE; this.stats.perfect++;
      } else if (bestDelta <= CONFIG.GREAT_WINDOW) {
        rating = 'GREAT'; points = CONFIG.GREAT_SCORE; this.stats.great++;
      } else {
        rating = 'GOOD'; points = CONFIG.GOOD_SCORE; this.stats.good++;
      }

      // Restore stem on successful hit (re-activates muted lane)
      if (this.stemsReady) { this.setStemActive(lane, true); }

      const isBonus = (lane === this.bonusLane && this.bonusLane >= 0);
      if (!isBonus) {
        this.combo++;
        if (this.combo > this.maxCombo) this.maxCombo = this.combo;
        this.updateMultiplier();
      }
      this.score += isBonus ? Math.floor(points * 0.5) : points * this.multiplier;
      this.rockMeter = Math.min(CONFIG.ROCK_METER_MAX, this.rockMeter + CONFIG.ROCK_HIT_GAIN);

      this.showHitFeedback(isBonus ? 'BONUS!' : rating, lane);
      this.spawnHitParticles(lane, rating);
    }
  }

  onMiss(note) {
    note.missed = true;
    // Bonus lane (beginner) â note fades out, no penalty, no feedback
    if (note.lane === this.bonusLane && this.bonusLane >= 0) {
      return;
    }
    this.stats.miss++;
    this.combo = 0;
    this.multiplier = 1;
    this.rockMeter = Math.max(0, this.rockMeter - CONFIG.ROCK_MISS_PENALTY);
    // Mute stem for this lane (vocals exempt)
    if (this.stemsReady) { this.setStemActive(note.lane, false); }
    // Visual: red lane flash, screen shake, miss particles
    this.missFlash[note.lane] = 1;
    this.screenShake = 8;
    this.spawnMissParticles(note.lane, note.y);
    this.showHitFeedback('MISS', note.lane);
  }

  spawnMissParticles(lane, y) {
    const x = this.lanes[lane].x;
    const hitY = Math.min(y, this.strikeY);
    // Burst of red X shards downward
    for (let i = 0; i < 10; i++) {
      this.particles.push({
        x: x + (Math.random() - 0.5) * 30,
        y: hitY,
        vx: (Math.random() - 0.5) * 5,
        vy: Math.random() * 4 + 1,
        life: 1,
        decay: 0.04 + Math.random() * 0.03,
        size: 3 + Math.random() * 4,
        color: '#f00',
      });
    }
  }

  updateMultiplier() {
    let mult = 1;
    for (let i = 0; i < CONFIG.MULT_THRESHOLDS.length; i++) {
      if (this.combo >= CONFIG.MULT_THRESHOLDS[i]) mult = i + 2;
    }
    this.multiplier = Math.min(mult, CONFIG.MAX_MULTIPLIER);
  }

  showHitFeedback(rating, lane) {
    const fb = document.getElementById('hit-feedback');
    fb.textContent = rating;
    fb.className = rating === 'BONUS!' ? 'good' : rating.toLowerCase();
    if (rating === 'BONUS!') fb.style.color = '#ffa500';
    else fb.style.color = '';
    fb.style.opacity = '1';
    fb.style.left = this.lanes[lane].x + 'px';
    fb.style.top = (this.strikeY - 60) + 'px';
    // Miss gets a bigger, shakier entrance
    const isMiss = rating === 'MISS';
    fb.style.transform = isMiss
      ? 'translate(-50%, -50%) scale(1.6)'
      : 'translate(-50%, -50%) scale(1.2)';
    fb.style.transition = 'none';

    requestAnimationFrame(() => {
      fb.style.transition = isMiss ? 'all 0.5s ease-out' : 'all 0.4s ease-out';
      fb.style.transform = isMiss
        ? 'translate(-50%, -30%) scale(0.9)'
        : 'translate(-50%, -80%) scale(1)';
      fb.style.opacity = '0';
    });
  }

  spawnHitParticles(lane, rating) {
    const x = this.lanes[lane].x;
    const y = this.strikeY;
    const color = CONFIG.LANE_COLORS[lane];
    const count = rating === 'PERFECT' ? 18 : rating === 'GREAT' ? 12 : 8;
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count + (Math.random() - 0.5) * 0.5;
      const speed = 2 + Math.random() * 5;
      this.particles.push({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed - 2,
        life: 1,
        decay: 0.015 + Math.random() * 0.02,
        size: 2 + Math.random() * 4,
        color,
      });
    }
  }

  // ============================================================
  // GAME LOOP
  // ============================================================
  gameLoop() {
    if (this.state !== 'playing') return;

    const now = performance.now();
    this.lastFrameTime = now;
    const songTime = this.getSongTime();

    // End check
    if (songTime > CONFIG.SONG_DURATION * 1000 + 2000) {
      this.endGame();
      return;
    }

    // Spawn notes within look-ahead
    while (this.nextNoteIndex < this.beatmap.length) {
      const note = this.beatmap[this.nextNoteIndex];
      if (note.time <= songTime + this.lookAheadMs) {
        this.activeNotes.push({ ...note, hit: false, missed: false, hitTime: 0, y: 0 });
        this.nextNoteIndex++;
      } else break;
    }

    // Update note positions
    for (const note of this.activeNotes) {
      const timeUntilHit = note.time - songTime;
      const progressRatio = 1 - (timeUntilHit / this.lookAheadMs);
      note.y = progressRatio * this.strikeY;

      if (!note.hit && !note.missed && songTime - note.time > CONFIG.GOOD_WINDOW) {
        this.onMiss(note);
      }
    }

    // Remove dead notes
    this.activeNotes = this.activeNotes.filter(n => {
      if (n.hit) return (now - n.hitTime) < 300;
      if (n.missed) return n.y < this.H + 50;
      return true;
    });

    // Update particles
    this.particles = this.particles.filter(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.12;
      p.life -= p.decay;
      return p.life > 0;
    });

    // Key flash + miss flash decay
    for (let i = 0; i < CONFIG.LANE_COUNT; i++) {
      if (this.keyFlash[i] !== undefined) this.keyFlash[i] *= 0.85;
      if (this.missFlash[i] !== undefined) this.missFlash[i] *= 0.80;
    }
    // Screen shake decay
    this.screenShake *= 0.82;

    // Update video backdrop (section switch + rock meter filter)
    this._updateVideoSection();
    this._tickStemDecay();

    this.render(songTime);
    this.updateHUD(songTime);
    requestAnimationFrame(() => this.gameLoop());
  }

  // ============================================================
  // RENDERING
  // ============================================================
  render(songTime) {
    const ctx = this.ctx;
    const W = this.W;
    const H = this.H;
    ctx.clearRect(0, 0, W, H);

    // Screen shake
    ctx.save();
    if (this.screenShake > 0.5) {
      ctx.translate(
        (Math.random() - 0.5) * this.screenShake,
        (Math.random() - 0.5) * this.screenShake
      );
    }

    // Lane backgrounds
    for (let i = 0; i < CONFIG.LANE_COUNT; i++) {
      const lane = this.lanes[i];

      // Alternating lane shade
      ctx.fillStyle = i % 2 === 0 ? 'rgba(255,255,255,0.02)' : 'rgba(255,255,255,0.04)';
      ctx.fillRect(lane.left, 0, lane.width, H);

      // Lane dividers
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(lane.left, 0);
      ctx.lineTo(lane.left, H);
      ctx.stroke();

      // Key press glow
      if (this.keyFlash[i] > 0.05) {
        const grad = ctx.createLinearGradient(lane.left, this.strikeY, lane.left, this.strikeY - 250);
        grad.addColorStop(0, (this.activeLaneGlow || CONFIG.LANE_GLOW)[i] + (this.keyFlash[i] * 0.4).toFixed(2) + ')');
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.fillRect(lane.left, this.strikeY - 250, lane.width, 250);
      }
    }

    // Miss flash â red lane overlay
    for (let i = 0; i < CONFIG.LANE_COUNT; i++) {
      if (this.missFlash[i] > 0.05) {
        const lane = this.lanes[i];
        const mgrad = ctx.createLinearGradient(lane.left, this.strikeY, lane.left, this.strikeY - 300);
        mgrad.addColorStop(0, 'rgba(255,0,0,' + (this.missFlash[i] * 0.55).toFixed(2) + ')');
        mgrad.addColorStop(1, 'transparent');
        ctx.fillStyle = mgrad;
        ctx.fillRect(lane.left, this.strikeY - 300, lane.width, 300);
        // Red border on the receptor
        ctx.beginPath();
        ctx.arc(lane.x, this.strikeY, CONFIG.NOTE_RADIUS + 8, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255,0,0,' + this.missFlash[i].toFixed(2) + ')';
        ctx.lineWidth = 3;
        ctx.stroke();
      }
    }

    // Outer lane borders
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(this.laneLeft, 0);
    ctx.lineTo(this.laneLeft, H);
    ctx.moveTo(this.laneRight, 0);
    ctx.lineTo(this.laneRight, H);
    ctx.stroke();

    // Strike zone
    const szGrad = ctx.createLinearGradient(this.laneLeft, this.strikeY - 3, this.laneLeft, this.strikeY + 3);
    szGrad.addColorStop(0, 'rgba(255,255,255,0.0)');
    szGrad.addColorStop(0.5, 'rgba(255,255,255,0.35)');
    szGrad.addColorStop(1, 'rgba(255,255,255,0.0)');
    ctx.fillStyle = szGrad;
    ctx.fillRect(this.laneLeft, this.strikeY - 3, this.laneRight - this.laneLeft, 6);

    // Receptors
    for (let i = 0; i < CONFIG.LANE_COUNT; i++) {
      const lane = this.lanes[i];
      const pressed = this.keysDown[i];

      // Outer ring
      ctx.beginPath();
      ctx.arc(lane.x, this.strikeY, CONFIG.NOTE_RADIUS + 4, 0, Math.PI * 2);
      ctx.strokeStyle = pressed ? (this.activeLaneColors || CONFIG.LANE_COLORS)[i] : 'rgba(255,255,255,0.15)';
      ctx.lineWidth = pressed ? 3 : 1.5;
      ctx.stroke();

      // Inner glow when pressed
      if (pressed) {
        ctx.beginPath();
        ctx.arc(lane.x, this.strikeY, CONFIG.NOTE_RADIUS + 2, 0, Math.PI * 2);
        ctx.fillStyle = (this.activeLaneGlow || CONFIG.LANE_GLOW)[i] + '0.25)';
        ctx.fill();
      }

      // Key label
      ctx.font = '14px "Press Start 2P"';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = pressed ? (this.activeLaneColors || CONFIG.LANE_COLORS)[i] : 'rgba(255,255,255,0.25)';
      ctx.fillText(((this.activeLaneKeys || CONFIG.LANE_KEYS)[i] || '').toUpperCase(), lane.x, this.strikeY);
      // Bonus lane badge
      if (i === this.bonusLane && this.bonusLane >= 0) {
        ctx.font = '8px "Press Start 2P"';
        ctx.fillStyle = 'rgba(255,165,0,0.7)';
        ctx.fillText('FREE', lane.x, this.strikeY + 18);
      }
    }

    // Notes
    for (const note of this.activeNotes) {
      const lane = this.lanes[note.lane];
      const color = (this.activeLaneColors || CONFIG.LANE_COLORS)[note.lane];

      if (note.hit) {
        // Hit note â expanding ring animation
        const elapsed = performance.now() - note.hitTime;
        const progress = elapsed / 300;
        const radius = CONFIG.NOTE_RADIUS + progress * 30;
        const alpha = 1 - progress;
        ctx.beginPath();
        ctx.arc(lane.x, this.strikeY, radius, 0, Math.PI * 2);
        ctx.strokeStyle = color;
        ctx.globalAlpha = alpha * 0.6;
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.globalAlpha = 1;
        continue;
      }

      const alpha = note.missed ? 0.25 : 1;

      // Glow
      if (!note.missed) {
        ctx.beginPath();
        ctx.arc(lane.x, note.y, CONFIG.NOTE_RADIUS + 10, 0, Math.PI * 2);
        const glow = ctx.createRadialGradient(lane.x, note.y, 0, lane.x, note.y, CONFIG.NOTE_RADIUS + 10);
        glow.addColorStop(0, (this.activeLaneGlow || CONFIG.LANE_GLOW)[note.lane] + '0.35)');
        glow.addColorStop(1, 'transparent');
        ctx.fillStyle = glow;
        ctx.fill();
      }

      // Note body
      ctx.beginPath();
      ctx.arc(lane.x, note.y, CONFIG.NOTE_RADIUS, 0, Math.PI * 2);
      ctx.fillStyle = note.missed ? 'rgba(80,80,80,0.3)' : color;
      ctx.globalAlpha = alpha;
      ctx.fill();
      ctx.globalAlpha = 1;

      // Border
      ctx.strokeStyle = note.missed ? 'rgba(255,0,0,0.2)' : 'rgba(255,255,255,0.5)';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Inner shine
      if (!note.missed) {
        ctx.beginPath();
        ctx.arc(lane.x - 5, note.y - 5, CONFIG.NOTE_RADIUS * 0.35, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fill();
      }
    }

    // Particles
    for (const p of this.particles) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
      ctx.fillStyle = p.color;
      ctx.globalAlpha = p.life * 0.8;
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Lane names at bottom
    ctx.font = '11px "Permanent Marker"';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    for (let i = 0; i < CONFIG.LANE_COUNT; i++) {
      ctx.fillStyle = (this.activeLaneColors || CONFIG.LANE_COLORS)[i];
      ctx.globalAlpha = 0.4;
      ctx.fillText((this.activeLaneNames || CONFIG.LANE_NAMES)[i], this.lanes[i].x, this.strikeY + 32);
    }
    ctx.globalAlpha = 1;

    ctx.restore();

    // Beat pulse (subtle screen flash on each beat at high combo)
    if (this.combo > 20) {
      const beatPhase = (songTime % (60000 / _activeSong.bpm)) / (60000 / _activeSong.bpm);
      if (beatPhase < 0.08) {
        const intensity = 0.04 * (1 - beatPhase / 0.08) * Math.min(this.combo / 50, 1);
        ctx.fillStyle = `rgba(0,255,255,${intensity})`;
        ctx.fillRect(0, 0, W, H);
      }
    }
  }

  updateHUD(songTime) {
    document.getElementById('score-value').textContent = this.score.toLocaleString();

    const comboEl = document.getElementById('combo-display');
    if (this.combo > 1) {
      comboEl.classList.add('active');
      document.getElementById('combo-count').textContent = this.combo;
    } else {
      comboEl.classList.remove('active');
    }

    document.getElementById('multiplier-display').textContent =
      this.multiplier > 1 ? this.multiplier + 'x' : '';

    const progress = Math.max(0, Math.min(100, (songTime / (CONFIG.SONG_DURATION * 1000)) * 100));
    document.getElementById('progress-bar').style.width = progress + '%';

    const rm = document.getElementById('rock-meter');
    rm.style.height = this.rockMeter + '%';
    if (this.rockMeter > 70) rm.style.background = 'linear-gradient(0deg, #0f0, #0ff)';
    else if (this.rockMeter > 40) rm.style.background = 'linear-gradient(0deg, #ff0, #0f0)';
    else rm.style.background = 'linear-gradient(0deg, #f00, #ff0)';
  }

  endGame() {
    this.state = 'results';
    if (this.stemsReady) {
      this.stopStems();
    } else if (this.audio) {
      this.audio.pause(); this.audio.currentTime = 0;
    }

    const totalHits = this.stats.perfect + this.stats.great + this.stats.good;
    const totalJudged = totalHits + this.stats.miss;
    const accuracy = totalJudged > 0
      ? ((this.stats.perfect * 100 + this.stats.great * 80 + this.stats.good * 50) / (totalJudged * 100) * 100)
      : 0;

    let grade, gradeClass;
    if (accuracy >= 95) { grade = 'S'; gradeClass = 'grade-s'; }
    else if (accuracy >= 85) { grade = 'A'; gradeClass = 'grade-a'; }
    else if (accuracy >= 70) { grade = 'B'; gradeClass = 'grade-b'; }
    else if (accuracy >= 50) { grade = 'C'; gradeClass = 'grade-c'; }
    else { grade = 'F'; gradeClass = 'grade-f'; }

    document.getElementById('results-screen').style.display = 'flex';
    document.getElementById('result-grade').textContent = grade;
    document.getElementById('result-grade').className = 'grade ' + gradeClass;
    document.getElementById('result-score').textContent = this.score.toLocaleString();
    document.getElementById('result-combo').textContent = this.maxCombo;
    document.getElementById('result-perfect').textContent = this.stats.perfect;
    document.getElementById('result-great').textContent = this.stats.great;
    document.getElementById('result-good').textContent = this.stats.good;
    document.getElementById('result-miss').textContent = this.stats.miss;
    document.getElementById('result-accuracy').textContent = accuracy.toFixed(1) + '%';
    jrShowLeaderboard(this.score);
  }
}


const firebaseConfig = {
  apiKey: "AIzaSyCO1jJVET2TBOMfrJD839jxU0ENYShQ1Fg",
  authDomain: "pitstop-wall.firebaseapp.com",
  databaseURL: "https://pitstop-wall-default-rtdb.firebaseio.com",
  projectId: "pitstop-wall",
  storageBucket: "pitstop-wall.firebasestorage.app",
  messagingSenderId: "767668528451",
  appId: "1:767668528451:web:107ef2d7230f7560fdfbf6"
};
firebase.initializeApp(firebaseConfig);
const jrHsRef = firebase.database().ref('highscores/jurn-rhythm');
let jrCachedScores = [];
let jrMyEntry = null;

jrHsRef.orderByChild('score').limitToLast(10).on('value', snap => {
  const d = snap.val();
  jrCachedScores = d
    ? Object.entries(d).map(([k,v]) => ({...v, key:k})).sort((a,b) => b.score - a.score)
    : [];
});

function jrIsHighScore(s) {
  return jrCachedScores.length < 10 || s > (jrCachedScores[jrCachedScores.length-1]?.score || 0);
}

function jrSaveScore(name, s) {
  jrMyEntry = { name, score: s, timestamp: Date.now() };
  jrHsRef.push({ name, score: s, timestamp: Date.now() });
}

function jrRenderLeaderboard() {
  const rows = document.getElementById('jrLbRows');
  const medals = ['\u{1F947}','\u{1F948}','\u{1F949}'];
  const colors = ['#ffd700','#c0c0c0','#cd7f32'];
  rows.innerHTML = jrCachedScores.slice(0,10).map((s,i) => {
    const isMe = jrMyEntry && s.name===jrMyEntry.name && s.score===jrMyEntry.score;
    const color = isMe ? '#0ff' : (colors[i] || 'rgba(255,255,255,0.55)');
    const rank = medals[i] || ((i+1)+'.');
    return '<div style="display:flex;justify-content:space-between;padding:2px 4px;font-size:0.9rem;color:'+color+(isMe?';font-weight:bold':'')+'">'
      + '<span>'+rank+' '+(s.name||'???')+'</span><span>'+s.score.toLocaleString()+'</span></div>';
  }).join('');
  document.getElementById('jrLeaderboard').style.display = 'block';
}

function jrShowLeaderboard(finalScore) {
  document.getElementById('jrInitialsSection').style.display = 'none';
  document.getElementById('jrLeaderboard').style.display = 'none';
  jrMyEntry = null;

  if (jrIsHighScore(finalScore)) {
    document.getElementById('jrInitialsSection').style.display = 'block';
    const input = document.getElementById('jrInitialsInput');
    input.value = '';
    setTimeout(() => input.focus(), 500);
    const submitFn = () => {
      const name = input.value.toUpperCase().replace(/[^A-Z]/g,'').slice(0,3);
      if (!name) return;
      jrSaveScore(name, finalScore);
      document.getElementById('jrInitialsSection').style.display = 'none';
      setTimeout(() => jrRenderLeaderboard(), 600);
    };
    document.getElementById('jrInitialsSubmit').onclick = submitFn;
    input.onkeydown = e => { if (e.key==='Enter') submitFn(); };
  } else {
    jrRenderLeaderboard();
  }
}

// Init
document.addEventListener('DOMContentLoaded', () => {
  window.game = new JURNRhythmGame();
});
</script>
</body>
</html>