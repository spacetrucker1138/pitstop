<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Gut Stackers ‚Äî Afterverse Arcade</title>
<link href="https://fonts.googleapis.com/css2?family=Creepster&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0a0a; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
canvas { display: block; max-width: 100vw; max-height: 100vh; object-fit: contain; touch-action: none; background: transparent; }
</style>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
</head>
<body>
<video id="bg-video" autoplay muted loop playsinline style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:-1;opacity:0.3;object-fit:contain;pointer-events:none;">
  <source src="gutstackers_video.mp4" type="video/mp4">
</video>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = 440, H = 700;
canvas.width = W; canvas.height = H;

const COLS = 10, ROWS = 20, CELL = 30;
const BOARD_X = (W - COLS * CELL) / 2, BOARD_Y = (H - ROWS * CELL) / 2 + 20;

// Pieces (standard Tetris shapes)
const SHAPES = [
  [[1,1,1,1]],           // I
  [[1,1],[1,1]],         // O
  [[0,1,0],[1,1,1]],    // T
  [[1,0,0],[1,1,1]],    // J
  [[0,0,1],[1,1,1]],    // L
  [[0,1,1],[1,1,0]],    // S
  [[1,1,0],[0,1,1]]     // Z
];

const COLORS = [
  '#a855f7', // I - purple
  '#7c3aed', // O - deep purple
  '#c084fc', // T - light purple
  '#6d28d9', // J - violet
  '#8b5cf6', // L - medium purple
  '#d946ef', // S - fuchsia
  '#a21caf'  // Z - dark fuchsia
];

const SKULL_EMOJIS = ['üíÄ','‚ò†Ô∏è','ü¶¥','‚ö∞Ô∏è','ü™¶','üëª','üï∑Ô∏è'];

// Logo (stored for future use)
const logoImage = new Image();
logoImage.src = 'gut_logo.png';
let logoReady = false;
logoImage.onload = function() { logoReady = true; };

// Organ tile texture
const organTile = new Image();
organTile.src = 'organ_tile.png';
let tintedTiles = []; // pre-rendered tinted tiles per piece type
let tilesReady = false;

// Organ color tints (hue-shifted body horror palette)
const ORGAN_TINTS = [
  { r: 180, g: 40, b: 40 },   // I - Deep blood red
  { r: 120, g: 40, b: 160 },  // O - Bruised purple
  { r: 220, g: 100, b: 140 }, // T - Raw pink flesh (closest to original)
  { r: 50, g: 130, b: 60 },   // J - Bile green (necrotic)
  { r: 170, g: 160, b: 40 },  // L - Infected yellow-green
  { r: 200, g: 40, b: 120 },  // S - Arterial magenta
  { r: 100, g: 30, b: 130 },  // Z - Venous dark purple
];

organTile.onload = function() {
  // Pre-render tinted versions of the tile for each piece type
  for (let i = 0; i < ORGAN_TINTS.length; i++) {
    const tc = document.createElement('canvas');
    tc.width = CELL; tc.height = CELL;
    const tctx = tc.getContext('2d');
    // Draw the organ tile scaled to cell size
    tctx.drawImage(organTile, 0, 0, CELL, CELL);
    // Apply color tint using multiply blend
    tctx.globalCompositeOperation = 'multiply';
    const t = ORGAN_TINTS[i];
    tctx.fillStyle = `rgb(${t.r},${t.g},${t.b})`;
    tctx.fillRect(0, 0, CELL, CELL);
    // Restore original alpha from the base image
    tctx.globalCompositeOperation = 'destination-in';
    tctx.drawImage(organTile, 0, 0, CELL, CELL);
    // Add slight highlight on top for wet look
    tctx.globalCompositeOperation = 'screen';
    tctx.fillStyle = 'rgba(255,200,200,0.08)';
    tctx.fillRect(0, 0, CELL, CELL/3);
    tintedTiles.push(tc);
  }
  tilesReady = true;
};

// Gore drip system - liquid that flows down from locked pieces
let goreDrips = [];
function spawnGoreDrips(lockedCells) {
  for (const cell of lockedCells) {
    // 90% chance per cell to spawn a drip (TRIPLE GORE)
    if (Math.random() > 0.9) continue;
    // Spawn 2-3 drips per cell for maximum slushie
    const dripCount = 2 + Math.floor(Math.random() * 2);
    const tint = ORGAN_TINTS[cell.type];
    for (let di = 0; di < dripCount; di++) {
      // Random gore color based on piece tint but shifted toward red/dark
      const r = Math.min(255, tint.r + Math.floor(Math.random()*80));
      const g = Math.max(0, tint.g - Math.floor(Math.random()*40));
      const b = Math.max(0, tint.b - Math.floor(Math.random()*30));
      const alpha = 0.6 + Math.random() * 0.4;
      goreDrips.push({
        x: BOARD_X + cell.col * CELL + Math.random() * CELL,
        y: BOARD_Y + cell.row * CELL + CELL * Math.random() * 0.5,
        vy: 0.4 + Math.random() * 1.2,
        width: 2 + Math.random() * 5,
        length: 12 + Math.random() * 30,
        color: `rgba(${r},${g},${b},`,
        alpha: alpha,
        fadeRate: 0.002 + Math.random() * 0.003,
        wobble: Math.random() * Math.PI * 2,
        wobbleSpeed: 0.02 + Math.random() * 0.04
      });
    }
  }
}

// Audio
class AudioMgr {
  constructor() {
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    this.muted = false;
    this.volume = 0.4;
  }
  resume() { if (this.ctx.state === 'suspended') this.ctx.resume(); }
  play(freq, dur, type='square', vol=0.3) {
    if (this.muted) return;
    const o = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = vol * this.volume;
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
    o.connect(g); g.connect(this.ctx.destination);
    o.start(); o.stop(this.ctx.currentTime + dur);
  }
  drop() {
    // Wet smoosh/splat sound - layered noise + low thud
    if (this.muted) return;
    const ctx = this.ctx;
    const now = ctx.currentTime;
    const vol = this.volume;

    // Layer 1: Noise burst (the wet "splat" texture)
    const bufLen = ctx.sampleRate * 0.12;
    const buf = ctx.createBuffer(1, bufLen, ctx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < bufLen; i++) {
      // Shaped noise - loud at start, dies fast
      const env = Math.exp(-i / (bufLen * 0.15));
      data[i] = (Math.random() * 2 - 1) * env;
    }
    const noise = ctx.createBufferSource();
    noise.buffer = buf;
    // Lowpass filter gives it a "wet" quality instead of harsh static
    const lpf = ctx.createBiquadFilter();
    lpf.type = 'lowpass';
    lpf.frequency.value = 1200;
    lpf.frequency.exponentialRampToValueAtTime(300, now + 0.1);
    const nGain = ctx.createGain();
    nGain.gain.value = 0.35 * vol;
    nGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
    noise.connect(lpf); lpf.connect(nGain); nGain.connect(ctx.destination);
    noise.start(now); noise.stop(now + 0.15);

    // Layer 2: Low thud (the "smoosh" body)
    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = 120;
    osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
    const oGain = ctx.createGain();
    oGain.gain.value = 0.3 * vol;
    oGain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
    osc.connect(oGain); oGain.connect(ctx.destination);
    osc.start(now); osc.stop(now + 0.12);

    // Layer 3: Quick high "squelch" 
    const sq = ctx.createOscillator();
    sq.type = 'sawtooth';
    sq.frequency.value = 800;
    sq.frequency.exponentialRampToValueAtTime(200, now + 0.06);
    const sqGain = ctx.createGain();
    sqGain.gain.value = 0.12 * vol;
    sqGain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
    const sqFilter = ctx.createBiquadFilter();
    sqFilter.type = 'bandpass';
    sqFilter.frequency.value = 600;
    sqFilter.Q.value = 2;
    sq.connect(sqFilter); sqFilter.connect(sqGain); sqGain.connect(ctx.destination);
    sq.start(now); sq.stop(now + 0.08);
  }
  clear() { this.play(600, 0.15, 'square', 0.5); setTimeout(() => this.play(800, 0.15, 'square', 0.5), 100); }
  tetris() { 
    [600,700,800,1000].forEach((f,i) => setTimeout(() => this.play(f, 0.15, 'square', 0.6), i*80));
  }
  rotate() { this.play(400, 0.05, 'triangle', 0.2); }
  gameOver() {
    [300,250,200,150].forEach((f,i) => setTimeout(() => this.play(f, 0.3, 'sawtooth', 0.5), i*200));
  }
  start() {
    [330,440,550].forEach((f,i) => setTimeout(() => this.play(f, 0.1, 'square', 0.4), i*100));
  }
}
const audio = new AudioMgr();

// Background Music
const bgMusic = new Audio('hauntedsong2.mp3');
bgMusic.loop = true;
bgMusic.volume = 0.35;
let musicStarted = false;

function updateMusic() {
  if (audio.muted) {
    bgMusic.volume = 0;
  } else {
    bgMusic.volume = 0.35;
  }
  if (state === 'playing') {
    if (bgMusic.paused) {
      bgMusic.play().catch(() => {});
    }
    musicStarted = true;
  } else if (state === 'gameover') {
    bgMusic.pause();
    bgMusic.currentTime = 0;
    musicStarted = false;
  } else if (state === 'title') {
    bgMusic.pause();
    bgMusic.currentTime = 0;
    musicStarted = false;
  } else if (state === 'paused') {
    bgMusic.pause();
  }
}


// State
let state = 'title';
let board = [];
let piece = null, nextPiece = null;
let pieceX, pieceY, pieceType;
let score = 0, level = 1, lines = 0, bestScore = 0;
let dropInterval = 48, dropTimer = 0;
let particles = [];
let countdownNum = 3, countdownTimer = 0;

// Load best
// Firebase High Scores
const firebaseConfig = {
  apiKey: "AIzaSyCO1jJVET2TBOMfrJD839jxU0ENYShQ1Fg",
  authDomain: "pitstop-wall.firebaseapp.com",
  databaseURL: "https://pitstop-wall-default-rtdb.firebaseio.com",
  projectId: "pitstop-wall",
  storageBucket: "pitstop-wall.firebasestorage.app",
  messagingSenderId: "767668528451",
  appId: "1:767668528451:web:107ef2d7230f7560fdfbf6"
};
firebase.initializeApp(firebaseConfig);
const hsRef = firebase.database().ref('highscores/gutstackers');
let cachedScores = [];

hsRef.orderByChild('score').limitToLast(10).on('value', snap => {
  const data = snap.val();
  cachedScores = data ? Object.values(data).sort((a, b) => b.score - a.score) : [];
  bestScore = cachedScores.length > 0 ? cachedScores[0].score : 0;
});

function fbIsHighScore(sc) {
  return sc > 0 && (cachedScores.length < 10 || sc > (cachedScores[cachedScores.length-1]?.score || 0));
}
function fbSaveHighScore(name, sc) {
  hsRef.push({ name: name, score: sc, level: level, timestamp: Date.now() });
}

let hsInitials = '';
let hsCursorBlink = 0;
let hsCurrentScore = 0

function createBoard() {
  board = [];
  for (let r = 0; r < ROWS; r++) {
    board.push(new Array(COLS).fill(0));
  }
}

function randomPiece() {
  const t = Math.floor(Math.random() * SHAPES.length);
  return { shape: SHAPES[t].map(r => [...r]), type: t };
}

function spawnPiece() {
  piece = nextPiece || randomPiece();
  nextPiece = randomPiece();
  pieceType = piece.type;
  pieceX = Math.floor((COLS - piece.shape[0].length) / 2);
  pieceY = 0;
  if (collides(piece.shape, pieceX, pieceY)) {
    audio.gameOver();
    hsCurrentScore = score;
    if (fbIsHighScore(score)) {
      state = 'highscore_entry';
      hsInitials = '';
      hsCursorBlink = 0;
    } else {
      state = 'gameover';
    }
    if (score > bestScore) { bestScore = score; }
  }
}

function collides(shape, px, py) {
  for (let r = 0; r < shape.length; r++) {
    for (let c = 0; c < shape[r].length; c++) {
      if (!shape[r][c]) continue;
      const nx = px + c, ny = py + r;
      if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
      if (ny >= 0 && board[ny][nx]) return true;
    }
  }
  return false;
}

function lockPiece() {
  for (let r = 0; r < piece.shape.length; r++) {
    for (let c = 0; c < piece.shape[r].length; c++) {
      if (!piece.shape[r][c]) continue;
      const ny = pieceY + r, nx = pieceX + c;
      if (ny >= 0 && ny < ROWS && nx >= 0 && nx < COLS) {
        board[ny][nx] = pieceType + 1;
      }
    }
  }
  audio.drop();
  // Spawn gore drips from newly locked cells
  const lockedCells = [];
  for (let r = 0; r < piece.shape.length; r++) {
    for (let c = 0; c < piece.shape[r].length; c++) {
      if (!piece.shape[r][c]) continue;
      const ny = pieceY + r, nx = pieceX + c;
      if (ny >= 0 && ny < ROWS && nx >= 0 && nx < COLS) {
        lockedCells.push({ col: nx, row: ny, type: pieceType });
      }
    }
  }
  spawnGoreDrips(lockedCells);
  clearLines();
  spawnPiece();
}

function clearLines() {
  let cleared = 0;
  for (let r = ROWS - 1; r >= 0; r--) {
    if (board[r].every(c => c > 0)) {
      // Spawn gore splash particles for cleared line
      for (let c = 0; c < COLS; c++) {
        const px = BOARD_X + c * CELL + CELL/2;
        const py = BOARD_Y + r * CELL + CELL/2;
        const tIdx = board[r][c] - 1;
        const tint = ORGAN_TINTS[tIdx] || ORGAN_TINTS[0];
        for (let i = 0; i < 4; i++) {
          const rr = Math.min(255, tint.r + Math.floor(Math.random()*80));
          const gg = Math.max(0, tint.g - Math.floor(Math.random()*20));
          const bb = Math.max(0, tint.b - Math.floor(Math.random()*20));
          particles.push({
            x: px, y: py,
            vx: (Math.random()-0.5)*10,
            vy: (Math.random()-0.5)*10 - 3,
            life: 1,
            color: `rgb(${rr},${gg},${bb})`,
            size: Math.random()*5+2,
            emoji: Math.random() > 0.6 ? SKULL_EMOJIS[Math.floor(Math.random()*SKULL_EMOJIS.length)] : null
          });
        }
        // MASSIVE gore drips from cleared line
        for (let gi = 0; gi < 3; gi++) {
          goreDrips.push({
            x: px + (Math.random()-0.5) * CELL,
            y: py,
            vy: 0.5 + Math.random() * 1.2,
            width: 2 + Math.random() * 4,
            length: 12 + Math.random() * 25,
            color: `rgba(${Math.min(255,tint.r+40)},${Math.max(0,tint.g-10)},${Math.max(0,tint.b-10)},`,
            alpha: 0.7 + Math.random() * 0.3,
            fadeRate: 0.002 + Math.random() * 0.003,
            wobble: Math.random() * Math.PI * 2,
            wobbleSpeed: 0.02 + Math.random() * 0.04
          });
        }
      }
      board.splice(r, 1);
      board.unshift(new Array(COLS).fill(0));
      cleared++;
      r++; // recheck this row
    }
  }
  if (cleared > 0) {
    const pts = [0, 100, 300, 500, 800];
    score += (pts[cleared] || 800) * level;
    lines += cleared;
    level = Math.floor(lines / 10) + 1;
    dropInterval = Math.max(4, 48 - (level - 1) * 4);
    if (cleared >= 4) audio.tetris(); else audio.clear();
  }
}

function rotatePiece() {
  const s = piece.shape;
  const rotated = s[0].map((_, c) => s.map(r => r[c]).reverse());
  if (!collides(rotated, pieceX, pieceY)) {
    piece.shape = rotated;
    audio.rotate();
  } else if (!collides(rotated, pieceX - 1, pieceY)) {
    piece.shape = rotated; pieceX--;
    audio.rotate();
  } else if (!collides(rotated, pieceX + 1, pieceY)) {
    piece.shape = rotated; pieceX++;
    audio.rotate();
  }
}

function hardDrop() {
  while (!collides(piece.shape, pieceX, pieceY + 1)) pieceY++;
  lockPiece();
}

// Input
let keys = {};
let keyTimer = {};
document.addEventListener('keydown', e => {
  if (e.key === 'm' || e.key === 'M') { audio.muted = !audio.muted; return; }
  if (state === 'title' && (e.key === 'e' || e.key === 'E' || e.key === ' ')) { startGame(); return; }
  if (state === 'highscore_entry') {
    if (e.key.length === 1 && /[a-zA-Z]/.test(e.key) && hsInitials.length < 3) {
      hsInitials += e.key.toUpperCase();
    }
    if (e.key === 'Backspace' && hsInitials.length > 0) {
      hsInitials = hsInitials.slice(0, -1);
    }
    if (e.key === 'Enter' && hsInitials.length > 0) {
      fbSaveHighScore(hsInitials, hsCurrentScore);
      state = 'highscore_display';
    }
    return;
  }
  if (state === 'highscore_display' && (e.key === 'e' || e.key === 'E' || e.key === ' ')) { state = 'title'; return; }
  if (state === 'gameover' && (e.key === 'e' || e.key === 'E' || e.key === ' ')) { state = 'title'; return; }
  if (state === 'playing' && (e.key === 'p' || e.key === 'P' || e.key === 'Escape')) { state = 'paused'; return; }
  if (state === 'paused' && (e.key === 'p' || e.key === 'P' || e.key === 'Escape')) { state = 'playing'; return; }

  if (state !== 'playing') return;
  if (e.key === 'ArrowLeft' || e.key === 'a') {
    if (!collides(piece.shape, pieceX-1, pieceY)) pieceX--;
  }
  if (e.key === 'ArrowRight' || e.key === 'd') {
    if (!collides(piece.shape, pieceX+1, pieceY)) pieceX++;
  }
  if (e.key === 'ArrowUp' || e.key === 'w') rotatePiece();
  if (e.key === 'ArrowDown' || e.key === 's') {
    if (!collides(piece.shape, pieceX, pieceY+1)) pieceY++;
  }
  if (e.key === ' ') hardDrop();
});

// Touch controls
let touchStartX = 0, touchStartY = 0, touchMoved = false;
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  audio.resume();
  if (state === 'title') { startGame(); return; }
  if (state === 'gameover' || state === 'highscore_display') { state = 'title'; return; }
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
  touchMoved = false;
});
canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  if (state !== 'playing') return;
  const dx = e.touches[0].clientX - touchStartX;
  const dy = e.touches[0].clientY - touchStartY;
  const threshold = 30;
  if (Math.abs(dx) > threshold && !touchMoved) {
    if (dx > 0 && !collides(piece.shape, pieceX+1, pieceY)) pieceX++;
    else if (dx < 0 && !collides(piece.shape, pieceX-1, pieceY)) pieceX--;
    touchStartX = e.touches[0].clientX;
    touchMoved = true;
  }
  if (dy > threshold * 2 && !touchMoved) {
    hardDrop();
    touchMoved = true;
  }
});
canvas.addEventListener('touchend', e => {
  if (!touchMoved && state === 'playing') rotatePiece();
});
canvas.addEventListener('click', () => {
  audio.resume();
  if (state === 'title') startGame();
  if (state === 'gameover' || state === 'highscore_display') state = 'title';
});

function startGame() {
  audio.resume();
  audio.start();
  createBoard();
  score = 0; level = 1; lines = 0;
  dropTimer = 0;
  particles = [];
  nextPiece = null;
  spawnPiece();
  state = 'countdown';
  countdownNum = 3;
  countdownTimer = 0;
}

// Draw cell
function drawCell(x, y, colorIdx) {
  const gx = BOARD_X + x * CELL, gy = BOARD_Y + y * CELL;

  if (tilesReady && tintedTiles[colorIdx]) {
    // Draw organ tile texture
    ctx.drawImage(tintedTiles[colorIdx], gx + 1, gy + 1, CELL - 2, CELL - 2);
    // Subtle wet highlight shimmer
    const shimmer = Math.sin(Date.now() * 0.003 + x * 0.5 + y * 0.7) * 0.04 + 0.02;
    ctx.fillStyle = `rgba(255,220,220,${shimmer})`;
    ctx.fillRect(gx + 3, gy + 3, CELL - 6, CELL/3);
  } else {
    // Fallback: gradient fill (before tile loads)
    const color = COLORS[colorIdx];
    const grad = ctx.createLinearGradient(gx, gy, gx, gy + CELL);
    grad.addColorStop(0, color);
    grad.addColorStop(1, shadeColor(color, -30));
    ctx.fillStyle = grad;
    ctx.fillRect(gx + 1, gy + 1, CELL - 2, CELL - 2);
  }
}

function shadeColor(hex, amt) {
  let r = parseInt(hex.slice(1,3),16) + amt;
  let g = parseInt(hex.slice(3,5),16) + amt;
  let b = parseInt(hex.slice(5,7),16) + amt;
  r = Math.max(0, Math.min(255, r));
  g = Math.max(0, Math.min(255, g));
  b = Math.max(0, Math.min(255, b));
  return `rgb(${r},${g},${b})`;
}

function drawMuteIndicator() {
  ctx.font = '12px monospace';
  ctx.textAlign = 'right';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText(audio.muted ? 'üîá M ‚Äî Muted' : 'üîä M ‚Äî Sound', W - 8, H - 8);
}

function drawTitle() {
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, W, H);

  const t = Date.now()/1000;

  // Floating bone emojis
  for (let i = 0; i < 6; i++) {
    ctx.font = '24px serif';
    ctx.textAlign = 'center';
    ctx.globalAlpha = 0.12;
    ctx.fillText(SKULL_EMOJIS[i % SKULL_EMOJIS.length], W*(i+1)/7, 100 + Math.sin(t+i*1.2)*30);
  }
  ctx.globalAlpha = 1;

  ctx.font = '60px Creepster';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#a855f7';
  ctx.shadowColor = '#a855f7';
  ctx.shadowBlur = 30;
  ctx.fillText('GUT STACKERS', W/2, 220);
  ctx.shadowBlur = 0;

  ctx.font = '18px Creepster';
  ctx.fillStyle = '#c084fc';
  ctx.fillText('Stack the guts. Feed the pile.', W/2, 265);

  if (cachedScores.length > 0) {
    const medals = ['ü•á', 'ü•à', 'ü•â'];
    ctx.font = '16px Creepster';
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.fillText('TOP PLAYERS', W/2, 300);
    const top3 = cachedScores.slice(0, 3);
    for (let i = 0; i < top3.length; i++) {
      ctx.fillStyle = i === 0 ? '#ffd700' : (i === 1 ? '#c0c0c0' : '#cd7f32');
      ctx.font = '15px Creepster';
      ctx.fillText(medals[i] + ' ' + (top3[i].name||'???') + ' ‚Äî ' + top3[i].score.toLocaleString(), W/2, 325 + i * 24);
    }
  } else if (bestScore > 0) {
    ctx.font = '20px Creepster';
    ctx.fillStyle = '#eab308';
    ctx.fillText('üèÜ Best: ' + bestScore, W/2, 310);
  }

  ctx.font = '16px Creepster';
  ctx.fillStyle = '#e9d5ff';
  ctx.fillText('‚Üê ‚Üí Move | ‚Üë Rotate | ‚Üì Soft Drop | Space Hard Drop', W/2, 400);
  ctx.fillText('Tap: Rotate | Swipe: Move | Swipe Down: Drop', W/2, 425);
  ctx.fillText('M ‚Äî Mute | P ‚Äî Pause', W/2, 450);

  const pulse = Math.sin(t*3)*0.3+0.7;
  ctx.globalAlpha = pulse;
  ctx.font = '28px Creepster';
  ctx.fillStyle = '#f87171';
  ctx.fillText('Press E or Tap to Start', W/2, 530);
  ctx.globalAlpha = 1;

  ctx.font = '14px Creepster';
  ctx.fillStyle = 'rgba(168,85,247,0.6)';
  ctx.fillText('‚ò† A JURN Production ‚ò†', W/2, H - 25);

  drawMuteIndicator();
}


function drawHighScoreEntry() {
  ctx.fillStyle = 'rgba(10,10,10,0.88)';
  ctx.fillRect(0, 0, W, H);

  ctx.font = '42px Creepster';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#eab308';
  ctx.shadowColor = '#eab308';
  ctx.shadowBlur = 20;
  ctx.fillText('HIGH SCORE!', W/2, 160);
  ctx.shadowBlur = 0;

  ctx.font = '24px Creepster';
  ctx.fillStyle = '#e9d5ff';
  ctx.fillText('Score: ' + hsCurrentScore, W/2, 210);

  ctx.font = '18px Creepster';
  ctx.fillStyle = '#c084fc';
  ctx.fillText('Enter your initials:', W/2, 270);

  // Draw initials boxes
  hsCursorBlink += 0.05;
  const displayStr = hsInitials.padEnd(3, '_');
  ctx.font = '40px Creepster';
  for (let i = 0; i < 3; i++) {
    const ch = displayStr[i];
    const isActive = i === hsInitials.length && ch === '_';
    const x = W/2 - 60 + i * 50;
    ctx.fillStyle = isActive ? (Math.sin(hsCursorBlink*6) > 0 ? '#00ff88' : '#0a0a0a') : '#00ff88';
    ctx.fillText(ch, x, 340);
  }

  ctx.font = '16px Creepster';
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.fillText('Press ENTER to submit', W/2, 400);

  drawMuteIndicator();
}

function drawHighScoreDisplay() {
  ctx.fillStyle = 'rgba(10,10,10,0.92)';
  ctx.fillRect(0, 0, W, H);

  ctx.font = '36px Creepster';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#a855f7';
  ctx.shadowColor = '#a855f7';
  ctx.shadowBlur = 20;
  ctx.fillText('LEADERBOARD', W/2, 100);
  ctx.shadowBlur = 0;

  const medals = ['ü•á', 'ü•à', 'ü•â'];
  const colors = ['#ffd700', '#c0c0c0', '#cd7f32'];
  const top = cachedScores.slice(0, 10);
  for (let i = 0; i < top.length; i++) {
    const s = top[i];
    const y = 155 + i * 36;
    const isNew = s.score === hsCurrentScore && s.timestamp > Date.now() - 5000;
    ctx.font = '18px Creepster';
    ctx.textAlign = 'left';
    ctx.fillStyle = isNew ? '#00ff88' : (colors[i] || 'rgba(255,255,255,0.6)');
    const medal = medals[i] || (i+1) + '.';
    ctx.fillText(medal + ' ' + (s.name||'???'), W/2 - 110, y);
    ctx.textAlign = 'right';
    ctx.fillText(s.score.toLocaleString(), W/2 + 110, y);
  }

  const t = Date.now()/1000;
  ctx.globalAlpha = Math.sin(t*3)*0.3+0.7;
  ctx.font = '20px Creepster';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#c084fc';
  ctx.fillText('Press E or Tap to Continue', W/2, 540);
  ctx.globalAlpha = 1;

  drawMuteIndicator();
}

function drawGameOver() {
  ctx.fillStyle = 'rgba(10,10,10,0.88)';
  ctx.fillRect(0, 0, W, H);

  ctx.font = '52px Creepster';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#f87171';
  ctx.shadowColor = '#f87171';
  ctx.shadowBlur = 25;
  ctx.fillText('GAME OVER', W/2, 220);
  ctx.shadowBlur = 0;

  ctx.font = '24px Creepster';
  ctx.fillStyle = '#e9d5ff';
  ctx.fillText('Score: ' + score, W/2, 280);
  ctx.fillText('Level: ' + level + ' | Lines: ' + lines, W/2, 315);

  if (score >= bestScore && score > 0) {
    ctx.fillStyle = '#eab308';
    ctx.fillText('üèÜ NEW BEST!', W/2, 355);
  }

  const t = Date.now()/1000;
  ctx.globalAlpha = Math.sin(t*3)*0.3+0.7;
  ctx.font = '22px Creepster';
  ctx.fillStyle = '#c084fc';
  ctx.fillText('Press E or Tap to Continue', W/2, 430);
  ctx.globalAlpha = 1;

  drawMuteIndicator();
}

function update() {
  if (state === 'countdown') {
    countdownTimer++;
    if (countdownTimer >= 60) { countdownTimer = 0; countdownNum--; }
    if (countdownNum <= 0) state = 'playing';
    return;
  }
  if (state !== 'playing') return;

  dropTimer++;
  if (dropTimer >= dropInterval) {
    dropTimer = 0;
    if (!collides(piece.shape, pieceX, pieceY + 1)) {
      pieceY++;
    } else {
      lockPiece();
    }
  }

  particles.forEach(p => {
    p.x += p.vx; p.y += p.vy;
    p.vy += 0.15;
    p.life -= 0.025;
  });
  particles = particles.filter(p => p.life > 0);

  // Update gore drips
  goreDrips.forEach(d => {
    d.y += d.vy;
    d.alpha -= d.fadeRate;
    d.wobble += d.wobbleSpeed;
    d.x += Math.sin(d.wobble) * 0.3;
    // Slow down as it drips
    d.vy *= 0.998;
  });
  goreDrips = goreDrips.filter(d => d.alpha > 0 && d.y < BOARD_Y + ROWS * CELL + 10);
}

function render() {
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = 'rgba(10,5,15,0.85)';
  ctx.fillRect(0, 0, W, H);

  // Dim video during gameplay, bright on title (drawTitle handles its own opacity)
  if (state !== 'title') {
    const bgVid = document.getElementById('bg-video');
    if (bgVid) bgVid.style.opacity = '0.25';
  }

  if (state === 'title') { drawTitle(); return; }
  if (state === 'highscore_entry') {
    drawHighScoreEntry();
    return;
  }
  if (state === 'highscore_display') {
    drawHighScoreDisplay();
    return;
  }
  if (state === 'gameover') {
    // Draw board behind overlay
    drawBoard();
    drawGameOver();
    return;
  }

  drawBoard();

  // Countdown
  if (state === 'countdown') {
    ctx.fillStyle = 'rgba(10,10,10,0.6)';
    ctx.fillRect(0, 0, W, H);
    const colors = ['#22c55e','#eab308','#f87171'];
    const scale = 1 + (countdownTimer/60)*0.5;
    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.scale(scale, scale);
    ctx.font = '80px Creepster';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = colors[3-countdownNum] || '#f87171';
    ctx.fillText(countdownNum, 0, 0);
    ctx.restore();
  }

  if (state === 'paused') {
    ctx.fillStyle = 'rgba(10,10,10,0.7)';
    ctx.fillRect(0, 0, W, H);
    ctx.font = '48px Creepster';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#a855f7';
    ctx.fillText('PAUSED', W/2, H/2);
    ctx.font = '20px Creepster';
    ctx.fillStyle = '#c084fc';
    ctx.fillText('Press P to Resume', W/2, H/2+50);
  }

  drawMuteIndicator();
}

function drawBoard() {
  // Board border
  ctx.strokeStyle = '#7c3aed';
  ctx.lineWidth = 2;
  ctx.shadowColor = '#7c3aed';
  ctx.shadowBlur = 10;
  ctx.strokeRect(BOARD_X - 2, BOARD_Y - 2, COLS*CELL + 4, ROWS*CELL + 4);
  ctx.shadowBlur = 0;

  // Board bg
  ctx.fillStyle = 'rgba(20,0,30,0.8)';
  ctx.fillRect(BOARD_X, BOARD_Y, COLS*CELL, ROWS*CELL);

  // Grid lines
  ctx.strokeStyle = 'rgba(168,85,247,0.08)';
  ctx.lineWidth = 1;
  for (let r = 0; r <= ROWS; r++) {
    ctx.beginPath();
    ctx.moveTo(BOARD_X, BOARD_Y + r*CELL);
    ctx.lineTo(BOARD_X + COLS*CELL, BOARD_Y + r*CELL);
    ctx.stroke();
  }
  for (let c = 0; c <= COLS; c++) {
    ctx.beginPath();
    ctx.moveTo(BOARD_X + c*CELL, BOARD_Y);
    ctx.lineTo(BOARD_X + c*CELL, BOARD_Y + ROWS*CELL);
    ctx.stroke();
  }

  // Board cells
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (board[r][c]) drawCell(c, r, board[r][c] - 1);
    }
  }

  // Current piece
  if (piece && (state === 'playing' || state === 'paused')) {
    // Ghost piece
    let ghostY = pieceY;
    while (!collides(piece.shape, pieceX, ghostY + 1)) ghostY++;
    if (ghostY !== pieceY) {
      ctx.globalAlpha = 0.2;
      for (let r = 0; r < piece.shape.length; r++) {
        for (let c = 0; c < piece.shape[r].length; c++) {
          if (piece.shape[r][c]) drawCell(pieceX + c, ghostY + r, pieceType);
        }
      }
      ctx.globalAlpha = 1;
    }

    // Active piece
    for (let r = 0; r < piece.shape.length; r++) {
      for (let c = 0; c < piece.shape[r].length; c++) {
        if (piece.shape[r][c]) drawCell(pieceX + c, pieceY + r, pieceType);
      }
    }
  }

  // Next piece preview
  ctx.font = '14px Creepster';
  ctx.textAlign = 'left';
  ctx.fillStyle = '#c084fc';
  ctx.fillText('NEXT', BOARD_X + COLS*CELL + 15, BOARD_Y + 15);
  if (nextPiece) {
    for (let r = 0; r < nextPiece.shape.length; r++) {
      for (let c = 0; c < nextPiece.shape[r].length; c++) {
        if (nextPiece.shape[r][c]) {
          const nx = BOARD_X + COLS*CELL + 15 + c*20;
          const ny = BOARD_Y + 25 + r*20;
          ctx.fillStyle = COLORS[nextPiece.type];
          ctx.fillRect(nx, ny, 18, 18);
        }
      }
    }
  }

  // HUD
  ctx.font = '16px Creepster';
  ctx.textAlign = 'left';
  ctx.fillStyle = '#e9d5ff';
  const hudX = BOARD_X + COLS*CELL + 15;
  ctx.fillText('SCORE', hudX, BOARD_Y + 120);
  ctx.fillStyle = '#a855f7';
  ctx.font = '22px Creepster';
  ctx.fillText(score, hudX, BOARD_Y + 145);

  ctx.font = '16px Creepster';
  ctx.fillStyle = '#e9d5ff';
  ctx.fillText('LEVEL', hudX, BOARD_Y + 185);
  ctx.fillStyle = '#a855f7';
  ctx.font = '22px Creepster';
  ctx.fillText(level, hudX, BOARD_Y + 210);

  ctx.font = '16px Creepster';
  ctx.fillStyle = '#e9d5ff';
  ctx.fillText('LINES', hudX, BOARD_Y + 250);
  ctx.fillStyle = '#a855f7';
  ctx.font = '22px Creepster';
  ctx.fillText(lines, hudX, BOARD_Y + 275);

  if (bestScore > 0) {
    ctx.font = '14px Creepster';
    ctx.fillStyle = '#eab308';
    ctx.fillText('üèÜ ' + bestScore, hudX, BOARD_Y + 320);
  }

  // Gore drips
  goreDrips.forEach(d => {
    const clipBottom = BOARD_Y + ROWS * CELL;
    if (d.y > clipBottom) return;
    const drawLen = Math.min(d.length, clipBottom - d.y);
    ctx.save();
    ctx.beginPath();
    ctx.rect(BOARD_X, BOARD_Y, COLS * CELL, ROWS * CELL);
    ctx.clip();
    const grad = ctx.createLinearGradient(d.x, d.y - drawLen, d.x, d.y);
    grad.addColorStop(0, d.color + '0)');
    grad.addColorStop(0.3, d.color + (d.alpha * 0.6) + ')');
    grad.addColorStop(1, d.color + d.alpha + ')');
    ctx.strokeStyle = grad;
    ctx.lineWidth = d.width;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(d.x, d.y - drawLen);
    ctx.lineTo(d.x, d.y);
    ctx.stroke();
    // Drip bulge at bottom
    ctx.fillStyle = d.color + d.alpha + ')';
    ctx.beginPath();
    ctx.arc(d.x, d.y, d.width * 0.8, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  });

  // Particles
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    if (p.emoji) {
      ctx.font = `${p.size*3}px serif`;
      ctx.textAlign = 'center';
      ctx.fillText(p.emoji, p.x, p.y);
    } else {
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      ctx.fill();
    }
  });
  ctx.globalAlpha = 1;
}

function loop() { updateMusic(); update(); render(); requestAnimationFrame(loop); }
loop();
</script>
</body>
</html>