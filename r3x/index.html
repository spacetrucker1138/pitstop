<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>R3X // Pitstop Operations</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0a0f;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    font-family: 'Courier New', monospace;
    color: #00ff88;
  }
  #hud {
    width: 800px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px 12px;
    background: #0d1117;
    border: 1px solid #1a2a1a;
    border-bottom: none;
    font-size: 11px;
    letter-spacing: 0.08em;
  }
  #hud .title { color: #00ff88; font-weight: bold; font-size: 13px; }
  #hud .status { color: #556655; }
  #hud .status.online { color: #00ff88; }
  #hud .status.fallback { color: #ff8800; }
  #canvas-wrap {
    position: relative;
    width: 800px;
    border: 1px solid #1a2a1a;
    background: #111118;
  }
  canvas { display: block; }
  #taskbar {
    width: 800px;
    background: #0d1117;
    border: 1px solid #1a2a1a;
    border-top: 1px solid #00ff8822;
    padding: 6px 12px;
    display: flex;
    gap: 12px;
    font-size: 10px;
    color: #334433;
    letter-spacing: 0.06em;
  }
  #taskbar span { cursor: pointer; transition: color 0.2s; }
  #taskbar span:hover { color: #00ff88; }
  #taskbar span.active { color: #00ff88; }
</style>
</head>
<body>

<div id="hud">
  <span class="title">R3X // PITSTOP OPS</span>
  <span id="hud-room">LOBBY</span>
  <span id="hud-status" class="status">● CONNECTING...</span>
</div>

<div id="canvas-wrap">
  <canvas id="world" width="800" height="420"></canvas>
</div>

<div id="taskbar">
  <span onclick="R3X.setRoom('lobby')"    id="btn-lobby"  class="active">[ LOBBY ]</span>
  <span onclick="R3X.setRoom('code')"     id="btn-code"          >[ CODE LAB ]</span>
  <span onclick="R3X.setRoom('art')"      id="btn-art"           >[ ART STUDIO ]</span>
  <span onclick="R3X.setRoom('comms')"    id="btn-comms"         >[ COMMS ]</span>
  <span onclick="R3X.setRoom('tasks')"    id="btn-tasks"         >[ TASK BOARD ]</span>
</div>

<script>
// ─────────────────────────────────────────────
//  SPRITE CONFIG
//  Sheet: 2048×512 | cell: 128×128
//  Row 0 = stand (1 frame)
//  Row 1 = walk  (16 frames)
//  Row 2 = run   (16 frames)
//  Row 3 = jump  (16 frames)
// ─────────────────────────────────────────────
const CELL_W = 128, CELL_H = 128;
const ANIMS = {
  stand:    { row: 0,  frames: 1,  fps: 4  },
  walk:     { row: 1,  frames: 16, fps: 10 },
  run:      { row: 2,  frames: 16, fps: 22 },
  jump:     { row: 3,  frames: 16, fps: 16 },
  comms:    { row: 4,  frames: 16, fps: 12 },  // talking / comms room idle
  art:      { row: 5,  frames: 16, fps: 14 },  // painting / art room idle
  repair:   { row: 6,  frames: 16, fps: 10 },  // wrenching / code room idle
  pingpong: { row: 7,  frames: 16, fps: 18 },  // lobby idle 1
  march:    { row: 8,  frames: 16, fps: 10 },  // lobby idle 2
  sweep:    { row: 9,  frames: 16, fps: 12 },  // tasks idle (sweeping)
  portal:   { row: 10, frames: 16, fps: 14 },  // tasks active (portal fire)
};

// ─────────────────────────────────────────────
//  ROOMS
// ─────────────────────────────────────────────
const ROOMS = {
  lobby: {
    label: "LOBBY",
    bg: "#12121c",
    accent: "#1a2a3a",
    floorY: 300,
    elements: [
      { type: "door",  x: 60,  y: 200, w: 60,  h: 100, color: "#1a2a1a", label: null },
      { type: "sign",  x: 350, y: 100, w: 120, h: 40,  color: "#0d1a0d", label: "PITSTOP OPS" },
      { type: "desk",  x: 560, y: 230, w: 120, h: 60,  color: "#1a1a2a", label: null },
      { type: "vent",  x: 700, y: 80,  w: 60,  h: 40,  color: "#0a1a1a", label: null },
    ],
    ambientText: "Security sweep. All clear.",
    idleAnim: "pingpong",
    idleAnim2: "march",
    walkAnim: "walk",
  },
  code: {
    label: "CODE LAB",
    bg: "#0d1520",
    accent: "#0a2040",
    floorY: 300,
    elements: [
      { type: "monitor", x: 80,  y: 160, w: 180, h: 120, color: "#0a1a0a", label: "COMPILING..." },
      { type: "monitor", x: 300, y: 180, w: 140, h: 100, color: "#0a1a0a", label: "PROCESS_ID: 4491" },
      { type: "rack",    x: 560, y: 120, w: 80,  h: 180, color: "#101520", label: null },
      { type: "cable",   x: 650, y: 280, w: 120, h: 10,  color: "#1a2a1a", label: null },
    ],
    ambientText: "Build in progress.",
    idleAnim: "repair",
    walkAnim: "run",
  },
  art: {
    label: "ART STUDIO",
    bg: "#1a0f18",
    accent: "#2a0a20",
    floorY: 300,
    elements: [
      { type: "canvas", x: 80,  y: 100, w: 120, h: 160, color: "#1a0a1a", label: null },
      { type: "canvas", x: 230, y: 130, w: 90,  h: 120, color: "#180a18", label: null },
      { type: "table",  x: 450, y: 250, w: 160, h: 50,  color: "#1a0f18", label: null },
      { type: "light",  x: 680, y: 60,  w: 40,  h: 80,  color: "#2a1a00", label: null },
    ],
    ambientText: "Running the renders.",
    idleAnim: "art",
    walkAnim: "walk",
  },
  comms: {
    label: "COMMS ROOM",
    bg: "#0f1a10",
    accent: "#0a2a10",
    floorY: 300,
    elements: [
      { type: "antenna", x: 120, y: 60,  w: 20,  h: 140, color: "#00ff8833", label: null },
      { type: "panel",   x: 200, y: 160, w: 200, h: 130, color: "#0a1a0a",   label: "SIGNAL: ACTIVE" },
      { type: "printer", x: 480, y: 250, w: 100, h: 60,  color: "#0f1a0f",   label: null },
      { type: "bin",     x: 650, y: 270, w: 50,  h: 50,  color: "#0a100a",   label: null },
    ],
    ambientText: "All messages relayed.",
    idleAnim: "comms",
    walkAnim: "walk",
  },
  tasks: {
    label: "TASK BOARD",
    bg: "#1a1200",
    accent: "#2a1a00",
    floorY: 300,
    elements: [
      { type: "board",  x: 60,  y: 80,  w: 300, h: 200, color: "#1a1000", label: "TASK BOARD" },
      { type: "note",   x: 80,  y: 120, w: 60,  h: 40,  color: "#2a1a00", label: "▣ SPRITE V2" },
      { type: "note",   x: 160, y: 120, w: 60,  h: 40,  color: "#2a1a00", label: "▣ WIRE STATE" },
      { type: "note",   x: 240, y: 120, w: 60,  h: 40,  color: "#2a2000", label: "▣ HEARTBEAT" },
      { type: "chair",  x: 560, y: 250, w: 80,  h: 70,  color: "#1a1200", label: null },
    ],
    ambientText: "Tasks queued. Standing by.",
    idleAnim: "sweep",
    idleAnim2: "portal",
    walkAnim: "walk",
  },
};

// ─────────────────────────────────────────────
//  DIALOGUE LINES (per room)
// ─────────────────────────────────────────────
const DIALOGUE = {
  lobby:  ["Quiet shift. The way I like it.", "Perimeter clear.", "Sector scanned. Nothing unusual.", "Standing by.", "Entry logged."],
  code:   ["Build running.", "Compilation in progress.", "No errors found. Yet.", "Process 4491 still alive.", "Deploying..."],
  art:    ["Rendering.", "Pixels take time. So do cigars.", "Waiting on the pipeline.", "Frame 1 of too many.", "Color pass. Looking good."],
  comms:  ["Message received.", "Relay confirmed.", "Signal strong.", "Transmitting now.", "Inbox clear."],
  tasks:  ["Tasks queued.", "Working the board.", "Nothing falls through here.", "Priority order maintained.", "Next item loading..."],
};

// ─────────────────────────────────────────────
//  FALLBACK PATROL SCRIPT
// ─────────────────────────────────────────────
const PATROL = ["lobby", "code", "art", "comms", "tasks", "lobby"];

// ─────────────────────────────────────────────
//  HEARTBEAT
// ─────────────────────────────────────────────
const HEARTBEAT_URL = "https://gist.githubusercontent.com/spacetrucker1138/e92fa584a52314a180b947c309440357/raw/r3x-state.json"; // R3X agent state gist
const HEARTBEAT_INTERVAL_MS = 5000;
const HEARTBEAT_MISS_LIMIT = 3;

// ─────────────────────────────────────────────
//  MAIN ENGINE
// ─────────────────────────────────────────────
const canvas = document.getElementById("world");
const ctx = canvas.getContext("2d");
const W = canvas.width, H = canvas.height;

const sprite = new Image();
sprite.src = "https://raw.githubusercontent.com/spacetrucker1138/pitstop/main/assets/r3x/r3x_v4_sprites.webp";

let state = {
  room: "lobby",
  r3x: {
    x: 200, y: 0, vy: 0, grounded: true,
    facing: 1,          // 1=right, -1=left
    anim: "walk",
    frame: 0,
    frameTick: 0,
    targetX: 200,
    moving: false,
    isJumping: false,
  },
  dialogue: { text: "", alpha: 0, timer: 0 },
  particles: [],        // cigar smoke
  online: false,
  fallback: false,
  missCount: 0,
  patrolIdx: 0,
  patrolTimer: 0,
  idleCycleTimer: 0,
  idleCyclePhase: 0,       // 0 = primary idle, 1 = secondary idle
  transitioning: false,
  transitionAlpha: 0,
  transitionDir: 1,
};

// Set floor Y from room config
function floorY() {
  return ROOMS[state.room].floorY;
}

function setDialogue(text) {
  state.dialogue.text = text;
  state.dialogue.alpha = 1;
  state.dialogue.timer = 220;
}

function pickDialogue(room) {
  const lines = DIALOGUE[room] || DIALOGUE.lobby;
  return lines[Math.floor(Math.random() * lines.length)];
}

function walkTo(targetX, onArrive) {
  const r = state.r3x;
  r.targetX = targetX;
  r.moving = true;
  r.facing = targetX > r.x ? 1 : -1;
  r.anim = ROOMS[state.room].walkAnim;
  r._onArrive = onArrive || null;
}

// ─────────────────────────────────────────────
//  DRAW HELPERS
// ─────────────────────────────────────────────
function drawRoom(room) {
  const cfg = ROOMS[room];
  // Background gradient
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, cfg.bg);
  grad.addColorStop(1, cfg.accent);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Floor
  ctx.fillStyle = "#0a0a10";
  ctx.fillRect(0, cfg.floorY + 30, W, H - cfg.floorY - 30);
  ctx.fillStyle = "#00ff8820";
  ctx.fillRect(0, cfg.floorY + 28, W, 2);

  // Scanline overlay (subtle)
  for (let sy = 0; sy < H; sy += 4) {
    ctx.fillStyle = "rgba(0,0,0,0.06)";
    ctx.fillRect(0, sy, W, 2);
  }

  // Room elements
  for (const el of cfg.elements) {
    drawElement(el);
  }

  // Room label
  ctx.font = "bold 10px 'Courier New'";
  ctx.fillStyle = "#00ff8840";
  ctx.fillText(`// ${cfg.label}`, 12, 22);
}

function drawElement(el) {
  ctx.save();
  switch (el.type) {
    case "monitor":
      ctx.fillStyle = "#1a1a2a";
      ctx.fillRect(el.x, el.y, el.w, el.h);
      ctx.strokeStyle = "#00ff8830";
      ctx.lineWidth = 1;
      ctx.strokeRect(el.x, el.y, el.w, el.h);
      if (el.label) {
        // Animated text flicker
        ctx.fillStyle = `rgba(0,255,136,${0.4 + 0.3 * Math.sin(Date.now()/400)})`;
        ctx.font = "9px 'Courier New'";
        ctx.fillText(el.label, el.x + 8, el.y + 20);
        // Cursor blink
        if (Math.floor(Date.now()/500) % 2 === 0) {
          ctx.fillStyle = "#00ff88aa";
          ctx.fillText("▮", el.x + 8, el.y + 36);
        }
      }
      break;
    case "board":
      ctx.fillStyle = el.color;
      ctx.fillRect(el.x, el.y, el.w, el.h);
      ctx.strokeStyle = "#ff880030";
      ctx.lineWidth = 1;
      ctx.strokeRect(el.x, el.y, el.w, el.h);
      if (el.label) {
        ctx.fillStyle = "#ff8800aa";
        ctx.font = "bold 9px 'Courier New'";
        ctx.fillText(el.label, el.x + 6, el.y + 14);
      }
      break;
    case "note":
      ctx.fillStyle = el.color;
      ctx.fillRect(el.x, el.y, el.w, el.h);
      ctx.strokeStyle = "#ff880060";
      ctx.lineWidth = 1;
      ctx.strokeRect(el.x, el.y, el.w, el.h);
      if (el.label) {
        ctx.fillStyle = "#ffaa44cc";
        ctx.font = "7px 'Courier New'";
        ctx.fillText(el.label, el.x + 3, el.y + 13);
      }
      break;
    case "antenna":
      ctx.fillStyle = el.color;
      ctx.fillRect(el.x, el.y, el.w, el.h);
      // Pulse ring
      const pulse = (Math.sin(Date.now() / 600) + 1) / 2;
      ctx.strokeStyle = `rgba(0,255,136,${pulse * 0.3})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(el.x + el.w/2, el.y, 20 + pulse * 15, 0, Math.PI * 2);
      ctx.stroke();
      break;
    case "panel":
      ctx.fillStyle = el.color;
      ctx.fillRect(el.x, el.y, el.w, el.h);
      ctx.strokeStyle = "#00ff8830";
      ctx.lineWidth = 1;
      ctx.strokeRect(el.x, el.y, el.w, el.h);
      if (el.label) {
        ctx.fillStyle = "#00ff88bb";
        ctx.font = "9px 'Courier New'";
        ctx.fillText(el.label, el.x + 6, el.y + 18);
      }
      // Signal bars
      for (let b = 0; b < 5; b++) {
        const bh = (b + 1) * 8;
        const active = b <= Math.floor((Math.sin(Date.now()/800) + 1) / 2 * 4);
        ctx.fillStyle = active ? "#00ff8888" : "#0a1a0a";
        ctx.fillRect(el.x + 8 + b * 16, el.y + el.h - bh - 10, 10, bh);
      }
      break;
    case "sign":
      ctx.fillStyle = el.color;
      ctx.fillRect(el.x, el.y, el.w, el.h);
      ctx.strokeStyle = "#00ff8860";
      ctx.lineWidth = 1;
      ctx.strokeRect(el.x, el.y, el.w, el.h);
      if (el.label) {
        ctx.fillStyle = "#00ff88";
        ctx.font = "bold 10px 'Courier New'";
        ctx.textAlign = "center";
        ctx.fillText(el.label, el.x + el.w/2, el.y + el.h/2 + 4);
        ctx.textAlign = "left";
      }
      break;
    default:
      ctx.fillStyle = el.color;
      ctx.fillRect(el.x, el.y, el.w, el.h);
      ctx.strokeStyle = "#00ff8815";
      ctx.lineWidth = 1;
      ctx.strokeRect(el.x, el.y, el.w, el.h);
      if (el.label) {
        ctx.fillStyle = "#00ff8877";
        ctx.font = "9px 'Courier New'";
        ctx.fillText(el.label, el.x + 4, el.y + 14);
      }
  }
  ctx.restore();
}

function drawR3X() {
  const r = state.r3x;
  const anim = ANIMS[r.anim] || ANIMS.stand;
  const frameIdx = Math.floor(r.frame) % anim.frames;

  const sx = frameIdx * CELL_W;
  const sy = anim.row * CELL_H;
  const drawSize = 80;
  const drawX = r.x - drawSize / 2;
  const drawY = r.y - drawSize;

  ctx.save();
  if (r.facing === -1) {
    // Flip horizontally
    ctx.translate(r.x * 2, 0);
    ctx.scale(-1, 1);
  }
  ctx.drawImage(sprite, sx, sy, CELL_W, CELL_H, r.facing === -1 ? (r.x * 2 - r.x - drawSize/2) : drawX, drawY, drawSize, drawSize);
  ctx.restore();

  // Shadow
  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.fillStyle = "#000";
  ctx.beginPath();
  ctx.ellipse(r.x, r.y + 2, 22, 6, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawSmoke() {
  for (const p of state.particles) {
    ctx.save();
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = "#aaaaaa";
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

function drawDialogue() {
  const d = state.dialogue;
  if (d.alpha <= 0) return;
  const r = state.r3x;
  const bx = r.x - 90;
  const by = r.y - 100;

  ctx.save();
  ctx.globalAlpha = Math.min(d.alpha, 1);
  ctx.fillStyle = "#0d1117ee";
  ctx.strokeStyle = "#00ff8888";
  ctx.lineWidth = 1;
  const bw = 180, bh = 36;
  ctx.fillRect(bx, by, bw, bh);
  ctx.strokeRect(bx, by, bw, bh);
  ctx.fillStyle = "#00ff88";
  ctx.font = "9px 'Courier New'";
  // Word wrap at 170px
  const words = d.text.split(" ");
  let line = "", lines = [];
  for (const w of words) {
    const test = line + w + " ";
    if (ctx.measureText(test).width > 165 && line) {
      lines.push(line.trim()); line = w + " ";
    } else { line = test; }
  }
  lines.push(line.trim());
  lines.slice(0, 3).forEach((l, i) => ctx.fillText(l, bx + 8, by + 14 + i * 12));
  ctx.restore();
}

function drawFallbackBadge() {
  if (!state.fallback) return;
  ctx.save();
  ctx.fillStyle = "#ff880022";
  ctx.fillRect(W - 140, 8, 132, 18);
  ctx.strokeStyle = "#ff880060";
  ctx.lineWidth = 1;
  ctx.strokeRect(W - 140, 8, 132, 18);
  ctx.fillStyle = "#ff8800aa";
  ctx.font = "9px 'Courier New'";
  ctx.fillText("◌ OFFLINE // PATROL", W - 134, 21);
  ctx.restore();
}

function drawTransition() {
  if (state.transitionAlpha <= 0) return;
  ctx.save();
  ctx.globalAlpha = state.transitionAlpha;
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, W, H);
  ctx.restore();
}

// ─────────────────────────────────────────────
//  PHYSICS + ANIMATION TICK
// ─────────────────────────────────────────────
function tick() {
  const r = state.r3x;
  const floor = floorY();

  // Animation frame advance
  const anim = ANIMS[r.anim] || ANIMS.stand;
  r.frameTick++;
  if (r.frameTick >= Math.round(60 / anim.fps)) {
    r.frame = (r.frame + 1) % anim.frames;
    r.frameTick = 0;
  }

  // Movement
  if (r.moving) {
    const speed = r.anim === "run" ? 4 : 2.5;
    const dx = r.targetX - r.x;
    if (Math.abs(dx) < speed + 1) {
      r.x = r.targetX;
      r.moving = false;
      r.anim = ROOMS[state.room].idleAnim;
      state.idleCycleTimer = 0;
      state.idleCyclePhase = 0;
      if (r._onArrive) { r._onArrive(); r._onArrive = null; }
    } else {
      r.x += Math.sign(dx) * speed;
    }
  }

  // Gravity
  if (!r.grounded) {
    r.vy += 0.5;
    r.y += r.vy;
    if (r.y >= floor + 30) {
      r.y = floor + 30;
      r.vy = 0;
      r.grounded = true;
      r.isJumping = false;
      r.anim = r.moving ? ROOMS[state.room].walkAnim : ROOMS[state.room].idleAnim;
    }
  } else {
    r.y = floor + 30;
  }

  // Smoke particles
  if (Math.random() < 0.08) {
    state.particles.push({
      x: r.x + (r.facing * 20),
      y: r.y - 55,
      r: 2 + Math.random() * 3,
      alpha: 0.4,
      vx: r.facing * 0.2 + (Math.random() - 0.5) * 0.4,
      vy: -0.4 - Math.random() * 0.3,
    });
  }
  for (const p of state.particles) {
    p.x += p.vx; p.y += p.vy; p.r += 0.04; p.alpha -= 0.008;
  }
  state.particles = state.particles.filter(p => p.alpha > 0);

  // Dialogue timer
  if (state.dialogue.timer > 0) {
    state.dialogue.timer--;
    if (state.dialogue.timer < 60) state.dialogue.alpha = state.dialogue.timer / 60;
  }

  // Transition fade
  if (state.transitioning) {
    state.transitionAlpha += state.transitionDir * 0.06;
    if (state.transitionAlpha >= 1) {
      // Room switch at peak black
      state.transitionDir = -1;
      performRoomSwitch();
    }
    if (state.transitionAlpha <= 0) {
      state.transitioning = false;
      state.transitionAlpha = 0;
    }
  }

  // Idle animation cycling (primary ↔ secondary idle)
  if (!r.moving && !state.transitioning) {
    state.idleCycleTimer++;
    const room = ROOMS[state.room];
    const hasCycle = !!room.idleAnim2;
    if (hasCycle) {
      // Switch every ~15 seconds (900 frames at 60fps)
      const switchAt = state.idleCyclePhase === 0 ? 900 : 540;
      if (state.idleCycleTimer >= switchAt) {
        state.idleCycleTimer = 0;
        state.idleCyclePhase = state.idleCyclePhase === 0 ? 1 : 0;
        r.anim = state.idleCyclePhase === 0 ? room.idleAnim : room.idleAnim2;
        r.frame = 0;
      }
    }
  }

  // Fallback patrol
  if (state.fallback) {
    state.patrolTimer--;
    if (state.patrolTimer <= 0 && !r.moving && !state.transitioning) {
      state.patrolIdx = (state.patrolIdx + 1) % PATROL.length;
      triggerRoomTransition(PATROL[state.patrolIdx]);
    }
  }
}

// ─────────────────────────────────────────────
//  ROOM TRANSITION
// ─────────────────────────────────────────────
let _pendingRoom = null;
function triggerRoomTransition(room) {
  if (state.transitioning) return;
  _pendingRoom = room;
  state.transitioning = true;
  state.transitionDir = 1;
  state.transitionAlpha = 0;
  // Walk R3X to door direction first
  const r = state.r3x;
  r.anim = ROOMS[state.room].walkAnim;
  r.moving = true;
  r.facing = 1;
  r.targetX = W + 50;
}

function performRoomSwitch() {
  if (!_pendingRoom) return;
  state.room = _pendingRoom;
  _pendingRoom = null;
  const r = state.r3x;
  r.x = -50;
  r.y = ROOMS[state.room].floorY + 30;
  r.facing = 1;
  r.anim = ROOMS[state.room].walkAnim;
  const destX = 150 + Math.random() * 400;
  walkTo(destX, () => {
    setDialogue(pickDialogue(state.room));
    state.patrolTimer = 280 + Math.floor(Math.random() * 120);
  });
  // Update HUD
  document.getElementById("hud-room").textContent = ROOMS[state.room].label;
  updateTaskbar(state.room);
}

function updateTaskbar(room) {
  for (const id of ["lobby","code","art","comms","tasks"]) {
    document.getElementById("btn-"+id).classList.toggle("active", id === room);
  }
}

// ─────────────────────────────────────────────
//  RENDER
// ─────────────────────────────────────────────
function render() {
  ctx.clearRect(0, 0, W, H);
  drawRoom(state.room);
  drawSmoke();
  drawR3X();
  drawDialogue();
  drawFallbackBadge();
  drawTransition();
}

function loop() {
  tick();
  render();
  requestAnimationFrame(loop);
}

// ─────────────────────────────────────────────
//  HEARTBEAT
// ─────────────────────────────────────────────
function heartbeat() {
  if (!HEARTBEAT_URL) {
    // No endpoint configured — simulate connected, stay online
    setOnline(true);
    return;
  }
  fetch(HEARTBEAT_URL, { method: "GET", timeout: 4000 })
    .then(r => r.json())
    .then(data => {
      state.missCount = 0;
      setOnline(true);
      // If agent pushes a room update
      // Route to unified setState handler
      window.R3X.setState({
        room: data.room,
        message: data.message,
        anim: data.anim
      });
    })
    .catch(() => {
      state.missCount++;
      if (state.missCount >= HEARTBEAT_MISS_LIMIT) {
        setOnline(false);
      }
    });
}

function setOnline(online) {
  const wasOnline = state.online;
  state.online = online;
  state.fallback = !online;
  const el = document.getElementById("hud-status");
  if (online) {
    el.textContent = "● CONNECTED";
    el.className = "status online";
    if (!wasOnline) {
      setDialogue("Back online. Missed nothing.");
      state.patrolTimer = 9999;
    }
  } else {
    el.textContent = "◌ FALLBACK";
    el.className = "status fallback";
    if (wasOnline) {
      setDialogue("Connection lost. Holding position.");
      state.patrolTimer = 180;
    }
  }
}

// ─────────────────────────────────────────────
//  PUBLIC API
// ─────────────────────────────────────────────
window.R3X = {
  setRoom(room) {
    if (!ROOMS[room]) return;
    if (room === state.room) return;
    triggerRoomTransition(room);
    if (!state.fallback) {
      document.getElementById("hud-status").textContent = "● CONNECTED";
    }
  },
  say(text) {
    setDialogue(text);
  },
  setState(payload) {
    // payload: { room?, message?, anim? }
    if (payload.room && ROOMS[payload.room] && payload.room !== state.room) {
      triggerRoomTransition(payload.room);
    }
    if (payload.message) setDialogue(payload.message);
    if (payload.anim && ANIMS[payload.anim]) {
      state.r3x.anim = payload.anim;
      state.r3x.frame = 0;
    }
  },
  getState() {
    return { room: state.room, online: state.online, fallback: state.fallback };
  }
};

// ─────────────────────────────────────────────
//  BOOT
// ─────────────────────────────────────────────
sprite.onload = () => {
  // Init R3X position
  const r = state.r3x;
  r.y = ROOMS[state.room].floorY + 30;
  r.x = -50;
  r.facing = 1;
  r.anim = ROOMS[state.room].walkAnim;
  walkTo(200, () => {
    setDialogue("R3X online. Sector secure.");
    state.patrolTimer = 9999;
  });

  // Start heartbeat poll
  heartbeat();
  setInterval(heartbeat, HEARTBEAT_INTERVAL_MS);

  // Start render loop
  loop();
};

sprite.onerror = () => {
  console.error("R3X: sprite sheet failed to load");
};
</script>
</body>
</html>